<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>KSLEO</title>
    <link href="https://leokang28.github.io/atom.xml" rel="self"/>
    <link href="https:&#x2F;&#x2F;leokang28.github.io"/>
    <updated>2026-01-07T09:17:30+0000</updated>
    <id>https:&#x2F;&#x2F;leokang28.github.io</id>

    
    
    
    
        
        <entry>
            <title>Using Structs</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;03-struct&#x2F;"/>
            <updated>2022-05-15T03:43:32+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;03-struct&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-3-using-structs-to-structure-related-data&amp;quot;&amp;gt;Chapter 3 - Using Structs to Structure Related Data&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;结构体是一个编码者自定义的数据类型，可以让编码者自己命名，组织一些数据形成一个有特殊意义的集合。跟面向对象概念中的对象概念类似。结构体和枚举是创建新类型的基础，以致能够充分利用 Rust 编译器做类型检查。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-jie-gou-ti-de-ding-yi-he-shi-li-hua&amp;quot;&amp;gt;Section 1 - 结构体的定义和实例化&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;结构体跟元组有些类似，它内部的数据也可以是不同的类型。与元组不同的地方是，你可以对每个数据命名，便于理解这些数据具体代表的是什么含义。由于有了这些名称，你不再需要像元组一样按顺序访问内部元素。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;struct&amp;lt;&amp;#x2F;code&amp;gt;关键字后加一个名称就定义了一个结构体。结构体的自定义名称应该是充分语义化的，能够传达内部数据为何要组织在一起。在花括号中，定义了每个元素的名称和类型，这些内部元素称之为&amp;lt;em&amp;gt;fields（字段）&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;通过结构体生成的变量称之为&amp;lt;em&amp;gt;instance（实例）&amp;lt;&amp;#x2F;em&amp;gt;。创建一个实例需要指明使用的结构体名称，并且以&amp;lt;em&amp;gt;key-value&amp;lt;&amp;#x2F;em&amp;gt;的形式填充每一个字段。key 是在结构体中定义好的字段名称，value 是我们想要在对应的字段中存储的数据。实例化的时候，字段顺序不需要和结构体定义的顺序一致。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let user1 = User {
    email: String::from(&amp;amp;quot;someone@example.com&amp;amp;quot;),
    username: String::from(&amp;amp;quot;someusername123&amp;amp;quot;),
    active: true,
    sign_in_count: 1,
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;获取实例中的数据可以通过点操作符，例如&amp;lt;code&amp;gt;user1.email&amp;lt;&amp;#x2F;code&amp;gt;。只要该实例是 mutable 的，我们就可以对它上面的字段数据做修改，例如&amp;lt;code&amp;gt;user1.mail = String::from(&amp;quot;anotheremail@example.com&amp;quot;);&amp;lt;&amp;#x2F;code&amp;gt;。需要注意，在改变数据时，实例本身需要是 mutable 的，Rust 不允许仅其中某些字段为 mutable。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;与其他表达式一样，可以在函数最后实例化一个结构体并将其作为函数返回值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn build_user(email: String, username: String) -&amp;amp;gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-li-hua-jian-xie&amp;quot;&amp;gt;实例化简写&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;因为参数名和字段名是完全相等的，可以通过字段初始化简写语法来创建实例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn build_user(email: String, username: String) -&amp;amp;gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;tong-guo-qi-ta-shi-li-chuang-jian-xin-shi-li&amp;quot;&amp;gt;通过其他实例创建新实例&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过已经存在的实例创建新实例是一个非常便捷的方法，并且可以使用结构体更新语法。先看一下使用普通方法的例子&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let user2 = User {
    email: String::from(&amp;amp;quot;another@example.com&amp;amp;quot;),
    username: String::from(&amp;amp;quot;anotherusername567&amp;amp;quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;创建一个新实例&amp;lt;code&amp;gt;user2&amp;lt;&amp;#x2F;code&amp;gt;，并且&amp;lt;code&amp;gt;active&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;sign_in_count&amp;lt;&amp;#x2F;code&amp;gt;这两个字段是从&amp;lt;code&amp;gt;user1&amp;lt;&amp;#x2F;code&amp;gt;取值的。使用结构体更新语法可以使代码量更少。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let user2 = User {
    email: String::from(&amp;amp;quot;another@example.com&amp;amp;quot;),
    username: String::from(&amp;amp;quot;anotherusername567&amp;amp;quot;),
    ..user1
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-yuan-zu-he-jie-gou-ti-gou-zao-xin-lei-xing&amp;quot;&amp;gt;使用元组和结构体构造新类型&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以定义一些像元组一样的结构体，称之为元组结构体。元组结构体具有语义化的名称，但是没有字段名，也就是说只有字段类型。元组结构体在给元组命名和与其他元组做区分时特别有用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;元组结构体的定义：&amp;lt;code&amp;gt;struct&amp;lt;&amp;#x2F;code&amp;gt;关键字加一个名称，后面再跟一个括号，里面是字段类型列表。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;black&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;origin&amp;lt;&amp;#x2F;code&amp;gt;是不同的变量，因为他们结构体的名称不同，哪怕他们内部的字段类型列表是完全一致的。元组结构体的实例和普通的元组在操作上没有任何区别。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;unit-like-structs-without-any-fields&amp;quot;&amp;gt;Unit-Like Structs Without Any Fields&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;结构体定义时也可以没有任何的字段，这种结构体称为&amp;lt;em&amp;gt;unit-like struct（类单元结构）&amp;lt;&amp;#x2F;em&amp;gt;，因为他们的表现跟单元类型&amp;lt;code&amp;gt;()&amp;lt;&amp;#x2F;code&amp;gt;相似。当你需要在某个类型上实现某些 trait，但又不想存储任何数据时，类单元结构很有用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-yi-ge-jie-gou-ti-shi-li-cheng-xu&amp;quot;&amp;gt;Section 2 - 一个结构体示例程序&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;写一个计算矩形面积的程序，从普通的变量开始。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let width1 = 50;
    let height1 = 30;

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, area(width1, height1));
}

fn area(width:u32, height:u32) -&amp;amp;gt; u32 {
    width * height
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;矩形的高度和宽度是两个关联的变量，因为他们构成了一个矩形，但是目前在程序中看不到任何关联性，可读性太差。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-yuan-zu-zhong-gou&amp;quot;&amp;gt;使用元组重构&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let rect1 = (50, 30);

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, area(rect1));
}

fn area(rect: (u32, u32)) -&amp;amp;gt; u32 {
    rect.0 * rect.1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用元组稍微有了一些结构性，但是在可读性还是不够好，因为元组不能够对字段进行命名。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-jie-gou-ti-zhong-gou&amp;quot;&amp;gt;使用结构体重构&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Rect {
    width: u32,
    height: u32,
}
fn main() {
    let rect1= Rect {
        width: 50,
        height: 30,
    };

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, area(rect1));
}

fn area(rect: Rect) -&amp;amp;gt; u32 {
    rect.width * rect.height
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;定义一个矩形类型之后，代码目前可读性和抽象都比较好。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-fang-fa-yu-fa&amp;quot;&amp;gt;Section 3 - 方法语法&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;方法和函数的唯一区别在于，方法是定义在类型中的，有它特定的执行上下文。方法的第一个参数永远是&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;，是一个当前调用它的实例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fang-fa-ding-yi&amp;quot;&amp;gt;方法定义&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Rect {
    width: u32,
    height: u32,
}

&amp;amp;#x2F;&amp;amp;#x2F; 方法定义
impl Rect {
    fn area(&amp;amp;amp;self) -&amp;amp;gt; u32 {
        self.width * self.height
    }
}
fn main() {
    let rect1= Rect {
        width: 50,
        height: 30,
    };

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, rect1.area());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;:::details -&amp;amp;gt;和.
在 C&amp;#x2F;C++中，方法的调用有两种操作符，分别是&amp;lt;code&amp;gt;-&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;.&amp;lt;&amp;#x2F;code&amp;gt;。当直接在实例上调用方法时使用&amp;lt;code&amp;gt;.&amp;lt;&amp;#x2F;code&amp;gt;操作符，当使用指针调用方法时使用&amp;lt;code&amp;gt;-&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符。也就是说当&amp;lt;code&amp;gt;obj&amp;lt;&amp;#x2F;code&amp;gt;是一个指针时，&amp;lt;code&amp;gt;obj-&amp;amp;gt;func()&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;(*obj).func()&amp;lt;&amp;#x2F;code&amp;gt;是一样的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 中没有和&amp;lt;code&amp;gt;-&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;等同的操作符，Rust 的方案是自动引用和解析引用。当你通过&amp;lt;code&amp;gt;obj.func()&amp;lt;&amp;#x2F;code&amp;gt;调用方法时，Rust 会自动加上&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;&amp;amp;amp;mut&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;*&amp;lt;&amp;#x2F;code&amp;gt;，让&amp;lt;code&amp;gt;obj&amp;lt;&amp;#x2F;code&amp;gt;能够跟函数声明匹配。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;duo-ge-can-shu-de-fang-fa&amp;quot;&amp;gt;多个参数的方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let rect1 = Rect {
        width: 30,
        height: 50,
    };
    let rect2 = Rect {
        width: 10,
        height: 40,
    };
    let rect3 = Rect {
        width: 60,
        height: 45,
    };

    println!(&amp;amp;quot;Can rect1 hold rect2? {}&amp;amp;quot;, rect1.can_hold(&amp;amp;amp;rect2));
    println!(&amp;amp;quot;Can rect1 hold rect3? {}&amp;amp;quot;, rect1.can_hold(&amp;amp;amp;rect3));
}

impl Rect {
    fn area(&amp;amp;amp;self) -&amp;amp;gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;amp;amp;self, other: &amp;amp;amp;Rect) -&amp;amp;gt; bool {
        self.width &amp;amp;gt; other.width &amp;amp;amp;&amp;amp;amp; self.height &amp;amp;gt; other.height
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;duo-ge-impldai-ma-kuai&amp;quot;&amp;gt;多个&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 是允许多个&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块的，例如&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Rect {
    fn area(&amp;amp;amp;self) -&amp;amp;gt; u32 {
        self.width * self.height
    }
}

impl Rect {
    fn can_hold(&amp;amp;amp;self, other: &amp;amp;amp;Rect) -&amp;amp;gt; bool {
        self.width &amp;amp;gt; other.width &amp;amp;amp;&amp;amp;amp; self.height &amp;amp;gt; other.height
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;目前没有必要写成多个&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块，后面会介绍到这种方法的适用情况。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Enums and Pattern Matching</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;04-enums-and-pattern-matching&#x2F;"/>
            <updated>2022-01-20T08:01:35+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;04-enums-and-pattern-matching&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-4-enums-and-pattern-matching&amp;quot;&amp;gt;Chapter 4 - Enums and Pattern Matching&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;enumerations 枚举&amp;lt;&amp;#x2F;em&amp;gt;定义一个类型，用来穷举所有可能的数据。很多语言都有枚举类型，但它们的含义和用法有些差别。Rust 更接近于函数式编程语言中的枚举类型，&amp;lt;em&amp;gt;algebraic data types&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-ding-yi-yi-ge-mei-ju&amp;quot;&amp;gt;Section 1 - 定义一个枚举&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;先考虑一个场景，在这个场景下枚举比结构体更适合，比如需要做一个 IP 地址相关的功能。目前 IP 地址有个两个版本在使用中，V4 和 V6。所有 IP 地址只可能是这两个版本其中之一，所以我们可以用枚举穷举所有可能性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;IP 地址这种确定性（只能在这两个版本中，总的集合确定）和互斥性（只能是其中之一）是枚举类型最好的使用场景。而且不管是哪个版本，归根结底它都是 IP 地址，它们属于同一类型，所以在编码过程中需要把它们当作同一个类型去操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面用代码说明，首先创建一个 IP 地址枚举类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4,
    V6,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;mei-ju-zhi&amp;quot;&amp;gt;枚举值&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;实例化枚举值&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v4 = IpAddrKind::V4;
let v6 = IpAddrKind::V6;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意这两个值都是在&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;命名空间下的。这表示 V4 和 V6 都是同一类型的值，这种方式是很有用的，在后续处理中可以把它们都当作&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;类型来处理。比如定义一个函数接受&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;类型的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn route(address: IpAddrKind) {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数可以这样调用：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;route(IpAddrKind::V4);
route(IpAddrKind::V6);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用枚举还有很多其他好处。比如，我们在存储 IP 地址时，不知道它是 V4 还是 V6 版本的，只知道是一个 IP 地址，也就是说我们只知道它的类型。我们使用之前的结构体来写一下代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    type: IpAddrKind,
    address: String,
}

let home = IpAddr {
    type: IpAddrKind::V4,
    address: String::from(&amp;amp;quot;127.0.0.1&amp;amp;quot;),
}

let loopback = IpAddr {
    type: IpAddrKind::V6,
    address: String::from(&amp;amp;quot;::1&amp;amp;quot;),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里定义了一个&amp;lt;code&amp;gt;IpAddr&amp;lt;&amp;#x2F;code&amp;gt;类型来存储 IP 地址数据，它有两个字段：&amp;lt;code&amp;gt;type&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;类型的 IP 地址版本，&amp;lt;code&amp;gt;address&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型的 IP 地址数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;有一种更简洁的方式，仅用枚举类型来表示，而不需要结构体嵌套枚举类型。这种方式是将数据直接存入枚举变体的实例中。&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;枚举的定义也需要更改一下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4(String),
    V6(String),
}

let home = IpAddrKind::V4(String::from(&amp;amp;quot;127.0.0.1&amp;amp;quot;));
let loopback = IpAddrKind::V6(String::from(&amp;amp;quot;::1&amp;amp;quot;));
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此外还有一种方式。枚举类型变体可以拥有不同的类型和数据量，因此我们可以将&amp;lt;code&amp;gt;V4&amp;lt;&amp;#x2F;code&amp;gt;类型定义成由 4 个整型数据组成的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4(u8, u8, u8, u8)
}
let home = IpAddrKind::V4(127, 0, 0, 1);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;IP 地址的存取是一个非常常用的功能，因此标准库已经实现了相关定义，编码人员可以直接使用。可以看看标准库是如何实现 IP 地址数据的定义的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Ipv4Addr {

}

struct Ipv6Addr {

}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;再来看另外一个例子，这个枚举类型下面有更多的字段和数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Message {
    Quit,
    Move {x: i32, y: i32},
    Write(String),
    ChangeColor(i32,i32,i32),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这些字段都有不同的数据类型：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Quit&amp;lt;&amp;#x2F;code&amp;gt;没有数据与它关联。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Move&amp;lt;&amp;#x2F;code&amp;gt;包含了一个匿名结构。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Write&amp;lt;&amp;#x2F;code&amp;gt;包含了一个字符串。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ChangeColor&amp;lt;&amp;#x2F;code&amp;gt;包含了 3 个&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;整数。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;这种方式与定义 4 个不同的结构体相似，不同点在于，枚举将他们都涵盖在了同一个类型&amp;lt;code&amp;gt;Message&amp;lt;&amp;#x2F;code&amp;gt;下。下面都结构体定义可以与枚举变体存储一样都数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct QuitMessage; &amp;amp;#x2F;&amp;amp;#x2F; unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); &amp;amp;#x2F;&amp;amp;#x2F; tuple struct
struct ChangeColorMessage(i32, i32, i32); &amp;amp;#x2F;&amp;amp;#x2F; tuple struct
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;枚举和结构体还有一个相似之处，都可以通过&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字对其进行方法扩展。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Message {
    fn call(&amp;amp;amp;self) {
        &amp;amp;#x2F;&amp;amp;#x2F; method body would be defined here
    }
}

let m = Message::Write(String::from(&amp;amp;quot;hello&amp;amp;quot;));
m.call();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来再看另外一个标准库中很常用的枚举类：&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;optionmei-ju-lei-ji-ta-dui-nullde-you-shi&amp;quot;&amp;gt;&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;枚举类及它对&amp;lt;code&amp;gt;Null&amp;lt;&amp;#x2F;code&amp;gt;的优势&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Option 枚举类在很多地方都会用到，因为它编码了一个很常见的情景：对变量的空值判断。用类型系统涵盖这个概念，代表编译器帮我们做了空值检查，可以在编译阶段就抛出错误，避免运行时 bug。并且 Rust 没有其他语言中&amp;lt;code&amp;gt;null&amp;lt;&amp;#x2F;code&amp;gt;的功能。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;null 值的问题在于，当你把 null 作为一个非 null 变量使用时，会抛出一个类型错误。因为变量的空和非空是很常见的场景，很容易导致 bug。但是 null 却描述了一个很有用的概念：一个变量因为某些原因此时不可用或不存在。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所以真正的问题不在于概念本身，而在于它的实现。因此 Rust 没有 null 值，取而代之是标准库实现的枚举类型用来描述值是否存在。这个枚举类型是&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，它的定义如下&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Option&amp;amp;lt;T&amp;amp;gt; {
    Some&amp;amp;lt;T&amp;amp;gt;,
    None,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;是默认引入的，不需要手动引入命名空间，它的枚举变体也是默认引入的，调用时不需要加&amp;lt;code&amp;gt;Option::&amp;lt;&amp;#x2F;code&amp;gt;前缀。&amp;lt;code&amp;gt;&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;是一个泛型参数，它可以代表任何类型，表示&amp;lt;code&amp;gt;Some&amp;lt;&amp;#x2F;code&amp;gt;可以存储任何类型的数据。下面是一些使用的例子&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let some_number = Some(5);
let some_str = Some(&amp;amp;quot;a string&amp;amp;quot;);

let absent_num: Option&amp;amp;lt;i32&amp;amp;gt; = None;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当使用&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;时，需要指定泛型是哪种数据类型，因为编译器无法通过&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;去推断&amp;lt;code&amp;gt;Some&amp;lt;&amp;#x2F;code&amp;gt;的正确类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;为何使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;要优于使用 null 值？简单来说，&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;不是同一类型，编译器不会让我们使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的值，就算它是一个有效值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x:i8 = 5;
let y:Option&amp;amp;lt;i8&amp;amp;gt; = Some(10);
let sum = x + y;

&amp;amp;#x2F;&amp;amp;#x2F; error[E0277]: cannot add `std::option::Option&amp;amp;lt;i8&amp;amp;gt;` to `i8`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果运行这段代码，编译器会直接抛错。编译器不知道如何将&amp;lt;code&amp;gt;i8&amp;lt;&amp;#x2F;code&amp;gt;类型和&amp;lt;code&amp;gt;Option&amp;amp;lt;i8&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的数据作加法计算。当变量是&amp;lt;code&amp;gt;i8&amp;lt;&amp;#x2F;code&amp;gt;类型时，编译器可以保证此时一定是一个有效值，所以不需要担心值不存在。当使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的变量时，我们需要考虑值不存在的情况，编译器需要确保我们对这种情况做了处理。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;也就是说，在使用之前，需要先将&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;转换成&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型。在这个过程中可以捕获最常见的值为空但被错误使用的错误情况。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果一个值可能为空，首先必须手动指定该值为&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型。然后在使用该值时，处理值为空的逻辑是必须的。所以任何非&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的数据，都可以被认为是非 null 的。这是 Rust 刻意的设计，为了限制代码中 null 值泛滥，增强代码的安全性。&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;有很多的方法扩展，可以读一下它的&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;option&amp;#x2F;enum.Option.html&amp;quot;&amp;gt;文档&amp;lt;&amp;#x2F;a&amp;gt;。熟悉&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;的内部方法对学习 Rust 很有好处。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通常为了使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;内部的&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;值，你的代码需要覆盖所有的枚举变体。某些代码仅在&amp;lt;code&amp;gt;Some&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;运行，此时代码能够访问到内部的&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;数据。某些代码仅在&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;运行，作空值逻辑处理。&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式是可以实现上述需求的一个控制流程。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-matchliu-cheng-kong-zhi-biao-da-shi&amp;quot;&amp;gt;Section 2 - &amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;流程控制表达式&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;可以通过许多的*patterns（匹配模型）*去对比，并在相应的匹配模型命中的情况下执行某些代码。匹配模型可以是字面量值、变量、通配符等等。&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;流程控制强大之处在于丰富的匹配模型，以及编译器可以确认所有的可能情况都被涵盖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&amp;amp;gt; i8 {
    match coin {
        Coin::Penny =&amp;amp;gt; 1,
        Coin::Nickel =&amp;amp;gt; 5,
        Coin::Dime =&amp;amp;gt; 10,
        Coin::Quarter =&amp;amp;gt; 25,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;分析一下这段代码。&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;后紧跟一个表达式，在这里是变量&amp;lt;code&amp;gt;coin&amp;lt;&amp;#x2F;code&amp;gt;。这里跟&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;有点类似，但是&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;后的表达式需要返回&amp;lt;code&amp;gt;bool&amp;lt;&amp;#x2F;code&amp;gt;值，而&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;后可以返回任何类型的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来是&amp;lt;em&amp;gt;match arms&amp;lt;&amp;#x2F;em&amp;gt;。每个 arm 由两个部分组成：一个匹配模型、一部分代码，两部分用&amp;lt;code&amp;gt;=&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符分割。arm 之间使用逗号分割。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式执行时，首先将结果值和匹配模型对比，如果某个匹配模型被命中，则它后面的代码会被执行，否则进入下一个 arm 进行对比。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;每个 arm 要执行的代码是一个表达式，其返回值作为&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式的返回值。如果需要执行多行代码，可以用花括号组成代码块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;pi-pei-mo-xing-bang-ding-de-shu-ju&amp;quot;&amp;gt;匹配模型绑定的数据&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式的匹配模型可以绑定一些数据，这也是提取枚举变体中数据的方式。修改一下代码&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    &amp;amp;#x2F;&amp;amp;#x2F; --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&amp;amp;gt; u8 {
    match coin {
        Coin::Penny =&amp;amp;gt; 1,
        Coin::Nickel =&amp;amp;gt; 5,
        Coin::Dime =&amp;amp;gt; 10,
        Coin::Quarter(state) =&amp;amp;gt; {
            println!(&amp;amp;quot;State quarter from {:?}!&amp;amp;quot;, state);
            25
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码在&amp;lt;code&amp;gt;Coin::Quarter&amp;lt;&amp;#x2F;code&amp;gt;匹配模型中绑定了一个变量&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;，当该匹配模型命中时，&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;变量会绑定&amp;lt;code&amp;gt;Quarter&amp;lt;&amp;#x2F;code&amp;gt;枚举变体中存储的数据，并且在该匹配模型后面的代码中，我们可以通过&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;变量使用这个数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;假如调用&amp;lt;code&amp;gt;value_in_cents(Coin::Quarter(UsState::Alabama));&amp;lt;&amp;#x2F;code&amp;gt;，变量&amp;lt;code&amp;gt;coin&amp;lt;&amp;#x2F;code&amp;gt;的值为&amp;lt;code&amp;gt;Coin::Quarter(UsState::Alabama)&amp;lt;&amp;#x2F;code&amp;gt;。在 match 表达式中，最后一个匹配模型会命中，此时&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;变量绑定的值将会是&amp;lt;code&amp;gt;UsState::Alabama&amp;lt;&amp;#x2F;code&amp;gt;，然后可以在&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;表达式中使用该匹配模型内部绑定的状态值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;matching-with-option&amp;quot;&amp;gt;Matching with Option&amp;lt;T&amp;gt;&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;实现一个函数接受一个&amp;lt;code&amp;gt;Option&amp;amp;lt;i32&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;作为参数，如果内部有值则+1，如果没有值则不做任何逻辑且返回&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn plus_one(x: Option&amp;amp;lt;i32&amp;amp;gt;) -&amp;amp;gt; Option&amp;amp;lt;i32&amp;amp;gt; {
    match x {
        None =&amp;amp;gt; None,
        Some(i) =&amp;amp;gt; Some(i + 1),
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;matches-yao-quan-mian&amp;quot;&amp;gt;Matches 要全面&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn plus_one(x: Option&amp;amp;lt;i32&amp;amp;gt;) -&amp;amp;gt; Option&amp;amp;lt;i32&amp;amp;gt; {
    match x {
        Some(i) =&amp;amp;gt; Some(i + 1),
    }
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0004]: non-exhaustive patterns: `None` not covered
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码中，&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;的情况没有被覆盖到，因此有可能会出现 bug。好在 Rust 在编译阶段就能指出这个地方有问题。在&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式中必须涵盖任何一种可能的情况，以保证代码的安全和健壮。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zhan-wei-fu&amp;quot;&amp;gt;&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位符&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当不想列举一些可能情况时，可以用占位符&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;来替代。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let some_u8_value = 0u8;
match some_u8_value {
    1 =&amp;amp;gt; println!(&amp;amp;quot;one&amp;amp;quot;),
    3 =&amp;amp;gt; println!(&amp;amp;quot;three&amp;amp;quot;),
    5 =&amp;amp;gt; println!(&amp;amp;quot;five&amp;amp;quot;),
    7 =&amp;amp;gt; println!(&amp;amp;quot;seven&amp;amp;quot;),
    _ =&amp;amp;gt; (),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位符会匹配所有的情况，因此需要将它放在最后面，以免覆盖我们想要处理的情况。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当只需要处理所有情况之中的一种时，&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式就显得有些啰嗦了。所以在这种场景下，Rust 为我们提供了&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-if-letliu-cheng-kong-zhi-biao-da-shi&amp;quot;&amp;gt;Section 3 - &amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;流程控制表达式&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;表达式可以让我们只关注一种需要处理的情况而忽略其他所有的情况。比如之前的例子&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&amp;amp;gt; println!(&amp;amp;quot;three&amp;amp;quot;),
    _ =&amp;amp;gt; (),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里只处理了值为 3 的情况，其余情况都被省略了，此时&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;要比&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;在书写上更加简洁。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;if let Some(3) = some_u8_value {
    println!(&amp;amp;quot;three&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以将&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;理解为&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;的一种语法糖。还可以在后面加&amp;lt;code&amp;gt;else&amp;lt;&amp;#x2F;code&amp;gt;分支，它的作用和&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位符是一样的效果。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Generic Types, Traits, and Lifetimes</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;08-generic-types-traits-and-lifetimes&#x2F;"/>
            <updated>2021-10-05T14:38:34+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;08-generic-types-traits-and-lifetimes&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-8-generic-types-traits-and-lifetimes&amp;quot;&amp;gt;Chapter 8 - Generic Types, Traits, and Lifetimes&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;每种语言都有针对概念抽象的有效工具。Rust 中的工具之一是&amp;lt;em&amp;gt;generic（泛型）&amp;lt;&amp;#x2F;em&amp;gt;。泛型是对类型或其他属性的抽象。在编码时，我们可以专注于表达泛型的行为或者与其他泛型之间的关系，而不用在意它在运行时代表的是什么类型的数据。函数也可以接收一些泛型参数而不是具体类型的参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;chou-xiang-han-shu-shan-chu-zhong-fu-dai-ma&amp;quot;&amp;gt;抽象函数删除重复代码&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在学习泛型之前，我们先看一下如何通过函数抽象来解决代码重复的问题，然后我们会将泛型参数再加入进来。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;先看一个寻找数组中最大数的示例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &amp;amp;gt; largest {
            largest = number;
        }
    }

    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, largest);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果我们要寻找另外一个数组中的最大数，可以重复这段代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &amp;amp;gt; largest {
            largest = number;
        }
    }

    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &amp;amp;gt; largest {
            largest = number;
        }
    }

    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, largest);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看出除了数组中的数据不同，其他地方的逻辑完全是一样的。这样写代码虽然可以得出正确的结果，但是显得太过啰嗦而且容易出错。如果我们要修改其中的逻辑，比如改成寻找最小的数字，那么就得将所有重复的代码都改一遍。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;为了去除重复代码，我们可以通过抽象一个函数，把不变的逻辑部分封装起来，可变的部分（数组）通过参数传递。这让我们的代码更加简洁，表意清晰也易于维护。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数目前还不能编译通过，因为还需要用到一些之后会讲到的内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-fan-xing&amp;quot;&amp;gt;Section 1 - 泛型&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;泛型即通用类型，是在运行时才确定具体运算类型的技术。通过泛型声明函数和结构体，在调用时可以使用多种数据类型。首先看看如何通过泛型声明函数、结构体、枚举和方法等，之后再讨论一下泛型对于性能的影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-sheng-ming&amp;quot;&amp;gt;函数声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用泛型声明函数时，我们使用泛型变量来替代参数和返回值的数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest_i32(list: &amp;amp;amp;[i32]) -&amp;amp;gt; i32 {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;amp;amp;[char]) -&amp;amp;gt; char {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let char_list = vec![&amp;amp;#x27;y&amp;amp;#x27;, &amp;amp;#x27;m&amp;amp;#x27;, &amp;amp;#x27;a&amp;amp;#x27;, &amp;amp;#x27;q&amp;amp;#x27;];

    let result = largest_char(&amp;amp;amp;char_list);
    println!(&amp;amp;quot;The largest char is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面分别有两个函数&amp;lt;code&amp;gt;largest_i32&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;largest_char&amp;lt;&amp;#x2F;code&amp;gt;，它们接收不同的数据类型，但是内部所做的事是一样的逻辑。所以这两个函数可以通过泛型抽象成一个函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在函数中将类型参数化，需要对类型参数命名，就像对普通参数命名那样。可以用一个标识符来表示类型参数，习惯上我们会用&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;来表示，因为 T 是 type 的缩写。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在函数体中使用参数时，需要先在函数声明中对参数命名，好让编译器知道这个名称的含义是什么。同样的，当我们在函数声明中使用类型参数前，需要对其进行命名。类型参数需要用&amp;lt;code&amp;gt;&amp;amp;lt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;包起来，并且置于函数名和参数列表之间。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个声明的含义是，&amp;lt;code&amp;gt;largest&amp;lt;&amp;#x2F;code&amp;gt;函数接收一个泛型&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;，参数&amp;lt;code&amp;gt;list&amp;lt;&amp;#x2F;code&amp;gt;是泛型&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;的切片，函数返回一个&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型的值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来将&amp;lt;code&amp;gt;largest_i32&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;largest_char&amp;lt;&amp;#x2F;code&amp;gt;函数通过泛型抽象为一个函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let char_list = vec![&amp;amp;#x27;y&amp;amp;#x27;, &amp;amp;#x27;m&amp;amp;#x27;, &amp;amp;#x27;a&amp;amp;#x27;, &amp;amp;#x27;q&amp;amp;#x27;];

    let result = largest(&amp;amp;amp;char_list);
    println!(&amp;amp;quot;The largest char is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此时代码编译会提示一个错误&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;error[E0369]: binary operation &amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt; cannot be applied to type &amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;这里的出现错误的原因是，&amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符不能在所有可能的数据类型上运算。为了进行比较运算，标准库提供了&amp;lt;code&amp;gt;std::cmp::PartialOrd&amp;lt;&amp;#x2F;code&amp;gt;trait，类型实现它就可以获得进行比较运算的能力。这个在后续章节中会介绍到。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;jie-gou-ti-sheng-ming&amp;quot;&amp;gt;结构体声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们也可以使用泛型对结构体的字段进行声明。跟函数声明没什么不同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T&amp;amp;gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以使用多个泛型参数来代表多种不同的类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T, U&amp;amp;gt; {
    x: T,
    y: U,
}

fn main() {
    let integer = Point { x: 5, y: 10.0 };
    let float = Point { x: 1.0, y: 4 };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;但是泛型参数的数量不宜过多，否则代码可读性会变差。当你需要使用到多个泛型变量时，说明你的代码需要重构到更细颗粒度。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mei-ju-sheng-ming&amp;quot;&amp;gt;枚举声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;跟结构体声明一样，没有什么特别。比如之前多次使用到的&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;枚举。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Option&amp;amp;lt;T&amp;amp;gt; {
    Some(T),
    None,
}

enum Result&amp;amp;lt;T, E&amp;amp;gt; {
    Ok(T),
    Err(E),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当你的代码出现多个相似的结构体和枚举，这些结构体和枚举仅仅只有数据类型不同时，就可以使用泛型对其进行抽象。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fang-fa-sheng-ming&amp;quot;&amp;gt;方法声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T&amp;amp;gt; {
    x: T,
    y: T,
}

impl&amp;amp;lt;T&amp;amp;gt; Point&amp;amp;lt;T&amp;amp;gt; {
    fn x(&amp;amp;amp;self) -&amp;amp;gt; &amp;amp;amp;T {
        &amp;amp;amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&amp;amp;quot;p.x = {}&amp;amp;quot;, p.x());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;泛型参数&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;被置于&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字之后，方法名之后的泛型参数就可以省略不写。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Point&amp;amp;lt;f32&amp;amp;gt; {
    fn distance_from_origin(&amp;amp;amp;self) -&amp;amp;gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这段代码的含义是，&amp;lt;code&amp;gt;Point&amp;amp;lt;f32&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上实现了一个方法&amp;lt;code&amp;gt;distance_from_origin&amp;lt;&amp;#x2F;code&amp;gt;，对于泛型&amp;lt;code&amp;gt;Point&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，当&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;f32&amp;lt;&amp;#x2F;code&amp;gt;以外的类型时，则它不具有&amp;lt;code&amp;gt;distance_from_origin&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;结构体的泛型参数不一定会被方法定义时全部使用。可以在方法上指定一些其他的泛型参数，这些泛型参数仅仅在该方法上生效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T, U&amp;amp;gt; {
    x: T,
    y: U,
}

impl&amp;amp;lt;T, U&amp;amp;gt; Point&amp;amp;lt;T, U&amp;amp;gt; {
    fn mixup&amp;amp;lt;V, W&amp;amp;gt;(self, other: Point&amp;amp;lt;V, W&amp;amp;gt;) -&amp;amp;gt; Point&amp;amp;lt;T, W&amp;amp;gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &amp;amp;quot;Hello&amp;amp;quot;, y: &amp;amp;#x27;c&amp;amp;#x27; };

    let p3 = p1.mixup(p2);

    println!(&amp;amp;quot;p3.x = {}, p3.y = {}&amp;amp;quot;, p3.x, p3.y);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-fan-xing-de-dai-ma-xing-neng&amp;quot;&amp;gt;使用泛型的代码性能&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;你可能会怀疑使用泛型会在运行时有一定的性能损耗。但是 Rust 在中使用泛型和特定的数据类型，在性能上没有任何区别。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 通过在编译阶段对使用了泛型的代码执行&amp;lt;em&amp;gt;monomorphization&amp;lt;&amp;#x2F;em&amp;gt;来完成性能优化。&amp;lt;em&amp;gt;monomorphization&amp;lt;&amp;#x2F;em&amp;gt;是在编译阶段将泛型替换成具体数据类型的进程。在这个进程中编译器执行与创建泛型函数相反的操作，编译器查看所有调用了泛型声明的代码，并且生成对应的具体数据类型的代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们通过一个例子来看看它的工作原理&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let integer = Some(5);
let float = Some(5.0);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当 Rust 编译这段代码，它会执行 monomorphization。编译器发现有两处代码调用了&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;枚举的实体，编译器会针对这两处代码的类型分别生成对应的&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;枚举。可以看成是抽象代码的一个逆操作&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;由于 Rust 在编译阶段生成了相应的代码，因此在运行时就没有性能损耗了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-traits-defining-shared-behavior&amp;quot;&amp;gt;Section 2 - Traits: Defining Shared Behavior&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;trait&amp;lt;&amp;#x2F;em&amp;gt;告诉编译器特定的类型下具有什么功能，并且是否对外暴露。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;trait 与其他类型的&amp;lt;code&amp;gt;interface&amp;lt;&amp;#x2F;code&amp;gt;概念类似，但不完全相同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;h3 id=&amp;quot;ding-yi-trait&amp;quot;&amp;gt;定义 Trait&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;类型的行为取决于我们能在该类型上调用的方法。如果多种不同类型都可以调用同一个方法，那么它们就具有相同的行为。trait 就是将这些相同方法组织在一起，定义一个行为的集合。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;例如，有一些结构体能够存储一些类型和数量的文本，&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;可以存储一个新闻内容；&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;可以存储至多 280 个字符的文本内容，和标识它是新推文、转推还是回复其他推文的一些元数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们想做一个媒体聚合库，用来展示&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;实例的摘要内容。因此，这两种类型中都必须要有摘要数据，然后通过调用&amp;lt;code&amp;gt;summarize&amp;lt;&amp;#x2F;code&amp;gt;方法来获取实例上的摘要数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub trait Summary {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String;
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里用&amp;lt;code&amp;gt;trait&amp;lt;&amp;#x2F;code&amp;gt;关键字定义了一个 trait。在 trait 内部，声明了一个方法，实现这个 trait 的类型可以调用这个方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在方法声明后，没有方法体，而是用分号结束。任何实现了这个 trait 的类型都必须自己实现这个方法的方法体。编译器会强制限定类型中实现的方法和 trait 中的方法声明是完全一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;trait 可以声明多个方法，每个方法占一行并以分号结束。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lei-xing-shi-xian-trait&amp;quot;&amp;gt;类型实现 trait&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;{}, by {} ({})&amp;amp;quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;{}: {}&amp;amp;quot;, self.username, self.content)
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在类型上实现 trait 和普通的方法扩展类似。不同之处在于，在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;之后需要加上 trait 名称，然后在加上&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;关键字，最后是类型名称。在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块里有和 trait 一样的方法声明，但是此时需要实现方法体。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在实现 trait 后，就可以在&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;类型的实例上调用实现的方法了，调用方式和普通的方法一样。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let tweet = Tweet {
    username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
    content: String::from(
        &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
    ),
    reply: false,
    retweet: false,
};

println!(&amp;amp;quot;1 new tweet: {}&amp;amp;quot;, tweet.summarize());
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意由于我们所有代码写在一个文件中，因此我们可以直接使用，当其他人实现这个 trait 时，则需要通过之前章节讲的模块规则，把 trait 先引入然后才能使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;trait 实现的一条限制是，当被实现的 trait 或者要实现的类型是我们 crate 的本地 trait 或类型时，才可以进行实现。例如，可以在&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;上实现标准库的&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;trait，因为&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;是我们的本地类型；也可以在&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上实现&amp;lt;code&amp;gt;Summary&amp;lt;&amp;#x2F;code&amp;gt;trait，因为&amp;lt;code&amp;gt;Summary&amp;lt;&amp;#x2F;code&amp;gt;trait 是我们的本地 trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;但是我们不能在外部类型上实现外部 trait，例如在&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上实现&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;。这个限制是程序属性之一称之为&amp;lt;em&amp;gt;连贯性（coherence）&amp;lt;&amp;#x2F;em&amp;gt;，更准确的说应该称之为&amp;lt;em&amp;gt;孤儿规则（orphan rule）&amp;lt;&amp;#x2F;em&amp;gt;。这条规则确保别人不能修改你的代码，反之亦然。如果没有这条规则，那么两个 crate 可以同时给同一个类型实现同一个 trait，这样编译器就不知道要调用哪个实现了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mo-ren-shi-xian&amp;quot;&amp;gt;默认实现&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;有时在定义 trait 时，对它下面的方法实现默认的逻辑。之后，在我们实现 trait 时，可以选择保留或者覆盖默认实现。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub trait Summary {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        String::from(&amp;amp;quot;(Read more...)&amp;amp;quot;)
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在不覆盖默认实现时，&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;后面跟一个空的 block 就好。trait 进行方法的默认逻辑编写，不会影响我们实现该 trait 的代码，因为覆盖和实现 trait 在语法上都是一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;默认实现的方法中，可以调用 trait 中的其他方法，就算被调用的方法没有默认实现。通过这种方式，trait 可以提供很多有用的功能，而我们只需要实现其中一部分代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub trait Summary {
    fn summarize_author(&amp;amp;amp;self) -&amp;amp;gt; String;

    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;(Read more from {}...)&amp;amp;quot;, self.summarize_author())
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;要使用&amp;lt;code&amp;gt;summarize&amp;lt;&amp;#x2F;code&amp;gt;方法，需要先实现它调用的&amp;lt;code&amp;gt;summarize_author&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Summary for Tweet {
    fn summarize_author(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;@{}&amp;amp;quot;, self.username)
    }
}

let tweet = Tweet {
    username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
    content: String::from(
        &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
    ),
    reply: false,
    retweet: false,
};

println!(&amp;amp;quot;1 new tweet: {}&amp;amp;quot;, tweet.summarize());

&amp;amp;#x2F;&amp;amp;#x2F; output: 1 new tweet: (Read more from @horse_ebooks...)
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;覆盖实现的方法是不可能调用同一个默认方法的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;trait-zuo-wei-can-shu&amp;quot;&amp;gt;Trait 作为参数&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法将 trait 作为参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify(item: &amp;amp;amp;impl Summary) {
    println!(&amp;amp;quot;Breaking news! {}&amp;amp;quot;, item.summarize());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们在参数&amp;lt;code&amp;gt;item&amp;lt;&amp;#x2F;code&amp;gt;之后没有指定数据类型，而是用&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字和 trait 名称。这样这个参数就可以接收任何实现了这个 trait 的类型。在&amp;lt;code&amp;gt;notify&amp;lt;&amp;#x2F;code&amp;gt;函数体中，可以通过&amp;lt;code&amp;gt;item&amp;lt;&amp;#x2F;code&amp;gt;调用所有&amp;lt;code&amp;gt;Summary&amp;lt;&amp;#x2F;code&amp;gt;上被&amp;lt;code&amp;gt;item&amp;lt;&amp;#x2F;code&amp;gt;的类型实现了的方法或者默认方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;trait-bound-syntax&amp;quot;&amp;gt;Trait Bound Syntax&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;方法是另外一种形式的语法糖，该形式成为&amp;lt;em&amp;gt;trait 绑定（trait bound）&amp;lt;&amp;#x2F;em&amp;gt;。它的代码如下：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify&amp;amp;lt;T: Summary&amp;amp;gt;(item: &amp;amp;amp;T) {
    println!(&amp;amp;quot;Breaking news! {}&amp;amp;quot;, item.summarize());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这种形式跟&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法等价，但是比较冗长。&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法使用更方便，并且在大多数简单场景下代码更简洁。trait 绑定能解决更复杂的场景。比如两个参数的情况：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify(item1: &amp;amp;amp;impl Summary, item2: &amp;amp;amp;impl Summary) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果我们想要&amp;lt;code&amp;gt;item1&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;item2&amp;lt;&amp;#x2F;code&amp;gt;的类型是不同的，那么&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;方法更合适。但是如果需要强制两个参数的类型是一致的，那么只有 trait 绑定能实现。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify&amp;amp;lt;T: Summary&amp;amp;gt;(item: &amp;amp;amp;T) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;泛型参数&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;保证&amp;lt;code&amp;gt;item1&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;item2&amp;lt;&amp;#x2F;code&amp;gt;的类型必须是一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;tong-guo-yu-fa-sheng-ming-duo-ge-trait-bound&amp;quot;&amp;gt;通过&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;语法声明多个 trait bound&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们可以指定多个 trait bound。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify(item: &amp;amp;amp;(impl Summary + Display)) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;语法也适用于 trait bound&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify&amp;amp;lt;T: Summary + DisPlay&amp;amp;gt;(item: &amp;amp;amp;T) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;shi-yong-wheretiao-jian-jian-hua-trait-bound&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;where&amp;lt;&amp;#x2F;code&amp;gt;条件简化 trait bound&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;使用太多 trait bound 也有缺点。每个泛型参数都有它自己的 trait bound，因此多个泛型参数的函数在泛型参数列表和参数列表中会包含很多 trait bound 信息，让函数声明变得冗长难以理解。因此，在函数声明后引入&amp;lt;code&amp;gt;where&amp;lt;&amp;#x2F;code&amp;gt;条件可以做到简化的作用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; before
fn some_function&amp;amp;lt;T: Display + Clone, U: Clone + Debug&amp;amp;gt;(t: &amp;amp;amp;T, u: &amp;amp;amp;U) -&amp;amp;gt; i32 {
&amp;amp;#x2F;&amp;amp;#x2F; with where
fn some_function&amp;amp;lt;T, U&amp;amp;gt;(t: &amp;amp;amp;T, u: &amp;amp;amp;U) -&amp;amp;gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;returning-types-that-implement-traits&amp;quot;&amp;gt;Returning Types that Implement Traits&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法同样可以用在函数声明中的返回类型部分。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn returns_summarizable() -&amp;amp;gt; impl Summary {
    Tweet {
        username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
        content: String::from(
            &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
        ),
        reply: false,
        retweet: false,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;返回实现了特定 trait 类型的功能在闭包和迭代器的场景下非常有用。闭包和迭代器创建的类型只有编译器知道，或者列举这些类型会非常长。&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法让你只需要指定返回一个实现了&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型就好，不用写过长的类型代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;但是，&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法用于返回类型时，函数只能返回一种类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn returns_summarizable(switch: bool) -&amp;amp;gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &amp;amp;quot;Penguins win the Stanley Cup Championship!&amp;amp;quot;,
            ),
            location: String::from(&amp;amp;quot;Pittsburgh, PA, USA&amp;amp;quot;),
            author: String::from(&amp;amp;quot;Iceburgh&amp;amp;quot;),
            content: String::from(
                &amp;amp;quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&amp;amp;quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
            content: String::from(
                &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数返回&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;两种类型，由于被&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法在编译器中的实现所限制，这个函数是不会编译通过的。在后面的章节会介绍到如何实现这种功能。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;xiu-gai-largesthan-shu&amp;quot;&amp;gt;修改&amp;lt;code&amp;gt;largest&amp;lt;&amp;#x2F;code&amp;gt;函数&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;现在我们可以修改本章开头的示例函数了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T: PartialOrd + Copy&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let char_list = vec![&amp;amp;#x27;y&amp;amp;#x27;, &amp;amp;#x27;m&amp;amp;#x27;, &amp;amp;#x27;a&amp;amp;#x27;, &amp;amp;#x27;q&amp;amp;#x27;];

    let result = largest(&amp;amp;amp;char_list);
    println!(&amp;amp;quot;The largest char is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;PartialOrd&amp;lt;&amp;#x2F;code&amp;gt;trait 限制参数类型要有&amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符计算的能力，&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;trait 限制参数类型只能是&amp;lt;em&amp;gt;stack-only&amp;lt;&amp;#x2F;em&amp;gt;的，或者可以用&amp;lt;code&amp;gt;Clone&amp;lt;&amp;#x2F;code&amp;gt;trait 替代。但是&amp;lt;code&amp;gt;clone&amp;lt;&amp;#x2F;code&amp;gt;方法会在 heap 上分配内存，如果数据量很大的话会有性能损耗。另外一种解决方案是通过返回引用&amp;lt;code&amp;gt;&amp;amp;amp;T&amp;lt;&amp;#x2F;code&amp;gt;而不是&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;。则可以省略&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;using-trait-bounds-to-conditionally-implement-methods&amp;quot;&amp;gt;Using Trait Bounds to Conditionally Implement Methods&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;将 Trait bound 用于&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;可以让我们有条件的实现 trait 中的方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt::Display;

struct Pair&amp;amp;lt;T&amp;amp;gt; {
    x: T,
    y: T,
}

impl&amp;amp;lt;T&amp;amp;gt; Pair&amp;amp;lt;T&amp;amp;gt; {
    fn new(x: T, y: T) -&amp;amp;gt; Self {
        Self { x, y }
    }
}

impl&amp;amp;lt;T: Display + PartialOrd&amp;amp;gt; Pair&amp;amp;lt;T&amp;amp;gt; {
    fn cmp_display(&amp;amp;amp;self) {
        if self.x &amp;amp;gt;= self.y {
            println!(&amp;amp;quot;The largest member is x = {}&amp;amp;quot;, self.x);
        } else {
            println!(&amp;amp;quot;The largest member is y = {}&amp;amp;quot;, self.y);
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Pair&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上的 new 方法任何类型都会被实现，而&amp;lt;code&amp;gt;cmp_display&amp;lt;&amp;#x2F;code&amp;gt;方法只有&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型实现了&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;partialOrd&amp;lt;&amp;#x2F;code&amp;gt;trait 时才会被实现。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这个限制条件也可以用于给类型实现 trait 时。为某些满足 trait bound 条件的类型实现特定的 trait 在 Rust 中称为&amp;lt;em&amp;gt;blanket implementations&amp;lt;&amp;#x2F;em&amp;gt;，这个做法被广泛的应用于 Rust 标准库中。例如，标准库实现了为所有实现了&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型实现了&amp;lt;code&amp;gt;ToString&amp;lt;&amp;#x2F;code&amp;gt;trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;T: Display&amp;amp;gt; ToString for T {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Trait 和 trait bound 可以让我们通过泛型参数抽象代码，同时可以向编译器指明我们需要泛型类型具有什么样的功能。然后编译器就能根据我们提供的信息去检查我们具体使用的类型有没有实现这些功能。在动态类型语言中，如果我们调用一个类型上没有定义的方法，那么会在运行时出现错误。Rust 在编译阶段就解决了这些错误，它强制我们在代码运行之前解决这些潜在错误，因此我们也不需要再在运行时代码中检查方法是否存在。这样既提升了性能，又没有损失泛型的动态性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-yong-lifetimes-yan-zheng-yin-yong&amp;quot;&amp;gt;Section 3 - 用 Lifetimes 验证引用&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;我们在之前的&amp;lt;a href=&amp;quot;&amp;#x2F;Rust&amp;#x2F;02-ownership.html#section-2-references-and-borrowing&amp;quot;&amp;gt;章节&amp;lt;&amp;#x2F;a&amp;gt;中没有讲到的一个概念是，Rust 中的引用都有&amp;lt;em&amp;gt;生命周期（lifetimes）&amp;lt;&amp;#x2F;em&amp;gt;，是引用有效的作用域范围。大多数情况下，生命周期是隐式和被推断的，就像数据类型是被推断的一样。当类型有多种可能时，我们就必须指定类型。同样的，当生命周期通过集中不同的方式关联时，我们也必须指定。Rust 要求我们使用泛型生命周期参数指明关联方式来确保真正的引用在运行时是绝对有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;生命周期的概念与其他语言中的工具有些不同，可以说是 Rust 最独特的功能。这节不会介绍生命周期的全部内容，但是会对你有可能遇到的多种生命周期语法作讨论，好熟悉生命周期的概念。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fang-zhi-xuan-kong-zhi-zhen&amp;quot;&amp;gt;防止悬空指针&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;生命周期的主要目标是防止出现悬空指针。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let r;

    {
        let x = 5;
        r = &amp;amp;amp;x;
    }

    println!(&amp;amp;quot;r: {}&amp;amp;quot;, r);
    &amp;amp;#x2F;&amp;amp;#x2F; error[E0597]: `x` does not live long enough
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;假如我们运行这段代码，编译器会报一个错误。因为内部作用域结束时，x 和它的引用也被销毁了。如果这个代码能够运行，那么 r 将指向一块已经被释放的内存，之后代码的运行肯定不符合我们的预期。Rust 通过 borrow checker 判断代码是否有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;the-borrow-checker&amp;quot;&amp;gt;The Borrow Checker&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 编译器用&amp;lt;em&amp;gt;borrow checker&amp;lt;&amp;#x2F;em&amp;gt;来比较作用域，判断引用是否有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let r;                &amp;amp;#x2F;&amp;amp;#x2F; ---------+-- &amp;amp;#x27;a
                          &amp;amp;#x2F;&amp;amp;#x2F;          |
    {                     &amp;amp;#x2F;&amp;amp;#x2F;          |
        let x = 5;        &amp;amp;#x2F;&amp;amp;#x2F; -+-- &amp;amp;#x27;b  |
        r = &amp;amp;amp;x;           &amp;amp;#x2F;&amp;amp;#x2F;  |       |
    }                     &amp;amp;#x2F;&amp;amp;#x2F; -+       |
                          &amp;amp;#x2F;&amp;amp;#x2F;          |
    println!(&amp;amp;quot;r: {}&amp;amp;quot;, r); &amp;amp;#x2F;&amp;amp;#x2F;          |
}                         &amp;amp;#x2F;&amp;amp;#x2F; ---------+
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;用&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;代表 r 的生命周期，&amp;lt;code&amp;gt;&amp;#x27;b&amp;lt;&amp;#x2F;code&amp;gt;代表 x 的生命周期。可以看到，内部的&amp;lt;code&amp;gt;&amp;#x27;b&amp;lt;&amp;#x2F;code&amp;gt;生命周期是要比外部的&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;生命周期小的。在编译阶段，编译器会对比这两个变量的生命周期大小，它会发现&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;的生命周期更大，但是它指向了一个生命周期更小的内存区域，所以编译器会报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let x = 5;            &amp;amp;#x2F;&amp;amp;#x2F; ----------+-- &amp;amp;#x27;b
                          &amp;amp;#x2F;&amp;amp;#x2F;           |
    let r = &amp;amp;amp;x;           &amp;amp;#x2F;&amp;amp;#x2F; --+-- &amp;amp;#x27;a  |
                          &amp;amp;#x2F;&amp;amp;#x2F;   |       |
    println!(&amp;amp;quot;r: {}&amp;amp;quot;, r); &amp;amp;#x2F;&amp;amp;#x2F;   |       |
                          &amp;amp;#x2F;&amp;amp;#x2F; --+       |
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;的生命周期&amp;lt;code&amp;gt;&amp;#x27;b&amp;lt;&amp;#x2F;code&amp;gt;比&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;的生命周期&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;大，那么&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;可以指向&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;，因为当&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;有效时，它的引用&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;也一定有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-de-fan-xing-sheng-ming-zhou-qi&amp;quot;&amp;gt;函数的泛型生命周期&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;写一个比较两个字符串长度的函数&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;。接收两个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;参数，返回一个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest(x: &amp;amp;amp;str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {
    if x.len() &amp;amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;amp;quot;abcd&amp;amp;quot;);
    let string2 = &amp;amp;quot;xyz&amp;amp;quot;;

    let result = longest(string1.as_str(), string2);
    println!(&amp;amp;quot;The longest string is {}&amp;amp;quot;, result);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0106]: missing lifetime specifier

&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;函数的实现，编译阶段会报错。返回类型需要一个泛型生命周期参数，因为 Rust 不知道返回的引用指向&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;还是&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;。事实上因为&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;表达式，我们自己也不知道会指向哪一个。为了解决这个错误，需要定义泛型生命周期参数来确定引用之间的关系，然后&amp;lt;code&amp;gt;borrow checker&amp;lt;&amp;#x2F;code&amp;gt;才能进行分析。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;sheng-ming-zhou-qi-sheng-ming-yu-fa&amp;quot;&amp;gt;生命周期声明语法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;生命周期声明不会改变任何引用真正的生命周期。就像函数可以接收泛型类型参数来接收任何数据类型，通过定义泛型生命周期，函数也可以接收任何生命周期的引用。生命周期声明只描述了引用之间的生命周期关系，对运行时真正的生命周期没有影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;泛型生命周期的定义语法比较奇怪：生命周期参数的名称前面用一个单引号&amp;lt;code&amp;gt;&amp;#x27;&amp;lt;&amp;#x2F;code&amp;gt;开头，名称都是小写字母，并且像泛型参数一样名称长度很短。最常用的名称是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;。把生命周期参数放在引用的&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;符号后面，用空格将类型隔开。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;i32        &amp;amp;#x2F;&amp;amp;#x2F; a reference
&amp;amp;amp;&amp;amp;#x27;a i32     &amp;amp;#x2F;&amp;amp;#x2F; a reference with an explicit lifetime
&amp;amp;amp;&amp;amp;#x27;a mut i32 &amp;amp;#x2F;&amp;amp;#x2F; a mutable reference with an explicit lifetime
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;单独的生命周期声明没什么意义，因为它的作用是告知编译器引用之间的生命周期关系。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zai-han-shu-sheng-ming-zhong-shi-yong-sheng-ming-zhou-qi-sheng-ming&amp;quot;&amp;gt;在函数声明中使用生命周期声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;现在开始在&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;函数上下文中定义生命周期。泛型生命周期参数需要像泛型类型参数一样，包在&amp;lt;code&amp;gt;&amp;amp;lt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;中。生命周期参数的声明中有一条限制是，所有的参数和返回值必须要有一致的生命周期参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt;(x:&amp;amp;amp;&amp;amp;#x27;a str, y:&amp;amp;amp;&amp;amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str {
    if x.len &amp;amp;gt; y.len {
        x
    } else {
        y
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;函数接收两个参数，且生命周期长度至少是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;，且返回值的生命周期也是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;。意味着函数返回值的生命周期和参数中生命周期较小的那个相等。记住，当我们定义声明生命周期参数时，对参数和返回值真正的生命周期没有任何影响。它的作用是我们指明 borrow checker 需要拒绝不符合这些限制的参数。函数不需要知道参数的确切生命周期，只需要把函数声明中符合条件的最小生命周期替换为&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;声明生命周期只需要在函数签名中，Rust 可以自动分析代码。然而当函数有外部代码或者引用的时候，Rust 编译器就不能靠自己分析生命周期了，所以需要手动指定。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;泛型生命周期会等于参数&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;中生命周期较小的那一个。因为我们指定返回值的生命周期也是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;，所以返回值的生命周期也和&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;中较小的那一个相等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们通过一个例子来看当参数真正的生命周期不相等时，生命周期参数如何对函数做限制。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let string1 = String::from(&amp;amp;quot;long string is long&amp;amp;quot;);

    {
        let string2 = String::from(&amp;amp;quot;xyz&amp;amp;quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&amp;amp;quot;The longest string is {}&amp;amp;quot;, result);
    }
}

&amp;amp;#x2F;&amp;amp;#x2F; output: The longest string is long string is long
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;string1&amp;lt;&amp;#x2F;code&amp;gt;的生命周期是外部作用域（main 函数）。&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;的生命周期是内部作用域（代码块）。&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;引用某个玩意儿，生命周期是内部作用域。这个代码能够正常执行并输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来，把&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;的定义和&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;移到外部作用域。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let string1 = String::from(&amp;amp;quot;long string is long&amp;amp;quot;);
    let result;

    {
        let string2 = String::from(&amp;amp;quot;xyz&amp;amp;quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&amp;amp;quot;The longest string is {}&amp;amp;quot;, result);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0597]: `string2` does not live long enough
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这时候编译会报错。之前提到返回值的生命周期等于参数生命周期较小的那个，这里也就是&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;。但是当&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;的引用被使用时，&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;的生命周期已经结束，其内存已经被释放，所以&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;是一个悬空指针，Rust 编译器不会让这种情况通过编译。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这个错误表示，&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;要在&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;宏调用它的时候有效，则&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;就必须在外部作用域结束前有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;thinking-in-terms-of-lifetimes&amp;quot;&amp;gt;Thinking in Terms of Lifetimes&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;定义函数生命周期参数的方式取决于函数的具体功能。如果你的函数任何情况下都返回第一个参数，那么就不需要对第二个参数进行生命周期定义。因为第二个参数与第一个参数或者返回值没有任何生命周期关系。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;&amp;amp;#x27;a str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str {
    x
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当函数返回一个引用时，它的生命周期要和参数列表其中一个参数的生命周期匹配。如果函数的返回值没有指向任何参数，而是指向一个函数内部创建的值，那么这个返回值在函数结束后会成为一个悬空指针。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str {
    let result = String::from(&amp;amp;quot;really long string&amp;amp;quot;);
    result.as_str()
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0515]: cannot return value referencing local variable `result`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;即使我们定义了泛型生命周期参数，编译器还是不会通过这个代码，因为返回值本质上和参数没有任何关联。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;总之，生命周期语法需要函数参数和返回值之间有所关联。只有这样 Rust 编译器才有足够的判断依据来允许执行内存安全的操作和禁止任何可能创建悬空指针的操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lifetime-annotations-in-struct-definitions&amp;quot;&amp;gt;Lifetime Annotations in Struct Definitions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;至今我们定义的结构体字段都是有所有权的，结构体字段也可以包含引用。当结构体字段包含引用的时候，需要对每个引用类型的字段定义生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct ImportantExcerpt&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; {
    part: &amp;amp;amp;&amp;amp;#x27;a str,
}

fn main() {
    let novel = String::from(&amp;amp;quot;Call me Ishmael. Some years ago...&amp;amp;quot;);
    let first_sentence = novel.split(&amp;amp;#x27;.&amp;amp;#x27;).next().expect(&amp;amp;quot;Could not find a &amp;amp;#x27;.&amp;amp;#x27;&amp;amp;quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个结构体有一个字段&amp;lt;code&amp;gt;part&amp;lt;&amp;#x2F;code&amp;gt;，存储一个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型的数据。泛型生命周期参数用&amp;lt;code&amp;gt;&amp;amp;lt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;包起来，放在结构体名称和结构体代码块之间。这个定义意味着，&amp;lt;code&amp;gt;ImportantExcerpt&amp;lt;&amp;#x2F;code&amp;gt;类型的实例，其生命周期不超过&amp;lt;code&amp;gt;part&amp;lt;&amp;#x2F;code&amp;gt;字段引用的生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;main&amp;lt;&amp;#x2F;code&amp;gt;方法创建了一个&amp;lt;code&amp;gt;ImportantExcerpt&amp;lt;&amp;#x2F;code&amp;gt;实例，并且将&amp;lt;code&amp;gt;novel&amp;lt;&amp;#x2F;code&amp;gt;变量的部分引用赋值给实例的字段。&amp;lt;code&amp;gt;novel&amp;lt;&amp;#x2F;code&amp;gt;在实例创建之前初始化，而且&amp;lt;code&amp;gt;novel&amp;lt;&amp;#x2F;code&amp;gt;在作用域执行结束，实例被释放后才会被释放，因此实例中的引用是有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lifetime-elision&amp;quot;&amp;gt;Lifetime Elision&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;现在了解了所有的引用都有生命周期，而且你需要为使用了引用的结构体和函数声明生命周期参数。之前我们写过一个获取句子中第一个单词的&amp;lt;a href=&amp;quot;https:&amp;#x2F;&amp;#x2F;leokang28.github.io&amp;#x2F;blog&amp;#x2F;08-generic-types-traits-and-lifetimes&amp;#x2F;Rust&amp;#x2F;2-ownership.html#section-3-the-slice-type&amp;quot;&amp;gt;方法&amp;lt;&amp;#x2F;a&amp;gt;，这个函数没有生命周期声明，而且编译通过了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;amp;amp;item) in bytes.iter().enumerate() {
        if item == b&amp;amp;#x27; &amp;amp;#x27; {
            return &amp;amp;amp;s[0..i];
        }
    }

    &amp;amp;amp;s[..]
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数没有生命周期声明但是编译通过是因为一些历史原因：早起的 Rust 版本（&amp;amp;lt;1.0）中，这个代码是不能编译通过的，因为要求所有引用都声明声明周期。在那个版本下，这个函数的签名是&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(s: &amp;amp;amp;&amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;&amp;#x27;a str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;在编写了大量的 Rust 代码之后，Rust 核心团队发现，Rust 程序员在一些特定场景下需要一直重复同样的生命周期声明。这些场景是可预测而且遵循特定的模式的。维护者将这些模式加入编译器，这样编译器就能对这些场景进行生命周期推断，而不需要程序员显式指定了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;今后可能还会出现其他特定的模式，然后被加入到编译器中。以后需要指定生命周期的场景可能会越来越少。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这些用来分析引用生命周期，被编写进 Rust 编译器的模式被称为&amp;lt;em&amp;gt;生命周期省略规则（lifetime elision rules）&amp;lt;&amp;#x2F;em&amp;gt;。这不是给程序员指定的规则，而是编译器的一个规则集合，编译器通过这个集合判断如果你的代码场景符合其中的某个模式，那么就不用显式声明生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;函数参数的生命周期称为&amp;lt;em&amp;gt;input lifetimes&amp;lt;&amp;#x2F;em&amp;gt;，函数返回值的生命周期称为&amp;lt;em&amp;gt;output lifetimes&amp;lt;&amp;#x2F;em&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当没有指定生命周期时，编译器通过三个规则来判断引用的生命周期。规则一适用于&amp;lt;em&amp;gt;input lifetimes&amp;lt;&amp;#x2F;em&amp;gt;，规则二三适用于&amp;lt;em&amp;gt;output lifetimes&amp;lt;&amp;#x2F;em&amp;gt;。如果通过三条规则编译器都不能确定引用的生命周期，则会报错退出。这三条规则同时适用于&amp;lt;code&amp;gt;fn&amp;lt;&amp;#x2F;code&amp;gt;声明和&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;声明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;规则一：每个引用参数都有它自己的生命周期。即，一个参数的函数可以获取到一个生命周期&amp;lt;code&amp;gt;fn foo&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a i32)&amp;lt;&amp;#x2F;code&amp;gt;，两个参数的函数获取到两个生命周期&amp;lt;code&amp;gt;fn foo&amp;amp;lt;&amp;#x27;a, &amp;#x27;b&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a i32, y: &amp;amp;amp;&amp;#x27;b i32)&amp;lt;&amp;#x2F;code&amp;gt;。依此类推。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;规则二：如果明确只有一个 input lifetime 参数，那么 output lifetime 跟它相同。&amp;lt;code&amp;gt;fn foo&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a i32) -&amp;amp;gt; &amp;amp;amp;&amp;#x27;a i32&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;规则三：如果有多个 input lifetime 参数，但是其中之一是&amp;lt;code&amp;gt;&amp;amp;amp;self&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;&amp;amp;amp;mut self&amp;lt;&amp;#x2F;code&amp;gt;，那么所有 output lifetimes 都跟&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;的生命周期相同。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;我们在编译器的角度看几个函数签名。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word(s: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;首先应用规则一，每个参数都有自己的生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(s:&amp;amp;amp;&amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;接着规则二也符合：只有一个参，那么返回值的生命周期也确定了&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(s:&amp;amp;amp;&amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;&amp;#x27;a str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;在看另外一个例子：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn longest(x: &amp;amp;amp;str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;首先规则一：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn longest&amp;amp;lt;&amp;#x27;a, &amp;#x27;b&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a str, y: &amp;amp;amp;&amp;#x27;b str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;接下来规则二不适用，因为有两个参数；规则三也不适用，因为它不是一个方法，没有&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;参数。三条规则结束，还没能确定返回值的生命周期，此时编译器报错退出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lifetime-annotations-in-method-definitions&amp;quot;&amp;gt;Lifetime Annotations in Method Definitions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当我们实现方法当时候声明其生命周期时，它的定义方式和泛型类型一样。我们在何处定义和使用生命周期参数取决于他们是否和方法的参数或者实例字段以及返回值相关。结构体字段的生命周期名称任何情况下都需要在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字后声明和在结构体名称中使用，因为它是结构体声明的一部分。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在方法签名中，引用可能会跟实例字段的生命周期绑定，也可能是独立的。此外，&amp;lt;em&amp;gt;生命周期省略规则&amp;lt;&amp;#x2F;em&amp;gt;通常使方法生命中不需要定义生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通过之前的&amp;lt;code&amp;gt;ImportantExcerpt&amp;lt;&amp;#x2F;code&amp;gt;结构体来看一些例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; ImportantExcerpt&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; {
    fn level(&amp;amp;amp;self) -&amp;amp;gt; i32 {
        3
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;后声明生命周期参数，在结构体名称后使用是必须的。但是由于生命周期省略规则一，不需要在方法签名中声明生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; ImportantExcerpt&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; {
    fn announce_and_return_part(&amp;amp;amp;self, announcement: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {
        println!(&amp;amp;quot;Attention please: {}&amp;amp;quot;, announcement);
        self.part
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面是一个符合生命周期省略规则三的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;the-static-lifetime&amp;quot;&amp;gt;The Static Lifetime&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;一个需要说明的特殊生命周期是&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;，意思是引用在整个程序执行期间都有效。字符串字面量的生命周期都是&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;let s: &amp;amp;amp;&amp;#x27;static str = &amp;quot;I have a static lifetime.&amp;quot;;&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;因为字符串字面量是直接写入可执行文件的，程序运行期间一直存在，所以它的生命周期是&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;可能在报错时你会看到编译器建议你使用&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;生命周期。但是这些问题可能是由于创建悬空指针或者生命周期不匹配造成的，首先应当解决真正的问题而不是无脑&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-generic-type-parameters-trait-bounds-and-lifetimes-together&amp;quot;&amp;gt;Section 4 - Generic Type Parameters, Trait Bounds, and Lifetimes Together&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;让我们把这三个概念使用在一个函数定义中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt::Display;

fn longest_with_an_announcement&amp;amp;lt;&amp;amp;#x27;a, T&amp;amp;gt;(
    x: &amp;amp;amp;&amp;amp;#x27;a str,
    y: &amp;amp;amp;&amp;amp;#x27;a str,
    ann: T,
) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str
where
    T: Display,
{
    println!(&amp;amp;quot;Announcement! {}&amp;amp;quot;, ann);
    if x.len() &amp;amp;gt; y.len() {
        x
    } else {
        y
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Writing Automated Tests</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;09-write-tests&#x2F;"/>
            <updated>2021-08-16T04:00:31+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;09-write-tests&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-9-writing-automated-tests&amp;quot;&amp;gt;Chapter 9 - Writing Automated Tests&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;程序的正确性是它按我们的预期运行的程度。Rust 被设计为高度关注程序正确性的语言，但正确性很复杂而且不容易实现。Rust 的类型系统承担了大部分的工作，但是类型系统不能够捕获所有可能的错误。因此，Rust 支持编写自动测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-ru-he-bian-xie-ce-shi-yong-li&amp;quot;&amp;gt;Section - 1 如何编写测试用例&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;测试用例是用来验证代码是否按预期设计运行的函数。测试用例通常包含三部分：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;初始化需要的数据和状态。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;运行需要测试的代码。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;断言结果是否正确。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ol&amp;gt;
&amp;lt;p&amp;gt;接下来看一下 Rust 为编写测试用例特别提供的功能。包括&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;属性，一些宏和&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;属性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;the-anatomy-of-a-test-function&amp;quot;&amp;gt;The Anatomy of a Test Function&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;最简单的情况，Rust 中一个测试用例就是一个带&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;属性的函数。属性是关于代码片段的元数据。在函数定义前加一行&amp;lt;code&amp;gt;#[test]&amp;lt;&amp;#x2F;code&amp;gt;，这个函数就是测试用例函数。然后当你执行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;，Rust 创建一个用来执行测试用例的可执行文件，这个文件会调用被&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;属性标记的函数，并且报告这些测试的结果是成功还是失败。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当我们使用&amp;lt;code&amp;gt;Cargo&amp;lt;&amp;#x2F;code&amp;gt;创建库项目时，会自动生成一个测试模块，你可以自己添加其他的测试模块和函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;首先创建一个库项目。&amp;lt;code&amp;gt;cargo new adder --lib&amp;lt;&amp;#x2F;code&amp;gt;。然后可以看到默认创建好的测试模块和用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;先把注意力集中到测试用例上。函数上面一行的&amp;lt;code&amp;gt;#[test]&amp;lt;&amp;#x2F;code&amp;gt;表明这个函数是一个测试用例，test runner 会在测试的时候执行这个函数。测试模块中也可以包含普通的函数，用于初始化或者提供普通的操作。因此需要在测试用例前用属性指明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;函数体中使用到了&amp;lt;code&amp;gt;assert_eq!&amp;lt;&amp;#x2F;code&amp;gt;宏。这个断言是一个典型的测试用例。运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;会得到以下输出信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;$ cargo test
Compiling adder v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;rust_learn&amp;amp;#x2F;adder)
 Finished test [unoptimized + debuginfo] target(s) in 0.57s
  Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到在&amp;lt;code&amp;gt;running 1 test&amp;lt;&amp;#x2F;code&amp;gt;这一行下面，显示运行了一个测试用例&amp;lt;code&amp;gt;it_works&amp;lt;&amp;#x2F;code&amp;gt;，并且运行结果是&amp;lt;code&amp;gt;ok&amp;lt;&amp;#x2F;code&amp;gt;。测试用例的运行结果汇总统计在下面一行。&amp;lt;code&amp;gt;test result: ok&amp;lt;&amp;#x2F;code&amp;gt;表示所有的测试用例都通过了测试，并且后面&amp;lt;code&amp;gt;1 passed; 0 failed;&amp;lt;&amp;#x2F;code&amp;gt;统计了成功和失败的数量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;测试输出的下一个部分是&amp;lt;code&amp;gt;Doc-tests&amp;lt;&amp;#x2F;code&amp;gt;，这个是文档测试的结果。我们这里没有文档测试，Rust 能在 API 文档里生成示例代码。这个功能让代码和文档保持同步。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;再添加一个失败结果的测试用例。每一个测试用例都跑在单独的线程中，主线程如果发现有一个测试线程失败，就把测试结果标记为失败。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&amp;amp;quot;Make this test fail&amp;amp;quot;);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;再运行测试用例，会得到如下输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::it_works ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
thread &amp;amp;#x27;tests::another&amp;amp;#x27; panicked at &amp;amp;#x27;Make this test fail&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到有两块&amp;lt;code&amp;gt;failures&amp;lt;&amp;#x2F;code&amp;gt;内容是之前没有的。第一部分是失败用例的文件路径和产生错误的代码位置。第二块是失败的用例名列表，当失败的用例非常多时，这个列表就很有用了。我们可以通过单独运行某个用例获取更多的错误信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面的摘要行显示，测试结果是&amp;lt;code&amp;gt;FAILED&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;yong-assert-hong-duan-yan-jie-guo&amp;quot;&amp;gt;用&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏断言结果&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏是由标准库提供的，用于在测试中确定运行结果是否为真。&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;一个返回布尔值的表达式。如果返回值是&amp;lt;code&amp;gt;true&amp;lt;&amp;#x2F;code&amp;gt;，它不会做任何特殊处理，并且该测试用例结果为&amp;lt;code&amp;gt;ok&amp;lt;&amp;#x2F;code&amp;gt;。如果为&amp;lt;code&amp;gt;false&amp;lt;&amp;#x2F;code&amp;gt;，它会调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏来让测试用例失败。使用&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;断言来检测函数是否按照我们的预期设计执行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面写一些测试用例，用来测试之前章节中定义的&amp;lt;code&amp;gt;Rectangle&amp;lt;&amp;#x2F;code&amp;gt;结构体。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;amp;amp;self, other: &amp;amp;amp;Rectangle) -&amp;amp;gt; bool {
        self.width &amp;amp;gt; other.width &amp;amp;amp;&amp;amp;amp; self.height &amp;amp;gt; other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;amp;amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;amp;amp;larger));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意在测试模块中引入了待测试模块的命名空间。测试模块跟普通模块一样，也要遵循命名空间规则。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-assert-eq-he-assert-ne-duan-yan-xiang-deng-xing&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;assert_eq!&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;assert_ne!&amp;lt;&amp;#x2F;code&amp;gt;断言相等性&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;判断相等性可以在&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏中传入一个&amp;lt;code&amp;gt;==&amp;lt;&amp;#x2F;code&amp;gt;表达式。但是由于这种判断是一个常用场景，因此标准库提供了专门用来判断相等性的宏。这两个宏接收两个参数来判断它们是否相等。断言失败时它们会打印出参数值，可以更清楚的知道测试用例为什么失败。而&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏的话，只能表示它的参数&amp;lt;code&amp;gt;==&amp;lt;&amp;#x2F;code&amp;gt;表达式返回了一个&amp;lt;code&amp;gt;false&amp;lt;&amp;#x2F;code&amp;gt;，而不能确定导致它失败的具体参数是什么。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;比如写一个函数，将它的参数+2。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_two(a:i32) -&amp;amp;gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
    #[test]
    fn it_adds_three() {
        assert_eq!(5, add_two(2));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;测试用例运行结果为如下&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::it_adds_two ... ok
test tests::it_adds_three ... FAILED

failures:

---- tests::it_adds_three stdout ----
thread &amp;amp;#x27;tests::it_adds_three&amp;amp;#x27; panicked at &amp;amp;#x27;assertion failed: `(left == right)`
left: `5`,
right: `4`&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:16:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_three

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一个用例通过。第二个用例，由于我们断言传的参数&amp;lt;code&amp;gt;add_two&amp;lt;&amp;#x2F;code&amp;gt;的结果为 5，因此测试结果为失败。并且指出它的错误原因是左右值不想等，且&amp;lt;code&amp;gt;left&amp;lt;&amp;#x2F;code&amp;gt;是 5，&amp;lt;code&amp;gt;right&amp;lt;&amp;#x2F;code&amp;gt;是 4。一些测试框架和语言中，可能把相等性判断的两个参数称为&amp;lt;code&amp;gt;expected&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;actual&amp;lt;&amp;#x2F;code&amp;gt;。Rust 中称为&amp;lt;code&amp;gt;left&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;right&amp;lt;&amp;#x2F;code&amp;gt;。参数传递的顺序对测试结果没有影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;assert_ne!&amp;lt;&amp;#x2F;code&amp;gt;宏跟它的作用一样，逻辑相反。一般 ne 函数用于那些我们不确定结果是什么值，但是可以确定结果不该是某个值的情况下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在接口底层，&amp;lt;code&amp;gt;assert_eq!&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;assert_ne!&amp;lt;&amp;#x2F;code&amp;gt;分别使用的是&amp;lt;code&amp;gt;==&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;!=&amp;lt;&amp;#x2F;code&amp;gt;运算符。当测试不通过时，这些宏通过 debug 格式化来打印参数信息，也就是说用于比较的参数值必须实现&amp;lt;code&amp;gt;PartialEq&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Debug&amp;lt;&amp;#x2F;code&amp;gt;两个 trait。所有基础类型和大部分标准库提供的类型都实现了这两个 trait。你自己定义的 struct 和 enum，需要你自己实现&amp;lt;code&amp;gt;PartialEq&amp;lt;&amp;#x2F;code&amp;gt;trait 来定义相等性。如果你需要测试不通过时打印参数信息，你还需要实现&amp;lt;code&amp;gt;Debug&amp;lt;&amp;#x2F;code&amp;gt;模块。由于这两个模块都是可派生模块，可以直接在自定义的 struct 和 enum 前面加&amp;lt;code&amp;gt;#[derive(PartialEq, Debug)]&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;tian-jia-zi-ding-yi-cuo-wu-xin-xi&amp;quot;&amp;gt;添加自定义错误信息&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏语法，将错误信息加在断言函数的最后。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn greeting(name: &amp;amp;amp;str) -&amp;amp;gt; String {
    String::from(&amp;amp;quot;Hello!&amp;amp;quot;)
}
&amp;amp;#x2F;&amp;amp;#x2F; 省略
assert!(
    result.contains(&amp;amp;quot;Carol&amp;amp;quot;),
    &amp;amp;#x2F;&amp;amp;#x2F; 错误信息
    &amp;amp;quot;Greeting did not contain name, value was `{}`&amp;amp;quot;,
    result
);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;checking-for-panics-with-should-panic&amp;quot;&amp;gt;Checking for Panics with should_panic&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;属性来检测，代码是不是按照预期发生了 panic。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&amp;amp;gt; Guess {
        if value &amp;amp;lt; 1 || value &amp;amp;gt; 100 {
            panic!(&amp;amp;quot;Guess value must be between 1 and 100, got {}.&amp;amp;quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;运行结果为 ok。我们传的值是 200，符合 panic 的条件，因此函数调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏。这个错误被&amp;lt;code&amp;gt;#[should_panic]&amp;lt;&amp;#x2F;code&amp;gt;捕获到了，测试结果跟我们预期的一样，因此它是一个成功的测试用例。换句话说，&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;只用来检测那些会 panic 的情况，如果没有发生 panic，那么这个用例就是失败。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;仅使用&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;来检测 panic 不是很精确，因为可能代码中 panic 没有携带有用信息。&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;可以接收参数，在 panic 发生时，这个参数会跟错误信息一起打印出来。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zai-ce-shi-yong-li-zhong-shi-yong-result-t-e&amp;quot;&amp;gt;在测试用例中使用&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;可以在测试用例中&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;来替代断言宏。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&amp;amp;gt; Result&amp;amp;lt;(), String&amp;amp;gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&amp;amp;quot;two plus two does not equal four&amp;amp;quot;))
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个测试用例返回一个&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;。同时可以在测试用例内部使用问号操作符。当使用&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;时，不能使用&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;属性，此时必须显式地返回一个&amp;lt;code&amp;gt;Err&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-controlling-how-tests-are-run&amp;quot;&amp;gt;Section 2 - Controlling How Tests Are Run&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;编译代码并且运行结果可执行文件，同样的，&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;在测试模式编译代码然后运行测试用例可执行文件。你可以通过指定命令参数，来改变&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;的默认行为。&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;编译生成的可执行文件的默认行为是：并行运行所有测试用例，捕获测试用例的输出信息，并加工成跟测试用例相关联的，阅读友好的输出信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;某些命令行参数是给&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;执行的，而某些是给编译完的可执行文件执行的。为了区分这两种类型的参数，用于&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;执行的参数跟在&amp;lt;code&amp;gt;--&amp;lt;&amp;#x2F;code&amp;gt;后面，然后后面再跟的是给可执行文件执行的参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;bing-xing-he-chuan-xing&amp;quot;&amp;gt;并行和串行&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当执行多个测试用例，默认的行为是多线程并行执行。因此测试代码可以最快运行完毕并且输出测试反馈。由于每个测试用例是单独一个线程的，所以保证每个用例是独立的，没有共享状态或者共享环境等。比如多个测试用例是对一个文件进行读写，当并发进行时，有可能进程 A 在读的时候，文件被进程 B 覆盖了，导致进程 A 测试失败。然而这并不是由于逻辑代码引起的错误。解决方法是所有测试用例隔离测试环境，或者串行测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;用参数&amp;lt;code&amp;gt;cargo test -- --test-threads=1&amp;lt;&amp;#x2F;code&amp;gt;指定执行的线程数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;xian-shi-bei-ce-shi-han-shu-de-shu-chu-xin-xi&amp;quot;&amp;gt;显示被测试函数的输出信息&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;默认情况下，Rust 会将测试通过用例下的函数输出信息全部捕获，只输出测试通过的信息。而测试用例失败时，所有信息信息都会被输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;
fn prints_and_returns_10(a: i32) -&amp;amp;gt; i32 {
    println!(&amp;amp;quot;I got the value {}&amp;amp;quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;默认测试上面的代码。输出以下信息&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread &amp;amp;#x27;main&amp;amp;#x27; panicked at &amp;amp;#x27;assertion failed: `(left == right)`
left: `5`,
right: `10`&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;cargo test -- --show-output&amp;lt;&amp;#x2F;code&amp;gt;参数，输出测试用例信息以及函数本身的输出信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread &amp;amp;#x27;main&amp;amp;#x27; panicked at &amp;amp;#x27;assertion failed: `(left == right)`
left: `5`,
right: `10`&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;running-a-subset-of-tests-by-name&amp;quot;&amp;gt;Running a Subset of Tests by Name&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过指定测试用例名称来运行特定的测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_two(a: i32) -&amp;amp;gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;默认运行测试用例&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时，所有的用例都会被执行：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;yun-xing-dan-ge-ce-shi&amp;quot;&amp;gt;运行单个测试&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo test [test_name]&amp;lt;&amp;#x2F;code&amp;gt;，例如&amp;lt;code&amp;gt;cargo test one_hundred&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到输出信息中说明&amp;lt;code&amp;gt;2 filtered out&amp;lt;&amp;#x2F;code&amp;gt;，有两个用例被过滤掉了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;yun-xing-duo-ge-ce-shi&amp;quot;&amp;gt;运行多个测试&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们可以在指定测试用例名称时，只指定其中的一部分名称。Rust 会运行所有名称包含我们参数的测试用例。例如&amp;lt;code&amp;gt;cargo test add&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;有两个用例名称包含 add，所以他们都被运行了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mo-ren-guo-lu-mou-xie-yong-li-chu-fei-ming-que-zhi-ding&amp;quot;&amp;gt;默认过滤某些用例除非明确指定&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在测试用例前加&amp;lt;code&amp;gt;ignore&amp;lt;&amp;#x2F;code&amp;gt;参数来默认跳过该用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    &amp;amp;#x2F;&amp;amp;#x2F; code that takes an hour to run
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时，输出如下&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看出&amp;lt;code&amp;gt;expensive_test&amp;lt;&amp;#x2F;code&amp;gt;显示被跳过了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;增加&amp;lt;code&amp;gt;cargo test -- --ignore&amp;lt;&amp;#x2F;code&amp;gt;参数，运行有&amp;lt;code&amp;gt;ignore&amp;lt;&amp;#x2F;code&amp;gt;属性的测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以将一些耗时任务标记为&amp;lt;code&amp;gt;ignore&amp;lt;&amp;#x2F;code&amp;gt;单独执行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-test-organization&amp;quot;&amp;gt;Section 3 - Test Organization&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 社区认为测试主要分为：单元测试和集成测试。单元测试更小更集中，同一时间只隔离测试一个模块，并且可以测试私有接口。集成测试更系统化，包含范围可能延展到我们整个库，且仅测试公有接口。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;dan-yuan-ce-shi&amp;quot;&amp;gt;单元测试&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;单元测试的目的是为了在隔离环境下快速地测试某个单一模块是否能按预期运行。单元测试放在 src 目录下的每个文件中，里面包含要测试的代码。最方便的方法是每个文件中都创建一个 test 模块，并且带测试模块前加&amp;lt;code&amp;gt;#[cfg(test)]&amp;lt;&amp;#x2F;code&amp;gt;注释。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;the-tests-module-and-cfg-test&amp;quot;&amp;gt;The Tests Module and #[cfg(test)]&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;#[cfg(test)]&amp;lt;&amp;#x2F;code&amp;gt;注释告诉编译器，只有当运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;命令时，才进行这些测试用例，&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;的时候不运行这些测试用例。这样可以缩短编译时间，而且不包含测试用例代码，也控制了编译结果文件的大小。由于集成测试在其他的目录中，所以不需要这个注释。由于单元测试和逻辑代码是在一起的，因此需要将他们标记，不要构建到最终的结果中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前我们新建 lib 项目时，cargo 自动生成了一个测试模块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cfg&amp;lt;&amp;#x2F;code&amp;gt;代表配置并且告诉编译器下面的内容只有满足了该配置时，才会被编译。在这个例子中，模块配置是&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;，这是 Rust 提供的用来编译和执行测试用例的。只有当我们运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时 Cargo 才会编译该测试代码。除了测试模块下的测试用例不会被编译，其他的一些帮助函数也不会被编译。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;testing-private-functions&amp;quot;&amp;gt;Testing Private Functions&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;社区一直有争论，私有接口应不应该直接去测试私有接口。其他语言测试私有接口是很困难的。不论你持何种观念，Rust 私有规则都允许你直接测试私有接口。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_two(a: i32) -&amp;amp;gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&amp;amp;gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;internal_adder&amp;lt;&amp;#x2F;code&amp;gt;函数没有&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字，但是依然可以在&amp;lt;code&amp;gt;tests&amp;lt;&amp;#x2F;code&amp;gt;模块中引入测试。Rust 不强制测试私有接口。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;ji-cheng-ce-shi&amp;quot;&amp;gt;集成测试&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 中的集成测试代码完全处于你的库之外。集成测试调用库的方式和其他代码一样，也就是说集成测试可以只调用部分 API。集成测试的目的是检测你的库中多个模块一起工作时正确与否。即使单元测试通过，集成测试有可能也会出现问题。创建集成测试首先需要创建&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;tests-mu-lu&amp;quot;&amp;gt;tests 目录&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;在于&amp;lt;em&amp;gt;src&amp;lt;&amp;#x2F;em&amp;gt;目录同级的根目录下创建&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录，Cargo 会在这个目录下查找集成测试文件。然后可以任意在这个目录下添加测试文件，Cargo 会将这些文件编译成独立的 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;让我们来创建一个集成测试目录，并创建一个新文件&amp;lt;em&amp;gt;tests&amp;#x2F;integration_test.rs&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个文件中的代码不需要用&amp;lt;code&amp;gt;#[cfg(test)]&amp;lt;&amp;#x2F;code&amp;gt;标注，Rust 会对&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录下的文件特殊处理，只有运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;的时候才会编译这个目录下的文件。运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;看下效果。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;  Compiling adder v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;rust_learn&amp;amp;#x2F;adder)
   Finished test [unoptimized + debuginfo] target(s) in 1.07s
    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;adder-9d658908b5cc4b63

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;integration_test-48170a4e87fe33c4

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

    Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到有三块内容输出：单元测试、集成测试和文档测试。使用&amp;lt;code&amp;gt;--test &amp;amp;lt;testname&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;可以仅执行某部分集成测试。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;submodules-in-integration-tests&amp;quot;&amp;gt;Submodules in Integration Tests&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当你的集成测试越来越多时，你可能想要把这些测试组织到&amp;lt;em&amp;gt;test&amp;lt;&amp;#x2F;em&amp;gt;目录下不同的文件中。比如，可以按照测试的函数功能来组织测试用例。之前已经提到过，集成测试会被编译成单独的 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;把集成测试当作独立的 crate，有助于创建独立的作用域，让集成测试的场景更接近其他用户调用你的 crate 的真实场景。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当我们在&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录下，想抽象一些通用代码供各个集成测试调用时，Rust 会把这写通用代码也当作集成测试编译成单独的 crate。例如，创建&amp;lt;em&amp;gt;tests&amp;#x2F;common.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，并写入一个&amp;lt;code&amp;gt;setup&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn setup() {
    &amp;amp;#x2F;&amp;amp;#x2F; something
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时，会发现测试结果输出多了一块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;common.rs&amp;lt;&amp;#x2F;em&amp;gt;中的内容被当作测试用例执行和打印不是我们想要的结果。我们只想它里面的代码供其他测试用例调用。可以通过创建&amp;lt;em&amp;gt;tests&amp;#x2F;mod&amp;#x2F;common.rs&amp;lt;&amp;#x2F;em&amp;gt;来代替，Rust 不会将这个目录下的文件当作集成测试来处理。此时，测试结果输出中也不会包含相应的内容了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当我们创建这个通用代码之后，就可以在其他集成测试文件中调用。例如：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;注意&amp;lt;code&amp;gt;mod common;&amp;lt;&amp;#x2F;code&amp;gt;的写法，之前讲过分号结尾是将该模块引入。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;h3 id=&amp;quot;integration-tests-for-binary-crates&amp;quot;&amp;gt;Integration Tests for Binary Crates&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果你的项目只有&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;，即你的项目是一个可执行 crate，此时不能创建集成测试。只有库 crate 才能创建集成测试，库 crate 导出的方法才能被其他 crate 用 use 导入和使用。可执行 crate 导出的函数只能内部使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这也是 Rust 项目在&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;文件中只调用&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;逻辑的原因之一。使用这种架构的话，集成测试来测试占绝大部分比例的库 crate 代码中的功能，而&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;中极少比例且几乎不含功能逻辑的调用代码不需要测试，仅需要阅读就可以判断其是否正确运行。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Smart Pointers</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;12-smart-pointer&#x2F;"/>
            <updated>2021-06-25T21:58:19+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;12-smart-pointer&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-12-smart-pointers&amp;quot;&amp;gt;Chapter 12 - Smart Pointers&amp;lt;&amp;#x2F;h1&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Ownership</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;02-ownership&#x2F;"/>
            <updated>2021-05-08T09:42:34+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;02-ownership&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-2-ownership&amp;quot;&amp;gt;Chapter 2 - Ownership&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Ownership 是 Rust 最重要的功能之一，它在没有&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;en.wikipedia.org&amp;#x2F;wiki&amp;#x2F;Garbage_collection_(computer_science)&amp;quot;&amp;gt;gc&amp;lt;&amp;#x2F;a&amp;gt;的前提下保证了内存读写安全。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-shen-me-shi-ownership&amp;quot;&amp;gt;Section 1 - 什么是 Ownership&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;ownership&amp;lt;&amp;#x2F;em&amp;gt;是 Rust 的核心功能，虽然这个概念很容易解释，但是对于其他语言而言是一个很陌生的概念。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所有程序都有内存调度的方式，比如很常见的 gc，不断的收集没有在使用的内存碎片。很多语言都需要明确的分配和释放内存，Rust 则使用外的方式：通过 ownership 下的一组规则，在编译阶段对内存进行检查，对运行时的性能没有任何影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;:::details Stack 和 Heap
stack 和 heap 都是在程序运行时可以使用的一部分内存，但是他们的结构不一样。栈是先进先出（FILO）的调度策略，数据入栈操作称&amp;lt;em&amp;gt;push&amp;lt;&amp;#x2F;em&amp;gt;，出栈称为&amp;lt;em&amp;gt;pop&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所有在 stack 上存储的数据，其大小都必须是已知和固定的。数据大小在编译阶段无法确定，或者可能会在运行时扩容的数据，都必须存储 heap。堆的组织性比较差，首先需要在堆内存中请求一块空间。内存调度器会找一块大小合适的空内存并把它打上标记，表示已被使用，然返回一个&amp;lt;em&amp;gt;指针（pointer）&amp;lt;&amp;#x2F;em&amp;gt;。指针代表的是该内存区域的地址。这个过程称为&amp;lt;em&amp;gt;allocating&amp;lt;&amp;#x2F;em&amp;gt;。由于指针是大小确定且固定的数据，因此针可以存储在 stack 上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;stack 存储比 heap 要快，因为不需要内存调度器分配内存，stack 的指针始终在其顶部。相比之下，heap 内存分配需要内存调度寻找大小和据匹配的内存，并且还需要为下一次分配做一些前置工作比如内存标记等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;stack 访问也比 heap 快，因为 heap 需要先根据存储在 stack 上的指针寻址。在多个指针跳转时，这些指针如果相隔太远，也会让访问更慢。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在调用函数时，参数（可能是 heap 上数据的指针）和函数的内部变量会被存进 stack。函数执行结束时这些数据会从 stack 中清除。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;保持对 heap 数据使用的监控，最小化这些 heap 上的数据内存大小，减少重复数据内容，清空没有使用的内存已确保不会内存溢出。这些都 ownership 解决的问题
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;ownership-rules&amp;quot;&amp;gt;Ownership Rules&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Rust 中每个值都有一个变量作为它的 owner&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;每个值只能有一个 owner&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;当 owner 超出作用域块，值将被删除&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h3 id=&amp;quot;variable-scope&amp;quot;&amp;gt;Variable scope&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;变量在定义的那一刻有效，直到定义该变量的作用域执行完毕。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{ &amp;amp;#x2F;&amp;amp;#x2F; s is not valid here, it’s not yet declared
  let s = &amp;amp;quot;hello&amp;amp;quot;; &amp;amp;#x2F;&amp;amp;#x2F; s is valid from this point forward
  &amp;amp;#x2F;&amp;amp;#x2F; do stuff with s
} &amp;amp;#x2F;&amp;amp;#x2F; this scope is now over, and s is no longer valid
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;stringlei-xing&amp;quot;&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;为了说明 ownership 的作用机制，需要一个比 Chapter1 中的基础数据类型稍微复杂一些的数据，之前介绍的数据全都是存储在 stack 上的，但是目前我们需要存储在 heap 上的数据，用来解释 Rust 如何决策释放 heap 内存的时机。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这里用&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型举例，专注于它和 ownership 相关的部分，这些特性在其他复杂数据类型也适用，不论是标准库导出的还是你自己定义的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前的代码块使用了字符串字面量，这种方式很便捷，但是在大部分场景下这种方式不太适用。一方面是因为字符串字面量是 immutable 的，其次是因为大部分情况下我们并不知道要存储的数据是什么，比如存储用户输入。因此 Rust 还有另外一种字符串类型，&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;。这种类型是分配在 heap 上的，因此能够任意修改和存储任意大小的数据。&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型可以通过标准库导出的&amp;lt;code&amp;gt;from&amp;lt;&amp;#x2F;code&amp;gt;方法来创建&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;  let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这种 string 数据可以修改&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;  s.push_str(&amp;amp;quot;, world!&amp;amp;quot;); &amp;amp;#x2F;&amp;amp;#x2F; push_str() appends a literal to a String

  println!(&amp;amp;quot;{}&amp;amp;quot;, s)
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;为什么字面量不可以修改而 String 却可以？主要区别在于这两种类型的内存处理方式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;memory-and-allocation&amp;quot;&amp;gt;Memory and Allocation&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;字符串字面量在编译截断是知道其内容的，因此它直接被 hardcode 到可执行文件中，因此它更快更有效率。这些特性也只有在数据不变时才有效。但是对于大小、数据在编译阶段都不确定，运行时会改变其内容的数据来说，无法在可执行文件中为这些数据插入 blob 内存。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型为了支持数据可变、内存可扩容，在编译阶段无法确定数据内容，在 heap 上分配了一定数量的内存出来。这意味着：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;内存必须在运行时由内存调度器分配。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;需要一种在内存使用完毕时，将内存交还给内存调度器的方法。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;第一点由编码人员控制：当执行&amp;lt;code&amp;gt;String::from&amp;lt;&amp;#x2F;code&amp;gt;方法时，它会去请求所需要的内存大小。这在大多数语言里都差不多。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第二点 Rust 与其他语言有些差异。在有 gc 机制的语言中，gc 会持续检查内存，回收没有使用的内存碎片。但是在没有 gc 机制的语言中，内存回收就是编码人员的职责，此时我们需要显式调用释放内存，就像申请内存时调用&amp;lt;code&amp;gt;String::from&amp;lt;&amp;#x2F;code&amp;gt;方法一样。内存管理一直都是一个难题，如果编码人员忘记回收内存，就会造成内存泄露；如果回收的太早，又会导致程序拿到一个悬空指针；如果对同一块内存释放了两次，同样也是个 bug。编码人员必须保证一次申请匹配一次释放。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 使用了一种不同的方式：当 owner 变量所在的作用域执行结束时，其内存会被自动回收。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;); &amp;amp;#x2F;&amp;amp;#x2F; s is valid from this point forward

    &amp;amp;#x2F;&amp;amp;#x2F; do stuff with s
}   &amp;amp;#x2F;&amp;amp;#x2F; this scope is now over, and s is no longer valid
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当作用域结束时，Rust 会调用一个特殊方法&amp;lt;code&amp;gt;drop&amp;lt;&amp;#x2F;code&amp;gt;。
:::tip Node:
在 C++中，这种在生命周期结束时重新分配资源的模式被称作&amp;lt;em&amp;gt;Resource Acquisition Is Initialization (RAII)&amp;lt;&amp;#x2F;em&amp;gt;。如果你对这种模式比较熟悉，Rust 的&amp;lt;code&amp;gt;drop&amp;lt;&amp;#x2F;code&amp;gt;方法同样也很容易理解。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;ways-variables-and-data-interact-move&amp;quot;&amp;gt;Ways Variables and Data Interact: Move&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;在 Rust 中多个变量对相同数据的交互方式有多种。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;
let y = x;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子很好理解，将 5 绑定到变量&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;上，创建一份变量&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;的值的拷贝并绑定在变量&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;上。整型数字是数据已知、大小确定的，在 stack 上会存储两份数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);
let s2 = s1;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子在写法上和上面的例子看起来一致，但是在行为上有很大的差别。下图说明了&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型底层所做的逻辑。&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型由左侧三部分组成：一个指向 heap 的内存地址，表示长度的值，表示容量的值，这组数据存储在 stack 上。右侧是 heap 上存储数据的内存。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;!-- ![img4-1](https:&amp;#x2F;&amp;#x2F;gitee.com&amp;#x2F;ksleo&amp;#x2F;source&amp;#x2F;raw&amp;#x2F;master&amp;#x2F;trpl04-01.svg) --&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-01.svg&amp;quot; alt=&amp;quot;img4-1&amp;quot; &amp;#x2F;&amp;gt;
length 是指数据具体使用的内存字节长度，capacity 是&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型从内存调度器申请到的内存字节长度。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当把&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;赋值给&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;时，&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;数据被复制了，也就是指针、长度和容量这个数据结构被复制了，而具体存储在 heap 上的数据并没有被复制。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-02.svg&amp;quot; alt=&amp;quot;img4-2&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果&amp;lt;code&amp;gt;s2 = s1&amp;lt;&amp;#x2F;code&amp;gt;这段代码执行 heap 复制，如果在 heap 上的数据量过大，这将会是一个很昂贵的操作，性能带来损耗并且双倍的内存占用。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-03.svg&amp;quot; alt=&amp;quot;img4-3&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前提到变量所在作用域执行结束时，Rust 会自动调用&amp;lt;code&amp;gt;drop&amp;lt;&amp;#x2F;code&amp;gt;方法释放该段内存。但是在上面的例子中会出现问题：作用域结束时，&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;都执行释放操作，但是这两个指针指向的是同一个地址，这就会引起&amp;lt;em&amp;gt;多次释放同一内存&amp;lt;&amp;#x2F;em&amp;gt;的问题。为了确保内存安全，Rust 在这种情况下有其他一些细节：Rust 不会去复制 heap 内存，而是认为&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;已经是一个无效引用，在作用域执行结束时，Rust 不会执行任何与&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;相关的释放操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);
let s2 = s1;

println!(&amp;amp;quot;{}&amp;amp;quot;, s1);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0382]: borrow of moved value: `s1`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;执行以上代码，编译器会抛出错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果你熟悉深复制和浅复制的概念，之前&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型下复制指针、长度和容量数据结构的操作，就可以认为是浅复制。但是由于 Rust 同时又让第一个值&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;失效了，因此在 Rust 中称为&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;而不是&amp;lt;em&amp;gt;shallow copy&amp;lt;&amp;#x2F;em&amp;gt;。在刚才的例子中，可以认为&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;到了&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-04.svg&amp;quot; alt=&amp;quot;img4-4&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;ways-variables-and-data-interact-clone&amp;quot;&amp;gt;Ways Variables and Data Interact: Clone&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;如果我们执行 heap 数据深复制，而不仅仅是 stack 浅复制，可以调用&amp;lt;code&amp;gt;clone&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);
let s2 = s1.clone();

println!(&amp;amp;quot;s1 = {}, s2 = {}&amp;amp;quot;, s1, s2);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;stack-only-data-copy&amp;quot;&amp;gt;Stack-Only Data: Copy&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;
let y = x;

println!(&amp;amp;quot;x = {}, y = {}&amp;amp;quot;, x, y);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这段代码执行不会有任何问题。但这与刚刚得到到结论出现了分歧：在没有调用 clone 得情况下，&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;仍然是有效的，看似没有发生&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;原因在于整型变量是编译时大小固定的，存储在 stack 上，并且其值很容易复制。也就是说没有必要在&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;创建后，将&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;标记为失效。也就是说在这种情况下，浅复制和深复制没有任何区别，所以就算调用&amp;lt;code&amp;gt;clone&amp;lt;&amp;#x2F;code&amp;gt;方法，也不会与浅复制在行为上有任何的不同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 有一个特殊的标记被称作&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait。一切在 stack 上存储的数据类型都可以理解为存在这个&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait。如果一个类型有&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait，旧的变量被分配给新的变量后仍然是有效的。Rust 不允许我们给任何实现，或者其任何一部分实现了&amp;lt;code&amp;gt;Drop&amp;lt;&amp;#x2F;code&amp;gt; trait 的类型做&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait 标记。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;任何基础数据类型的组合是&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;的，凡是不需要分配或属于某种形式的资源的，都是&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;。下面是一些&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;类型举例：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;所有整型，例如&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;所有浮点，例如&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;bool&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;char&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;只包含&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;类型的 tuples。比如&amp;lt;code&amp;gt;(u32, u64)&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;(u32, String)&amp;lt;&amp;#x2F;code&amp;gt;不是。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h3 id=&amp;quot;ownership-and-functions&amp;quot;&amp;gt;Ownership and Functions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;把值传递给函数参数和传递给变量，在语义上是相似的，比如都会执行&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;或者复制。用一个例子说明&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);  &amp;amp;#x2F;&amp;amp;#x2F; s comes into scope

    takes_ownership(s); &amp;amp;#x2F;&amp;amp;#x2F; s&amp;amp;#x27;s value moves into the function
                                     &amp;amp;#x2F;&amp;amp;#x2F; and so is no longer valid here

    let x = 5;                  &amp;amp;#x2F;&amp;amp;#x2F; x comes into scope

    makes_copy(x);     &amp;amp;#x2F;&amp;amp;#x2F; x would move into the function,
                                     &amp;amp;#x2F;&amp;amp;#x2F; but i32 is Copy, so it’s okay to still
                                     &amp;amp;#x2F;&amp;amp;#x2F; use x afterward

} &amp;amp;#x2F;&amp;amp;#x2F; Here, x goes out of scope, then s. But because s&amp;amp;#x27;s value was moved, nothing
  &amp;amp;#x2F;&amp;amp;#x2F; special happens.

fn takes_ownership(some_string: String) { &amp;amp;#x2F;&amp;amp;#x2F; some_string comes into scope
    println!(&amp;amp;quot;{}&amp;amp;quot;, some_string);
} &amp;amp;#x2F;&amp;amp;#x2F; Here, some_string goes out of scope and `drop` is called. The backing
  &amp;amp;#x2F;&amp;amp;#x2F; memory is freed.

fn makes_copy(some_integer: i32) { &amp;amp;#x2F;&amp;amp;#x2F; some_integer comes into scope
    println!(&amp;amp;quot;{}&amp;amp;quot;, some_integer);
} &amp;amp;#x2F;&amp;amp;#x2F; Here, some_integer goes out of scope. Nothing special happens.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;return-values-and-scope&amp;quot;&amp;gt;Return Values and Scope&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数返回值也会使 ownership 发生转移。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s1 = gives_ownership();         &amp;amp;#x2F;&amp;amp;#x2F; gives_ownership moves its return
                                        &amp;amp;#x2F;&amp;amp;#x2F; value into s1

    let s2 = String::from(&amp;amp;quot;hello&amp;amp;quot;);     &amp;amp;#x2F;&amp;amp;#x2F; s2 comes into scope

    let s3 = takes_and_gives_back(s2);  &amp;amp;#x2F;&amp;amp;#x2F; s2 is moved into
                                        &amp;amp;#x2F;&amp;amp;#x2F; takes_and_gives_back, which also
                                        &amp;amp;#x2F;&amp;amp;#x2F; moves its return value into s3
} &amp;amp;#x2F;&amp;amp;#x2F; Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  &amp;amp;#x2F;&amp;amp;#x2F; moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&amp;amp;gt; String {             &amp;amp;#x2F;&amp;amp;#x2F; gives_ownership will move its
                                             &amp;amp;#x2F;&amp;amp;#x2F; return value into the function
                                             &amp;amp;#x2F;&amp;amp;#x2F; that calls it

    let some_string = String::from(&amp;amp;quot;hello&amp;amp;quot;); &amp;amp;#x2F;&amp;amp;#x2F; some_string comes into scope

    some_string                              &amp;amp;#x2F;&amp;amp;#x2F; some_string is returned and
                                             &amp;amp;#x2F;&amp;amp;#x2F; moves out to the calling
                                             &amp;amp;#x2F;&amp;amp;#x2F; function
}

&amp;amp;#x2F;&amp;amp;#x2F; takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -&amp;amp;gt; String { &amp;amp;#x2F;&amp;amp;#x2F; a_string comes into
                                                      &amp;amp;#x2F;&amp;amp;#x2F; scope

    a_string  &amp;amp;#x2F;&amp;amp;#x2F; a_string is returned and moves out to the calling function
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;变量的 ownership 遵循同一套模式：赋值给其他变量，ownership 就会转移。当一个变量的数据存储在 heap 上时，它所在的作用域在执行完毕后，该变量的 heap 空间就会被释放，除非它把 ownership 转移给其他变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果我们只想在函数中使用变量而不想转移其 ownership 呢？想一想除了要把函数主体逻辑的结果返回，还要要把传进函数的 ownership 再传出去，这也太操蛋了。我们可以通过&amp;lt;code&amp;gt;Tuple&amp;lt;&amp;#x2F;code&amp;gt;实现这个需求。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    let (s2, len) = calculate_length(s1);

    println!(&amp;amp;quot;The length of &amp;amp;#x27;{}&amp;amp;#x27; is {}.&amp;amp;quot;, s2, len);
}

fn calculate_length(s: String) -&amp;amp;gt; (String, usize) {
    let length = s.len(); &amp;amp;#x2F;&amp;amp;#x2F; len() returns the length of a String

    (s, length)
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;对于一个常见的概念来说，不应该做这么多大量的额外工作。好在 Rust 已经实现了这个功能，称之为&amp;lt;em&amp;gt;references&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-references-and-borrowing&amp;quot;&amp;gt;Section 2 - References and Borrowing&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;之前我们在&amp;lt;code&amp;gt;calculate_length&amp;lt;&amp;#x2F;code&amp;gt;中返回了一个元组用于返回函数结果和 ownership，以便我们在函数调用完成后可以继续使用&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;变量。因为之前提过，传参和赋值在行为上差不多是一致的，&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;变量传参进入&amp;lt;code&amp;gt;calculate_length&amp;lt;&amp;#x2F;code&amp;gt;函数后，其 ownership 也被转移到了函数内部，&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;此时是不可用的了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面是一个通过传入一个变量的 reference，来控制 ownership 不被传递到函数内部的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    let len = calculate_length(&amp;amp;amp;s1);

    println!(&amp;amp;quot;The length of &amp;amp;#x27;{}&amp;amp;#x27; is {}.&amp;amp;quot;, s1, len);
}

fn calculate_length(s: &amp;amp;amp;String) -&amp;amp;gt; usize { &amp;amp;#x2F;&amp;amp;#x2F; s is a reference to a String
    s.len()
} &amp;amp;#x2F;&amp;amp;#x2F; Here, s goes out of scope. But because it does not have ownership of what
  &amp;amp;#x2F;&amp;amp;#x2F; it refers to, nothing happens.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;首先 Tuple 被删除了，其次参数的定义和传递都加了一个&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;符号，这个符号代表的就是&amp;lt;em&amp;gt;references&amp;lt;&amp;#x2F;em&amp;gt;，引用可以只读变量的值而不转移其所有权。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-05.svg&amp;quot; alt=&amp;quot;img4-5&amp;quot; &amp;#x2F;&amp;gt;
:::tip Note
与&amp;lt;em&amp;gt;reference&amp;lt;&amp;#x2F;em&amp;gt;相对的操作称为&amp;lt;em&amp;gt;dereference&amp;lt;&amp;#x2F;em&amp;gt;，运算符是&amp;lt;code&amp;gt;*&amp;lt;&amp;#x2F;code&amp;gt;。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;s1&amp;lt;&amp;#x2F;code&amp;gt;这种语法创建了一个引用，指向被引用的值，但是不转移原变量的所有权。因为没有所有权，所以函数结束时，它指向的 heap 区域不会被释放。当函数参数以引用方式传递时，函数不再需要显式的返回所有权，因为所有权一开始就没有发生转移。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;引用作为函数参数称之为&amp;lt;em&amp;gt;borrowing&amp;lt;&amp;#x2F;em&amp;gt;。如果我们尝试改变引用，编译器会报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    change(&amp;amp;amp;s);
}

fn change(some_string: &amp;amp;amp;String) {
    some_string.push_str(&amp;amp;quot;, world&amp;amp;quot;);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;amp;amp;` reference
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;和变量的默认行为相同，引用也是 immutable 的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mutable-reference&amp;quot;&amp;gt;Mutable Reference&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;只需要进行一个改动，就可以获取一个 mutable 的引用。即在函数定义和调用的时候，在&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;操作符后加上&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    change(&amp;amp;amp;mut s);
}

fn change(some_string: &amp;amp;amp;mut String) {
    some_string.push_str(&amp;amp;quot;, world&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可变引用有一个限制，同一个作用域下，对同一个数据只能有一个可变引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let r1 = &amp;amp;amp;mut s;
let r2 = &amp;amp;amp;mut s;

println!(&amp;amp;quot;{}, {}&amp;amp;quot;, r1, r2);
&amp;amp;#x2F;&amp;amp;#x2F; error[E0499]: cannot borrow `s` as mutable more than once at a time
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这样做的好处在于避免在编译阶段造成数据竞争。数据竞争和竞态条件相似，在以下三个行为发生时会引发竞态：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;两个以上指针同时访问同一资源。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;至少一个指针正在被用于写操作。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;没有用于同步访问数据的机制。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;数据竞争在运行时调试时很难找出问题并且解决它。Rust 中不会发生这种情况，因为代码有可能引发竞态时，编译阶段就不会通过。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let r1 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
let r2 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
let r3 = &amp;amp;amp;mut s; &amp;amp;#x2F;&amp;amp;#x2F; BIG PROBLEM

println!(&amp;amp;quot;{}, {}, and {}&amp;amp;quot;, r1, r2, r3);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当存在 immutable 的引用时，不可以创建 mutable 的引用。可以存在多个 immutable 引用，因为仅仅读数据并不会造成脏读。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;引用的生命周期从定义它开始，到最后一次使用它结束，下面的代码编译是可以通过的，因为在 mutable 引用创建之前，immutable 引用的生命周期就结束了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let r1 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
let r2 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
println!(&amp;amp;quot;{}, {}&amp;amp;quot;, r1, r2);
let r3 = &amp;amp;amp;mut s; &amp;amp;#x2F;&amp;amp;#x2F; no problem

println!(&amp;amp;quot;{}&amp;amp;quot;, r3);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;尽管这类编译错误非常令人烦躁，但是在编译阶段明确指出问题所在总好过在运行时出错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;dangling-references&amp;quot;&amp;gt;Dangling References&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;悬空指针是指针指向的地址，被其他操作释放掉了。Rust 编译器保证不会出现悬空指针：如果有一个指针指向一块内存区域，编译器会保证在这块内存区域的数据被使用前，该指针所在的作用域不会结束。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面是一个创建悬空指针的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = dangle();
}

fn dangle() -&amp;amp;gt; &amp;amp;amp;String {
    let str = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    &amp;amp;amp;str
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这段代码编译器会报错，其中有这样一条帮助信息：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;this function’s return type contains a borrowed value, but there is no value for it to be borrowed from&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;因为&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;是在&amp;lt;code&amp;gt;dangle&amp;lt;&amp;#x2F;code&amp;gt;函数中创建的，当&amp;lt;code&amp;gt;dangle&amp;lt;&amp;#x2F;code&amp;gt;函数执行结束，&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;指向的内存区域也被释放了，意味着我们返回了一个不合法的&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;引用，Rust 编译器是不会允许此类情况发生的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;解决方法是直接返回原变量，也就是转移所有权，这样在函数结束后相关内存就不会被释放，因为所有权被转移到了外部变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn dangle() -&amp;amp;gt; String {
    let str = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    str
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;the-rules-of-references&amp;quot;&amp;gt;The Rules of References&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;任何情况下都只能有一个 mutable 引用或多个 immutable 引用。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;引用必须是有效的。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-the-slice-type&amp;quot;&amp;gt;Section 3 - The Slice Type&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;另外一种没有所有权的数据类型是切片，切片引用一段集合上连续的元素。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;引入一个小例子：写一个函数，接受一个 String 作为参数，返回它里面的第一个词。如果 String 中没有匹配到空格，说明传入的是一个词，此时返回原参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;考虑一下这个函数的声明该怎么写&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;String) -&amp;amp;gt; ?
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个方法中我们不想要获取所有权，所以传入一个引用。但是它应该返回什么类型？第一种方案可以返回结果的最后一个字母的下标。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;String) -&amp;amp;gt; usize {
    let bytes = s.as_bytes();
    for (i, &amp;amp;amp;item) in bytes.iter().emumrate() {
        if item == b&amp;amp;#x27; &amp;amp;#x27; {
            return i;
        }
    }
    s.len()
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个方法的问题在于，它返回的下标仅在&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;上下文中有意义，如果该引用的值被修改了，则之前的运算值也不正确了。如果我们返回的是前后两个下标&amp;lt;code&amp;gt;fn second_word(s: &amp;amp;amp;String) -&amp;amp;gt; (usize, usize) {&amp;lt;&amp;#x2F;code&amp;gt;，那么这种方式就更加脆弱，此时已经有三个不相关的变量需要保持数据同步了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;string-slices&amp;quot;&amp;gt;String Slices&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;字符串切片是字符串其中一段内容的引用。字符串切片可以使用下面的方法创建&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = String::from(&amp;amp;quot;hello world&amp;amp;quot;);

let hello = &amp;amp;amp;s[0..5];
let world = &amp;amp;amp;s[6..11];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;切片和引用是类似的，不过是用&amp;lt;code&amp;gt;[start_index..end_index]&amp;lt;&amp;#x2F;code&amp;gt;这种方式截断了字符串的一部分，该区间是左闭右开的。切片内部实现存储的是首地址和切片长度。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-06.svg&amp;quot; alt=&amp;quot;img4-6&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 的&amp;lt;code&amp;gt;..&amp;lt;&amp;#x2F;code&amp;gt;范围语法，如果定义的范围从 0 开始，那么 0 可以不写。所以，下面两种写法是一样的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let slice = &amp;amp;amp;s[0..2];
let slice = &amp;amp;amp;s[..2];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果范围是从头部到尾部，那么两边的数字都可以省略掉。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let len = s.len();

let slice = &amp;amp;amp;s[0..len];
let slice = &amp;amp;amp;s[..];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;:::warning 注意
字符串切片下标必须是在合法的 utf8 字符边界处，如果下标处于多字节字符之中，程序会抛出错误。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;有了这些相关概念，之前的&amp;lt;code&amp;gt;first_word&amp;lt;&amp;#x2F;code&amp;gt;函数可以做一些修改。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;String) -&amp;amp;gt; &amp;amp;amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;amp;amp;item) in bytes.iter().enumerate() {
        if (item == b&amp;amp;#x27; &amp;amp;#x27;) {
            return &amp;amp;amp;s[0..i];
        }
    }
    &amp;amp;amp;s[..]
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;之前的函数，在调用之后清空原来的 string，编译阶段不会出错，但是在运行时会引发 bug。现在经过改造之后的方法，在编译阶段就会指出问题所在。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let mut s = String::from(&amp;amp;quot;hello world&amp;amp;quot;);

    let word = first_word(&amp;amp;amp;s);

    s.clear(); &amp;amp;#x2F;&amp;amp;#x2F; error!

    println!(&amp;amp;quot;the first word is: {}&amp;amp;quot;, word);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;回顾之前的规则，当存在 immutable 的引用时，不能同时存在 mutable 的引用。&amp;lt;code&amp;gt;clear&amp;lt;&amp;#x2F;code&amp;gt;方法需要清空原字符串，所以它需要一个 mutable 的引用，Rust 是不允许的并在编译阶段直接抛错。Rust 编译器不光让自定义 API 更加易用，并且在编译阶段排除了许多潜在 bug。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;zi-fu-chuan-zi-mian-liang-shi-qie-pian-lei-xing&amp;quot;&amp;gt;字符串字面量是切片类型&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;之前提到，字符串字面量直接存储在可执行文件中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = &amp;amp;quot;hello&amp;amp;quot;;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里变量&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的类型是&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;，它是一个切片，指一个向可执行文件中字面量存储位置的指针。这就是为什么字符串字面量不可以修改了，因为&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;是一个 immutable 引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;zi-fu-chuan-qie-pian-zuo-wei-han-shu-can-shu&amp;quot;&amp;gt;字符串切片作为函数参数&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;之前的&amp;lt;code&amp;gt;first_word&amp;lt;&amp;#x2F;code&amp;gt;函数，有一个更好的定义方式是&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此时我们可以传&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;类型或者&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let my_string = String::from(&amp;amp;quot;hello world&amp;amp;quot;);

    &amp;amp;#x2F;&amp;amp;#x2F; first_word works on slices of `String`s
    let word = first_word(&amp;amp;amp;my_string[..]);

    let my_string_literal = &amp;amp;quot;hello world&amp;amp;quot;;

    &amp;amp;#x2F;&amp;amp;#x2F; first_word works on slices of string literals
    let word = first_word(&amp;amp;amp;my_string_literal[..]);

    &amp;amp;#x2F;&amp;amp;#x2F; Because string literals *are* string slices already,
    &amp;amp;#x2F;&amp;amp;#x2F; this works too, without the slice syntax!
    let word = first_word(&amp;amp;amp;my_string);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;qi-ta-qie-pian-lei-xing&amp;quot;&amp;gt;其他切片类型&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;数组切片&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let arr = [1,2,3,4,5];
let arr_slice = &amp;amp;amp;[0..2];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;arr_slice&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;&amp;amp;amp;[i32]&amp;lt;&amp;#x2F;code&amp;gt;类型的，它跟&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;的表现没有任何区别：存储一个头指针和内容长度。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Common Collections</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;06-common-collections&#x2F;"/>
            <updated>2021-03-10T09:54:00+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;06-common-collections&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-6-common-collections&amp;quot;&amp;gt;Chapter 6 - Common Collections&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Rust 标准库提供了很丰富的数据集合类。大多数数据结构通常只能存储一条数据，而集合可以存储多条数据。跟数组和元组不同，集合的数据存储在 heap 上，这意味着它存储的数据可以不用在编译阶段确定大小和内容，可以在运行时自由操作。这里介绍使用频率最高的三种集合类型：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Vector&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;String&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;HashMap&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-vector&amp;quot;&amp;gt;Section 1 - Vector&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;首先介绍集合&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，vector 允许你在单个数据结构里存储多个值，这些值存储在内存中相邻的位置。Vector 只能存储相同类型的数据，当你有一个类型列表时 Vector 非常适用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-a-new-vector&amp;quot;&amp;gt;Creating a New Vector&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;Vec::new&amp;lt;&amp;#x2F;code&amp;gt;方法新建一个 vector。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v:Vec&amp;amp;lt;i32&amp;amp;gt; = Vec::new();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Vector 是基于泛型实现的，创建 vector 时如果没有初始化值，则需要指定类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在一些应用场景中，Rust 可以根据指定的初始化值推断 vector 的类型，所以一半很少通过类型变量指定类型。创建 vector 时进行初始化是比较常见的方式，Rust 提供了&amp;lt;code&amp;gt;vec!&amp;lt;&amp;#x2F;code&amp;gt;宏来初始化并创建 vector。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v = vec![1, 2, 3];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;由于我们使用&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的数据初始化 vector，因此 Rust 可以推断出这个 vector 是&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;updating-a-vector&amp;quot;&amp;gt;Updating a Vector&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;push&amp;lt;&amp;#x2F;code&amp;gt;方法在 vector 实例上追加数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;vector 类型的变量要更改时也需要使用&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字声明。由于 push 的数据都是&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的，因此 Rust 将此类型推断为 vector 的类型，因此可以不用指定其类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;dropping-a-vector-drops-its-elements&amp;quot;&amp;gt;Dropping a Vector Drops Its Elements&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;跟其他结构体一样，vector 所在的上下文结束时，它将被释放（没有发生所有权转移）。当 vector 被释放时，它内部的数据也将被删除。这听起来似乎简单合理，但是当开始引用 vector 内的数据时，情况将变得复杂。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;reading-elements-of-vectors&amp;quot;&amp;gt;Reading Elements of Vectors&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;有两种方式引用 vector 中存储的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt; let v = vec![1, 2, 3, 4, 5];

let third: &amp;amp;amp;i32 = &amp;amp;amp;v[2];
println!(&amp;amp;quot;The third element is {}&amp;amp;quot;, third);

match v.get(2) {
    Some(third) =&amp;amp;gt; println!(&amp;amp;quot;The third element is {}&amp;amp;quot;, third),
    None =&amp;amp;gt; println!(&amp;amp;quot;There is no third element.&amp;amp;quot;),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一种方式通过&amp;lt;code&amp;gt;&amp;amp;amp;[]&amp;lt;&amp;#x2F;code&amp;gt;返回一个引用，然后使用下标访问 vector 中的数据，下标从 0 开始，与数组类似。第二种方式通过 vector 实例上的&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法，它返回一个&amp;lt;code&amp;gt;Option&amp;amp;lt;&amp;amp;amp;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;由于有两种访问方式，所以当发生越界访问时，需要针对不同的访问方式做不同的处理。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v = vec![1, 2, 3];

let num = &amp;amp;amp;v[100];

let num = v.get(100);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一种访问方式会导致程序报错，当你希望发生越界时程序终止运行，可以使用这种方式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当使用&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法时，如果发生越界访问，它会返回&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;，后续应当有处理&amp;lt;code&amp;gt;Some(&amp;amp;amp;i32)&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;的逻辑。这种方式相比程序终止，有更好的用户体验。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当创建了一个有效引用，borrow checker 会强制执行所有权和&amp;lt;a href=&amp;quot;&amp;#x2F;Rust&amp;#x2F;2-ownership.html#the-rules-of-references&amp;quot;&amp;gt;引用规则&amp;lt;&amp;#x2F;a&amp;gt;检查来确保当前引用和其他指向 vector 内容的引用也是有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;amp;amp;v[0];

v.push(6);

println!(&amp;amp;quot;The first element is: {}&amp;amp;quot;, first);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个代码在编译阶段会报错，因为在同一个上下文环境中，对同一个数据存在 immutable 引用时，不能有 mubable 类型的引用。这段代码看上去应该是可以运行的，为什么对 vector 头部的引用和 vector 尾部的 push 操作会发生冲突呢？因为追加数据时有可能存在当前内存不足，在 heap 上重新分配内存，而此时旧的引用还指向之前被释放的内存，此时不符合引用规则中所有引用都必须有效的那一条，因此编译器会直接报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;iterating-over-the-values-in-a-vector&amp;quot;&amp;gt;Iterating over the Values in a Vector&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环遍历 vector，获取内部每一条数据的一个 immutable 引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v = vec![1, 2, 3];

for &amp;amp;amp;i in &amp;amp;amp;v {
    println!(&amp;amp;quot;{}&amp;amp;quot;, i);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;也可以通过遍历 mutable 引用来修改 vector 中的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut v = vec![1, 2 ,3];
for &amp;amp;amp;i in &amp;amp;amp;mut v {
    i *= 2;
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;using-an-enum-to-store-multiple-types&amp;quot;&amp;gt;Using an Enum to Store Multiple Types&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前说过 vector 只能存储相同类型的数据，这个限制很不方便，因为有很多的场景需要存储不同类型的数据列表。我们可以通过定义枚举来满足这种场景需求。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;比如我们需要读取一个电子表格的一行数据，其类型可能是数字、字符串等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&amp;amp;quot;blue&amp;amp;quot;)),
    SpreadsheetCell::Float(10.12),
];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 在编译阶段需要知道 vector 存储何种数据类型，方便在 heap 上分配每个元素所需要的内存大小。第二个好处是可以明确指定这个 vector 存储的是何种类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在编写过程中，如果你不能确定枚举下的所有类型，这种方式则不适用。此时可以用 trait 对象作为替代，后面的章节中会介绍到 trait 对象。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-string&amp;quot;&amp;gt;Section 2 - String&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;许多 Rust 新手对 String 会在理解上有一些吃力，基于一下三个可能的原因：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Rust 倾向于抛出任何可能的错误。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;String 是一个比许多程序员所理解的更加复杂的数据类型。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;UTF8。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;将 String 放在集合这一章讨论，是由于 String 类型是基于字节的集合实现的，并且添加了一些实用功能，这些字节在 String 类型中会被解析为文本。下面会讨论 String 类型和其他集合类型的相同之处，如 creating，updating，reading 等操作。还将讨论 String 和其他集合类型的不同之处——Stirng 类型上操作的复杂化，由于人和机器对文本的解释方式不同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;what-is-a-string&amp;quot;&amp;gt;What Is a String?&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;首先定义一下&amp;lt;em&amp;gt;string&amp;lt;&amp;#x2F;em&amp;gt;的含义。Rust 语言核心中只有一种字符串类型，即字符串切片&amp;lt;code&amp;gt;str&amp;lt;&amp;#x2F;code&amp;gt;。之前介绍过字符串切片，是对一些 utf8 编码数据的引用。保存在可执行文件中的字符串字面量也是&amp;lt;code&amp;gt;str&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;而&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型，是由 Rust 标准库提供而非写在 Rust 语言核心中，是一种可扩展、可修改、utf8 编码的字符串类型。当在 Rust 中提到字符串类型时，一般指的是这两种类型而非其中一种。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-a-new-string&amp;quot;&amp;gt;Creating a New String&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型上的方法大多数都是和&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型相似的。比如新建方法&amp;lt;code&amp;gt;new&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::new();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里新建了一个空的字符串&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;，之后可以在它上面存储文本数据。但是通常在新建字符串时都会有初始化的值。可以使用&amp;lt;code&amp;gt;to_string&amp;lt;&amp;#x2F;code&amp;gt;方法将字面量或者&amp;lt;code&amp;gt;str&amp;lt;&amp;#x2F;code&amp;gt;数据转换成&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型。也可以使用&amp;lt;code&amp;gt;String::from&amp;lt;&amp;#x2F;code&amp;gt;方法来创建，跟&amp;lt;code&amp;gt;to_string&amp;lt;&amp;#x2F;code&amp;gt;方法效果是一样的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let data = &amp;amp;quot;initial data&amp;amp;quot;;

let s = data.to_string();
let s = &amp;amp;quot;initial data&amp;amp;quot;.to_string();

let s = String::from(&amp;amp;quot;initial data&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型是 utf8 编码的，因此它可以存储任何 utf8 编码范围内的文本数据，以下都是有效的字符串数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let hello = String::from(&amp;amp;quot;السلام عليكم&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Dobrý den&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Hello&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;שָׁלוֹם&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;नमस्ते&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;こんにちは&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;안녕하세요&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;你好&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Olá&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Здравствуйте&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Hola&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;updating-a-string&amp;quot;&amp;gt;Updating a String&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型大小、内容都可以改变，可以像&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;一样用 push 的方式追加数据。此外，也可以通过&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符或者&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏来进行字符串拼接。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;appending-to-a-string-with-push-str-and-push&amp;quot;&amp;gt;Appending to a String with &amp;lt;code&amp;gt;push_str&amp;lt;&amp;#x2F;code&amp;gt; and &amp;lt;code&amp;gt;push&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;push_str&amp;lt;&amp;#x2F;code&amp;gt;方法追加一个字符串切片。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;foo&amp;amp;quot;);

s.push_str(&amp;amp;quot;bar&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;push&amp;lt;&amp;#x2F;code&amp;gt;方法追加单个字符。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;s.push(&amp;amp;#x27;a&amp;amp;#x27;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;concatenation-with-the-operator-or-the-format-macro&amp;quot;&amp;gt;Concatenation with the + Operator or the format! Macro&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符拼接字符串&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;Hello, &amp;amp;quot;);
let s2 = String::from(&amp;amp;quot;world!&amp;amp;quot;);
let s3 = s1 + &amp;amp;amp;s2; &amp;amp;#x2F;&amp;amp;#x2F; 这里s1的所有权发生了转移
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;加运算执行完毕后&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;不再有效的原因，和为什么要使用&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;的引用进行加运算的原因，在于执行&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算时所调用的方法。该方法的声明类似于：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn add(self, s: &amp;amp;amp;str) -&amp;amp;gt; String
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;标准库中的&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法是通过泛型声明的。这里我们使用&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型作为说明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;首先&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;变量之前有&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;修饰符，说明这里是一个&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;的引用。由于&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法的声明，只能将一个第二个字符串的引用作为参数和第一个字符串做合并。也不能合并两个&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型的数据。但是，&amp;lt;code&amp;gt;&amp;amp;amp;s2&amp;lt;&amp;#x2F;code&amp;gt;是一个&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;类型而非&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型，为什么编译器没有报错？&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因为编译器可以将&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;类型*coerce（强转换）*为&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型。调用&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法时，Rust 进行了 deref coercion（隐式强转换），在这个例子中，&amp;lt;code&amp;gt;&amp;amp;amp;s2&amp;lt;&amp;#x2F;code&amp;gt;将返回&amp;lt;code&amp;gt;&amp;amp;amp;s2[..]&amp;lt;&amp;#x2F;code&amp;gt;。由于&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法没有获取参数&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的所有权，因此&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;变量在计算之后依然是有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;其次，&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法获取了&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;的所有权。这意味着&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;变量在进行计算之后不再有效。&amp;lt;code&amp;gt;s3 = s1 + &amp;amp;amp;s2;&amp;lt;&amp;#x2F;code&amp;gt;看起来是进行了值的复制和拼接，并且创建了新的变量。实际上是对&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;进行内容追加后转移了的所有权。看似进行了许多复制和变量的新建，实际上要比这更有效率。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;而在多个字符串进行拼接时，&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符看起来会比较啰嗦。此时使用&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏代替是比较好的方案。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;tic&amp;amp;quot;);
let s2 = String::from(&amp;amp;quot;tac&amp;amp;quot;);
let s3 = String::from(&amp;amp;quot;toe&amp;amp;quot;);

let s = format!(&amp;amp;quot;{}-{}-{}&amp;amp;quot;, s1, s2, s3);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏的方法比&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符可读性更好，并且它不会获取任何参数的所有权。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;indexing-into-strings&amp;quot;&amp;gt;Indexing into Strings&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在其他语言中，使用索引访问字符串中的某个字符是常见的操作。但是在 Rust 中会报错，Rust 不支持数字索引，要解释这个问题，需要讨论 Rust 如何在内存中存储 String 数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;internal-representation&amp;quot;&amp;gt;Internal Representation&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型是对&amp;lt;code&amp;gt;Vec&amp;amp;lt;u8&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的一层封装。来看一些 utf8 编码的字符串示例&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hola&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在这个示例中，&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的长度是 4，意思是 vector 存储的“hola”有 4 字节长，每个字母占 1 字节。但是在其他字符数据的情况下呢？&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let hello = &amp;amp;quot;Здравствуйте&amp;amp;quot;;
&amp;amp;#x2F;&amp;amp;#x2F; 注意这是西里尔字母З，而不是阿拉伯数字3
let answer = &amp;amp;amp;hello[0];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子中，&amp;lt;code&amp;gt;answer&amp;lt;&amp;#x2F;code&amp;gt;会是&amp;lt;code&amp;gt;З&amp;lt;&amp;#x2F;code&amp;gt;吗？在 utf8 编码中，3 的第一个字节是&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;，第二个字节是&amp;lt;code&amp;gt;151&amp;lt;&amp;#x2F;code&amp;gt;，所以&amp;lt;code&amp;gt;answer&amp;lt;&amp;#x2F;code&amp;gt;的值是&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;，而&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;不是一个有效字符。这跟用户期望返回第一个字符不一致，但 Rust 在 0 索引处存储的值就是&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;的 16 进制。用户通常不希望获得字节类型的数据，哪怕字符串全部是由拉丁字母组成的。如果&amp;lt;code&amp;gt;&amp;amp;amp;&amp;quot;hello&amp;quot;[0]&amp;lt;&amp;#x2F;code&amp;gt;是一个合法的索引，那么它也只会返回&amp;lt;code&amp;gt;104&amp;lt;&amp;#x2F;code&amp;gt;而不是&amp;lt;code&amp;gt;h&amp;lt;&amp;#x2F;code&amp;gt;。因此，Rust 不允许使用索引访问字符串中的字符，在编译阶段就抛出错误，以免在开发阶段对代码的执行产生误解。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;bytes-and-scalar-values-and-grapheme-clusters&amp;quot;&amp;gt;Bytes and Scalar Values and Grapheme Clusters&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;从 Rust 的视角来看，有三种相关的方式查看 String 中的数据：&amp;lt;em&amp;gt;Bytes（可执行）&amp;lt;&amp;#x2F;em&amp;gt;，&amp;lt;em&amp;gt;scalar values（标量）&amp;lt;&amp;#x2F;em&amp;gt;，&amp;lt;em&amp;gt;grapheme clusters（词组）&amp;lt;&amp;#x2F;em&amp;gt;（最接近人类字符的概念）。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;用梵文写的印地语“नमस्ते“，在&amp;lt;code&amp;gt;Vec&amp;amp;lt;u8&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;中存储的数据是&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;这 18 个 16 进制数据就是计算机最终存储的数据。如果从 unicode 标量的角度看，也是 Rust 中的&amp;lt;code&amp;gt;char&amp;lt;&amp;#x2F;code&amp;gt;类型。这些字节串可以看作&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;[&amp;#x27;न&amp;#x27;, &amp;#x27;म&amp;#x27;, &amp;#x27;स&amp;#x27;, &amp;#x27;्&amp;#x27;, &amp;#x27;त&amp;#x27;, &amp;#x27;े&amp;#x27;]&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;其中有 6 个 char 字符，其中第四个和第六个是变音符号，不具备表意功能。最后，如果从词组的角度看，就可以得到一个人类阅读友好的组成单词的四个字母。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;[&amp;quot;न&amp;quot;, &amp;quot;म&amp;quot;, &amp;quot;स्&amp;quot;, &amp;quot;ते&amp;quot;]&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;Rust 提供了多种方式来解释计算机存储的原始字符数据，满足不同程序的数据需求，而不用关心具体使用的是哪种人类语言。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 不允许使用索引访问字符串数据的最后一个原因是，索引操作要求数据量不会影响读取的时间复杂度（O(1)）。但是这在 String 类型的性能上是不能够保证的，因为 Rust 需要从头遍历到索引位置处，找出其中有效的字符。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;slicing-strings&amp;quot;&amp;gt;Slicing Strings&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;索引访问 String 不是一个好的方案，原因还在于索引访问的返回值不清晰，是应该返回可执行数据，还是字符，还是词组，还是字符串切片呢？因此，Rust 需要编码者在使用索引创建字符串切片时更加准确的定义返回值。为了更具体的索引，请使用&amp;lt;code&amp;gt;[]&amp;lt;&amp;#x2F;code&amp;gt;和范围语法创建字符串切片，而不是在&amp;lt;code&amp;gt;[]&amp;lt;&amp;#x2F;code&amp;gt;中使用单个数字。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let hello = &amp;amp;quot;Здравствуйте&amp;amp;quot;;

let s = &amp;amp;amp;hello[0..4];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;是一个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;，由于每个西里尔字符使用 2 字节编码，因此&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的值应该是 Зд。如果把&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;变量改成&amp;lt;code&amp;gt;&amp;amp;amp;hello[0..3]&amp;lt;&amp;#x2F;code&amp;gt;，程序会在运行时崩溃——当前索引不在正确的字符边界处。在使用 range 创建字符串切片时需要小心，因为有可能会让程序崩溃。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;methods-for-iterating-over-strings&amp;quot;&amp;gt;Methods for Iterating Over Strings&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果需要在每个单独的 unicode 字符标量上执行某些操作，可以通过 String 的&amp;lt;code&amp;gt;chars&amp;lt;&amp;#x2F;code&amp;gt;方法来遍历每个字符标量，它返回的是&amp;lt;code&amp;gt;char&amp;lt;&amp;#x2F;code&amp;gt;类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;for c in &amp;amp;quot;नमस्ते&amp;amp;quot;.chars() {
    println!(&amp;amp;quot;{}&amp;amp;quot;, c);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;bytes&amp;lt;&amp;#x2F;code&amp;gt;方法返回原始的字节数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;for b in &amp;amp;quot;नमस्ते&amp;amp;quot;.bytes() {
    println!(&amp;amp;quot;{}&amp;amp;quot;, b);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;请记住有效的 unicode 字符标量是有 1 个或以上的字节所组成的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;由于返回词组的方法比较复杂，因此标准库并没有提供相关功能。有需要可以上&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;查看。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;strings-are-not-so-simple&amp;quot;&amp;gt;Strings Are Not So Simple&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 将正确的处理字符串数据作为所有程序的默认行为，因此编码者需要在前期投入精力去思考如何正确的处理 utf8 数据。代价则是相比其他编程语言，Rust 暴露了更多的复杂性给编码者，但同时能够让你避免类似于非 ASCII 字符的错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-hashmap&amp;quot;&amp;gt;Section 3 - HashMap&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;最后一个要介绍的常见集合是&amp;lt;em&amp;gt;hash map&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;code&amp;gt;HashMap&amp;amp;lt;K, V&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型存储的是&amp;lt;code&amp;gt;K&amp;lt;&amp;#x2F;code&amp;gt;类型与&amp;lt;code&amp;gt;V&amp;lt;&amp;#x2F;code&amp;gt;类型之间的键值对映射关系。通过&amp;lt;em&amp;gt;hashing function&amp;lt;&amp;#x2F;em&amp;gt;来实现，这个函数确定了键和值如何在内存中存储。这个功能很多编程语言都提供了，只不过叫法有差异，比如哈希表、对象、map、字典等等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当你想通过非数字索引的方式查看数据时，哈希表是很实用的，它使用的是任意数据类型的键来检索数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们仅列举一些常用的 API，在标准库&amp;lt;code&amp;gt;HashMap&amp;amp;lt;K, V&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;中定义了许多实用的方法，具体查阅标准库文档。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-a-new-hash-map&amp;quot;&amp;gt;Creating a New Hash Map&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;new&amp;lt;&amp;#x2F;code&amp;gt;方法新建，&amp;lt;code&amp;gt;insert&amp;lt;&amp;#x2F;code&amp;gt;方法插入数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::colloctions::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Yellow&amp;amp;quot;), 50);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;首先需要引入&amp;lt;code&amp;gt;HashMap&amp;lt;&amp;#x2F;code&amp;gt;模块。在介绍的三种集合中，HashMap 是使用频率最低的，因此它没有被默认包含到上下文中。标准库对 HashMap 的支持也很少，比如没有宏来构建 HashMap。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;跟 vectors 一样，哈希表的数据存储在 heap 上。上面的代码定义了一个键为&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型，值为&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的哈希表。哈市表跟 vector 一样是同质的，即键是同一种数据类型，值也是同一种数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;另外一种创建哈希表的方式是通过迭代器和元组组成的 vector 上的&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法，其中每个元组包含哈希表的键和值。&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法将数据收集到多种集合类型中，包括哈希表。&amp;lt;code&amp;gt;zip&amp;lt;&amp;#x2F;code&amp;gt;方法可以用来创建元组组成的 vector。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let teams = vec![String::from(&amp;amp;quot;Blue&amp;amp;quot;), String::from(&amp;amp;quot;Yellow&amp;amp;quot;)];
let initial_scores = vec![10, 50];

let mut scores: HashMap&amp;amp;lt;_, _&amp;amp;gt; =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;类型声明&amp;lt;code&amp;gt;HashMap&amp;amp;lt;_, _&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;是必须的，因为&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法会把数据收集到许多种集合中，除非你指定，否则 Rust 不知道你需要的是哪一种。键和值的类型参数使用下划线占位，此时 Rust 可以通过返回值来推断键和值的类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;hash-maps-and-ownership&amp;quot;&amp;gt;Hash Maps and Ownership&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;对于实现了&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型来说，比如&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;，值是拷贝进哈希表的。对于 owned 的数据类型来说，比如&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;，所有权会被转移到哈希表上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let field_name = String::from(&amp;amp;quot;Favorite color&amp;amp;quot;);
let field_value = String::from(&amp;amp;quot;Blue&amp;amp;quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0382]: borrow of moved value: `field_name`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在这个例子中，当&amp;lt;code&amp;gt;field_name&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;field_value&amp;lt;&amp;#x2F;code&amp;gt;被添加到 map 之后，我们是不能使用这个值的，因为所有权被传递到了 map 中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果我们使用引用插入到哈希表中，那么所有权将不会被移动到哈希表中。但是，此时需要保证引用的有效时间至少要和哈希表一致。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;accessing-values-in-a-hash-map&amp;quot;&amp;gt;Accessing Values in a Hash Map&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法获取哈希表的值。&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法返回&amp;lt;code&amp;gt;Option&amp;amp;lt;&amp;amp;amp;V&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collection::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Yellow&amp;amp;quot;), 50);

let team_name = String::from(&amp;amp;quot;Blue&amp;amp;quot;);
let score = scores.get(&amp;amp;amp;team_name);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环遍历键值对&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Yellow&amp;amp;quot;), 50);

for (key, value) in &amp;amp;amp;scores {
    println!(&amp;amp;quot;{}: {}&amp;amp;quot;, key, value);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;updating-a-hash-map&amp;quot;&amp;gt;Updating a Hash Map&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;键值对的数量是可以增加的，但是每个键只能关联到一个值。当你需要修改哈希表的值时，需要考虑到值已经关联了值的情况，覆盖、舍弃还是合并。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;overwriting-a-value&amp;quot;&amp;gt;Overwriting a Value&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;如果在插入值之后，重新对同一个键进行了插值，那么新值会将旧值覆盖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 25);

println!(&amp;amp;quot;{:?}&amp;amp;quot;, scores);
&amp;amp;#x2F;&amp;amp;#x2F; 25
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;only-inserting-a-value-if-the-key-has-no-value&amp;quot;&amp;gt;Only Inserting a Value If the Key Has No Value&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;检查键是否关联了值，如果没有就给他它关联一个新值，这是很常见的逻辑。哈希表对这种情况提供了一个特殊的 API&amp;lt;code&amp;gt;entry&amp;lt;&amp;#x2F;code&amp;gt;，它的参数是你需要检查的键，返回一个&amp;lt;code&amp;gt;Entry&amp;lt;&amp;#x2F;code&amp;gt;枚举，代表一个值是否存在。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);

scores.entry(String::from(&amp;amp;quot;Yellow&amp;amp;quot;)).or_insert(50);
scores.entry(String::from(&amp;amp;quot;Blue&amp;amp;quot;)).or_insert(50);

println!(&amp;amp;quot;{:?}&amp;amp;quot;, scores);
&amp;amp;#x2F;&amp;amp;#x2F; {&amp;amp;quot;Yellow&amp;amp;quot;: 50, &amp;amp;quot;Blue&amp;amp;quot;: 10}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;or_insert&amp;lt;&amp;#x2F;code&amp;gt;方法当键存在时，返回一个该键值的可变引用。如果不存在，则把参数当作值插入到哈希表中然后返回一个可变引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;updating-a-value-based-on-the-old-value&amp;quot;&amp;gt;Updating a Value Based on the Old Value&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;另一种常见场景是使用旧值更新哈希表的新值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let text = &amp;amp;quot;hello world wonderful world&amp;amp;quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&amp;amp;quot;{:?}&amp;amp;quot;, map);
&amp;amp;#x2F;&amp;amp;#x2F; {&amp;amp;quot;world&amp;amp;quot;: 2, &amp;amp;quot;hello&amp;amp;quot;: 1, &amp;amp;quot;wonderful&amp;amp;quot;: 1}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;hashing-functions&amp;quot;&amp;gt;Hashing Functions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;HashMap&amp;lt;&amp;#x2F;code&amp;gt;默认使用*&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;www.131002.net&amp;#x2F;siphash&amp;#x2F;siphash.pdf&amp;quot;&amp;gt;cryptographically strong&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;em&amp;gt;散列函数。它对 DoS 攻击有很好对抵抗性。这个算法不是最快的，但是从安全性的角度考虑，舍弃这点性能是值得的。如果你想自己指定散列函数，你可以指定一个&amp;lt;&amp;#x2F;em&amp;gt;hasher*来自己切换散列函数。hasher 是一个实现了&amp;lt;code&amp;gt;BuildHasher&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Error Handling</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;07-error-handling&#x2F;"/>
            <updated>2021-02-20T01:17:20+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;07-error-handling&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-7-error-handling&amp;quot;&amp;gt;Chapter 7 - Error Handling&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Rust 的可靠性之一就在于它的错误处理。在很多情况下，Rust 要求你在代码编译之前对所有可能的错误情况进行处理。在部署到生产环境之前确保发现并处理错误，这让你的代码健壮性更强。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 将错误分为两个大类：&amp;lt;em&amp;gt;recoverable&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;unrecoverable&amp;lt;&amp;#x2F;em&amp;gt;。前者例如读取不存在的文件，将该错误上报并且重试这个操作是合理的行为。后者一半是由于代码逻辑 bug，例如数组越界访问。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;大多数语言不会对这两个大类进行区分，一般都是采用同一套解决方式，例如异常机制。Rust 没有异常机制，Rust 用&amp;lt;code&amp;gt;Result&amp;amp;lt;U,E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;处理 recoverable 类型的错误，用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏处理 unrecoverable 类型的错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-unrecoverable-errors-with-panic&amp;quot;&amp;gt;Section 1 - Unrecoverable Errors with panic!&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;当出现一些意料之外的错误，并且没有后续的处理逻辑或者不知道该如何处理时，Rust 有&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏。当&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏调用时，打印出错误信息，然后释放清空堆栈内存退出程序。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;:::details Unwinding the Stack or Aborting in Response to a Panic
一般来说，当 panic 发生后，Rust 会进入&amp;lt;em&amp;gt;unwinding&amp;lt;&amp;#x2F;em&amp;gt;阶段，它需要到堆栈顶部，开始遍历堆栈清空数据和函数，这是一个很费时的操作。另一种方案是&amp;lt;em&amp;gt;abort&amp;lt;&amp;#x2F;em&amp;gt;，即程序退出时 Rust 不会清空堆栈，而将这个操作交给操作系统。如果你需要你的项目编译结果尽可能小，你可以通过设置&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件来让你的程序为 abort 模式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;[profile.release]
panic = &amp;amp;#x27;abort&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面简单调用一下&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏来看一看它的输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    panic!(&amp;amp;quot;crash&amp;amp;quot;);
}
&amp;amp;#x2F;&amp;amp;#x2F; thread &amp;amp;#x27;main&amp;amp;#x27; panicked at &amp;amp;#x27;crash&amp;amp;#x27;, src&amp;amp;#x2F;main.rs:17:9
&amp;amp;#x2F;&amp;amp;#x2F; note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;输出了两行信息，第一行是错误信息和错误在源代码在文件中的位置。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在这个例子中，我们可以跟踪代码在对应的位置找到导致&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏调用的代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;using-a-panic-backtrace&amp;quot;&amp;gt;Using a &amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt; Backtrace&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以设置&amp;lt;code&amp;gt;RUST_BACKTRACE&amp;lt;&amp;#x2F;code&amp;gt;环境变量来获取发生错误的完整调用链路。它是一个函数的调用堆栈列表，从栈顶开始一直到我们自己的代码文件。这个链路中可能包含核心文件、标准库文件、其他你使用到的第三方模块代码。你所在文件那一行上面的内容是你的代码调用的文件，下面的内容是调用你代码的文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;stack backtrace:
    0: backtrace::backtrace::libunwind::trace
                at &amp;amp;#x2F;Users&amp;amp;#x2F;runner&amp;amp;#x2F;.cargo&amp;amp;#x2F;registry&amp;amp;#x2F;src&amp;amp;#x2F;github.com-1ecc6299db9ec823&amp;amp;#x2F;backtrace-0.3.46&amp;amp;#x2F;src&amp;amp;#x2F;backtrace&amp;amp;#x2F;libunwind.rs:86
    1: backtrace::backtrace::trace_unsynchronized
                at &amp;amp;#x2F;Users&amp;amp;#x2F;runner&amp;amp;#x2F;.cargo&amp;amp;#x2F;registry&amp;amp;#x2F;src&amp;amp;#x2F;github.com-1ecc6299db9ec823&amp;amp;#x2F;backtrace-0.3.46&amp;amp;#x2F;src&amp;amp;#x2F;backtrace&amp;amp;#x2F;mod.rs:66
    2: std::sys_common::backtrace::_print_fmt
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:78
    3: &amp;amp;lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&amp;amp;gt;::fmt
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:59
    4: core::fmt::write
                at src&amp;amp;#x2F;libcore&amp;amp;#x2F;fmt&amp;amp;#x2F;mod.rs:1076
    5: std::io::Write::write_fmt
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;io&amp;amp;#x2F;mod.rs:1537
    6: std::sys_common::backtrace::_print
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:62
    7: std::sys_common::backtrace::print
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:49
    8: std::panicking::default_hook::{{closure}}
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:198
    9: std::panicking::default_hook
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:218
    10: std::panicking::rust_panic_with_hook
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:486
    11: rust_begin_unwind
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:388
    12: core::panicking::panic_fmt
                at src&amp;amp;#x2F;libcore&amp;amp;#x2F;panicking.rs:101
    13: core::panicking::panic_bounds_check
                at src&amp;amp;#x2F;libcore&amp;amp;#x2F;panicking.rs:73
    14: &amp;amp;lt;usize as core::slice::SliceIndex&amp;amp;lt;[T]&amp;amp;gt;&amp;amp;gt;::index
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libcore&amp;amp;#x2F;slice&amp;amp;#x2F;mod.rs:2872
    15: core::slice::&amp;amp;lt;impl core::ops::index::Index&amp;amp;lt;I&amp;amp;gt; for [T]&amp;amp;gt;::index
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libcore&amp;amp;#x2F;slice&amp;amp;#x2F;mod.rs:2732
    16: &amp;amp;lt;alloc::vec::Vec&amp;amp;lt;T&amp;amp;gt; as core::ops::index::Index&amp;amp;lt;I&amp;amp;gt;&amp;amp;gt;::index
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;liballoc&amp;amp;#x2F;vec.rs:1942
    17: p::main
                at src&amp;amp;#x2F;main.rs:5
    18: std::rt::lang_start::{{closure}}
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:67
    19: std::rt::lang_start_internal::{{closure}}
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:52
    20: std::panicking::try::do_call
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:297
    21: std::panicking::try
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:274
    22: std::panic::catch_unwind
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panic.rs:394
    23: std::rt::lang_start_internal
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:51
    24: std::rt::lang_start
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:67
    25: main
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;为了获取这个输出，debug 标识必须是 enable 的，在运行&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;的并且不带&amp;lt;code&amp;gt;--release&amp;lt;&amp;#x2F;code&amp;gt;选项的时候，该标识默认是 enable 的。具体的输出内容和你的操作系统以及 Rust 版本有关。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-recoverable-errors-with-result&amp;quot;&amp;gt;Section 2 - Recoverable Errors with &amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;大多数错误抛出的时候，都没有必要将程序退出。比如，当读取的文件不存在时，可以考虑创建该文件而不是终止进程。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;枚举有两个值，&amp;lt;code&amp;gt;Ok&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Err&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Result&amp;amp;lt;T, E&amp;amp;gt; {
    Ok(T),
    Err(E),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;T 和 E 是泛型变量。T 代表成功情况下返回值的类型，E 代表失败情况下错误的返回类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如何知道&amp;lt;code&amp;gt;File::open&amp;lt;&amp;#x2F;code&amp;gt;函数返回的是一个&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;枚举呢？一种方式是查看标准库 API 文档，另外一种方式是给变量&amp;lt;code&amp;gt;f&amp;lt;&amp;#x2F;code&amp;gt;指定一个其他的数据类型。然后编译代码，编译器会给出类型不匹配的错误信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这里泛型变量&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;会被填充为成功值的类型，在这里是一个&amp;lt;code&amp;gt;std::fs::File&amp;lt;&amp;#x2F;code&amp;gt;类型的文件句柄，&amp;lt;code&amp;gt;E&amp;lt;&amp;#x2F;code&amp;gt;则是&amp;lt;code&amp;gt;std::io::Error&amp;lt;&amp;#x2F;code&amp;gt;类型。这意味着&amp;lt;code&amp;gt;File::open&amp;lt;&amp;#x2F;code&amp;gt;函数可能会返回一个文件句柄，可以用来进行读写。或者可能返回一个 io 错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因此我们需要用&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式对&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;的所有情况进行覆盖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);

    let f = match f {
        Ok(file) =&amp;amp;gt; file,
        Err(error) =&amp;amp;gt; panic!(&amp;amp;quot;Problem opening the file: {:?}&amp;amp;quot;, error),
    };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;matching-on-different-errors&amp;quot;&amp;gt;Matching on Different Errors&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;上面的代码，当打开文件出错时，不论何种错误都会调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏然后退出程序。而我们的期望时根据不同的错误类型，有不同的处理方案。比如因为文件不存在，我们希望创建文件；如果是因为没有权限，则调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏退出程序。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);

    let f = match f {
        Ok(file) =&amp;amp;gt; file,
        Err(error) =&amp;amp;gt; match error.kind() {
            ErrorKind::NotFound =&amp;amp;gt; match File::create(&amp;amp;quot;hello.txt&amp;amp;quot;) {
                Ok(fc) =&amp;amp;gt; fc,
                Err(e) =&amp;amp;gt; panic!(&amp;amp;quot;Problem creating the file: {:?}&amp;amp;quot;, e),
            },
            other_error =&amp;amp;gt; {
                panic!(&amp;amp;quot;Problem opening the file: {:?}&amp;amp;quot;, other_error)
            }
        },
    };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;File::open&amp;lt;&amp;#x2F;code&amp;gt;函数返回的是一个标准库提供的&amp;lt;code&amp;gt;io::Error&amp;lt;&amp;#x2F;code&amp;gt;类型的错误。这个类型上有一个&amp;lt;code&amp;gt;kind&amp;lt;&amp;#x2F;code&amp;gt;方法用来获取&amp;lt;code&amp;gt;io::ErrorKind&amp;lt;&amp;#x2F;code&amp;gt;类型的值。这个类型也由标准库提供，枚举了一些 io 操作可能出现的错误类型。我们想要在&amp;lt;code&amp;gt;ErrorKind::NotFound&amp;lt;&amp;#x2F;code&amp;gt;错误类型出现时，创建一个新文件。由于&amp;lt;code&amp;gt;File::create&amp;lt;&amp;#x2F;code&amp;gt;方法也有可能失败，所以也需要用&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式覆盖可能出现的情况。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;但是这里出现了太多的&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式嵌套。后面会介绍*闭包（closure）*的用法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shortcuts-for-panic-on-error-unwrap-and-expect&amp;quot;&amp;gt;Shortcuts for Panic on Error: &amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt; and &amp;lt;code&amp;gt;expect&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式能够满足需求。但是太多的&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;显得太啰嗦，表意也不够清晰。&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上有许多工具函数，其中一个叫做&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;的函数可以作为&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式的语法糖使用。如果是成功状态，&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;方法会返回值；如果是失败状态，&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;会调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;).unwrap();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;另外一个&amp;lt;code&amp;gt;expect&amp;lt;&amp;#x2F;code&amp;gt;方法，作用和&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;一样，但是可以让我们指定错误输出信息。可以表达我们想表达的错误信息，在错误追踪时也比较容易。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;).expect(&amp;amp;quot;Failed to open hello.txt&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;propagating-errors&amp;quot;&amp;gt;Propagating Errors&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当你实现一个函数时，它的实现可能会抛出某些错误，与其在你的函数中捕获这个错误，不如把这个错误传递给调用者，好让调用者决定如何处理这个错误。这个被称为错误的&amp;lt;em&amp;gt;传递（propgation）&amp;lt;&amp;#x2F;em&amp;gt;，这给了调用者更多的控制权，它内部也许有更完善的信息和逻辑来处理错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;例如，我们要写一个函数，在一个文件中读取一些内容，如果读取错误，将这个错误抛给调用者。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&amp;amp;gt; Result&amp;amp;lt;String, io::Error&amp;amp;gt; {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);

    let mut f = match f {
        Ok(file) =&amp;amp;gt; file,
        Err(e) =&amp;amp;gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;amp;amp;mut s) {
        Ok(_) =&amp;amp;gt; Ok(s),
        Err(e) =&amp;amp;gt; Err(e),
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;a-shortcut-for-propagating-errors-the-operator&amp;quot;&amp;gt;A Shortcut for Propagating Errors: the ? Operator&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&amp;amp;gt; Result&amp;amp;lt;String, io::Error&amp;amp;gt; {
    let mut f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;amp;amp;mut s)?;
    Ok(s)
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符跟在&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型之后，当&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;值是&amp;lt;code&amp;gt;Ok&amp;lt;&amp;#x2F;code&amp;gt;时，它的值会作为表达式的值返回；当值是&amp;lt;code&amp;gt;Err&amp;lt;&amp;#x2F;code&amp;gt;时，会将这个错误作为整个函数的返回值抛出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式和&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符还有一点不同：&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符抛出的错误会经过一个由标准库&amp;lt;code&amp;gt;From&amp;lt;&amp;#x2F;code&amp;gt;trait 提供的，名称为&amp;lt;code&amp;gt;from&amp;lt;&amp;#x2F;code&amp;gt;的函数处理，它将原始的错误类型转换成我们当前函数声明中定义的错误类型。只要错误类型实现了&amp;lt;code&amp;gt;from&amp;lt;&amp;#x2F;code&amp;gt;方法，&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符就会调用它来进行错误类型转换。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符使函数体更加简洁，上面这个例子还可以更加简洁。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&amp;amp;gt; Result&amp;amp;lt;String, io::Error&amp;amp;gt; {
    let mut s = String::new();
    File::open(&amp;amp;quot;hello.txt&amp;amp;quot;)?.read_to_string(&amp;amp;amp;mut s)?;
    Ok(s)
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Packages, Crates and Modules</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;05-packages-and-modules&#x2F;"/>
            <updated>2021-01-15T13:42:49+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;05-packages-and-modules&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-5-managing-growing-projects-with-packages-crates-and-modules&amp;quot;&amp;gt;Chapter 5 - Managing Growing Projects with Packages, Crates, and Modules&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;当项目体积越来越大，良好的代码组织就变得很重要。因为只靠脑子记忆整个项目的代码逻辑是不可能的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;目前为止所写的一些示例程序都是一个模块一个文件下的。当项目体积增长，就可以将代码分割到不同模块不同文件中。一个*package（包）*可以包含多个可执行 crate，并且可以选择性的包含一个库 crate。当包体积变大，可以通过提取代码成一个独立的 crate，将它转变为一个外部依赖。本章会涵盖所有这些技术。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;除了分组功能，封装逻辑实现代码可以让代码复用：当你封装了一个操作，其他地方的代码可以通过接口直接使用这个功能，而不需要知道内部具体是如何实现的。封装代码哪部分是公用接口，哪部分是私有属性，这取决于封装实现的编码人员。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;还有一个相关概念称之为&amp;lt;em&amp;gt;scope（域）&amp;lt;&amp;#x2F;em&amp;gt;：这是一个嵌套结构的上下文环境。当读写编译代码时，编码人员和编译器都需要知道特定位置的一些特定名称代表的是一个变量、函数、结构体、模块还是一些其他的东西。你可以创建一个 scope 并指定哪些内容在这个 scope 中。在同一个 scope 中不允许出现两个名称一致的实体。有一些工具可以解决命名冲突。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 模块系统包括：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Packages&amp;lt;&amp;#x2F;strong&amp;gt;：是 Cargo 的一个功能，可以用来创建、测试和发布 crate。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Crates&amp;lt;&amp;#x2F;strong&amp;gt;：一个导出可执行文件或者可执行文件的模块树。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Modules&amp;lt;&amp;#x2F;strong&amp;gt;和&amp;lt;strong&amp;gt;use&amp;lt;&amp;#x2F;strong&amp;gt;：用来控制&amp;lt;em&amp;gt;Paths&amp;lt;&amp;#x2F;em&amp;gt;的组织、域和隐私。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Paths&amp;lt;&amp;#x2F;strong&amp;gt;：命名实体的方式，例如给函数、结构体和模块命名。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;接下来会依次覆盖这些内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-packages-and-crates&amp;quot;&amp;gt;Section 1 - Packages and Crates&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;crate&amp;lt;&amp;#x2F;em&amp;gt;是一个可执行文件或者库。&amp;lt;em&amp;gt;crate root&amp;lt;&amp;#x2F;em&amp;gt;是编译器开始编译并把你的 crate 打包成根模块的源文件。&amp;lt;em&amp;gt;package&amp;lt;&amp;#x2F;em&amp;gt;是由一个或者多个提供了某些功能的 crate 组成的。一个 package 有一个描述如何构建这些 crate 的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;一个 package 最多包含一个库 crate，可以包含任意数量的可执行 crate。但是至少要包含一个 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;看一下使用&amp;lt;code&amp;gt;cargo new&amp;lt;&amp;#x2F;code&amp;gt;创建新的 package 时发生了什么。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;$ cargo new my-project
    Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project&amp;amp;#x2F;src
main.rs
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;cargo 生成一个 package，创建了一个&amp;lt;em&amp;gt;cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。看一下 cargo.toml 文件的内容，里面没有关于&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;的信息，因为 Rust 遵循一个规定，&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;文件是与 package 同名的可执行 crate 的入口文件。如果 package 下有一个&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，则它是与 package 同名的库 crate 的入口文件。cargo 将入口文件传给&amp;lt;code&amp;gt;rustc&amp;lt;&amp;#x2F;code&amp;gt;构建库或者可执行文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们刚生成的项目中，只有一个 src&amp;#x2F;main.rs 文件，意味着这个项目只有一个可执行 crate。如果 package 中同时具有&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，则说明这个 package 有一个可执行 crate 和一个库 crate，且都与 package 同名。如果 package 具有多个可执行 crate，则对应的文件需要存放在&amp;lt;em&amp;gt;src&amp;#x2F;bin&amp;lt;&amp;#x2F;em&amp;gt;目录下，每个文件都是一个独立的可执行 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;一个 crate 最好将一些相关功能组织到一个 scope 里面，方便在项目之间复用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;将 crate 的功能保持在它的 scope 内，可以明确该功能是我们自己定义的还是该 crate 定义的，避免潜在冲突。比如，&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;crate 定义了一个 trait 叫做&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;。我们也可以自己定义一个结构体叫&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;。由于 crate 的功能被限定在自己的 scope 中，因此当我们引入 rand 的时候，编译器很明确&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;是指向何处的。在我们自己的 crate 中，&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;指向我们定义的结构体；当我们要使用&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;中的&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;时，可以通过&amp;lt;code&amp;gt;rand::Rng&amp;lt;&amp;#x2F;code&amp;gt;的方式访问。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-defining-modules-to-control-scope-and-privacy&amp;quot;&amp;gt;Section 2 - Defining Modules to Control Scope and Privacy&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;module 让我们把代码组织管理，方便维护和复用。同时 module 还控制一个实体的隐私性，是外部可访问（public）还是不可访问（private）。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来写一个库 crate 作为例子。这些代码只定义函数声明而不实现函数体，因为现在需要将重点放在代码组织上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们模拟一个餐厅的状况。餐厅有&amp;lt;em&amp;gt;front of house&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;back of house&amp;lt;&amp;#x2F;em&amp;gt;。前厅主要是客人吃饭，服务员送餐，下单等。后厅主要给厨师使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们可以将功能函数通过嵌套模块的方式组织。使用&amp;lt;code&amp;gt;cargo run --lib restaurant&amp;lt;&amp;#x2F;code&amp;gt;创建一个 restaurant 库 crate，然后写入以下代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们用&amp;lt;code&amp;gt;mod&amp;lt;&amp;#x2F;code&amp;gt;关键字创建了一个&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块，并且用花括号将其内容包裹。在这个模块中，可以定义其他的模块，比如&amp;lt;code&amp;gt;hosting&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;serving&amp;lt;&amp;#x2F;code&amp;gt;，当然内部也可以定义其他的内容，比如结构体、枚举、函数、traits 等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通过模块可以将相关的定义组织在一起。编码人员想阅读或者扩展这个模块时，都能很方便的找到，且不破坏其组织性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前有提到&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;被称作 crate 的入口文件。之所以叫他们入口文件是因为，这两个文件中的内容都会生成一个根结点为 crate 的模块树。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;crate
└── front_of_house
    ├── hosting
    │   ├── add_to_waitlist
    │   └── seat_at_table
    └── serving
        ├── take_order
        ├── serve_order
        └── take_payment
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这棵树展示了模块的嵌套关系。可以看出这棵树上的一些模块是兄弟节点，这说明他们定义在同一个模块里。这里的概念和数据结构树中的兄弟子父节点的概念是类似的。整个模块的父节点是 crate 隐式节点。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-paths-for-referring-to-an-item-in-the-module-tree&amp;quot;&amp;gt;Section 3 - Paths for Referring to an Item in the Module Tree&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;如何导入模块中的内容使用，Rust 使用和文件系统路径相似的概念。调用一个外部方法的时候需要知道它的路径。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;路径有两种形式：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;从 crate 根节点开始的绝对路径。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;从当前模块开始的相对路径，在当前模块中调用&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;super&amp;lt;&amp;#x2F;code&amp;gt;或者其他关键字和名称。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;绝对路径和相对路径都是一组通过&amp;lt;code&amp;gt;::&amp;lt;&amp;#x2F;code&amp;gt;符号分隔的标识符组成。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;回到之前的例子，应该如何调用&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;这个函数呢？或者说，这个函数的路径是什么？下面的代码用两种方式来调用该方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    &amp;amp;#x2F;&amp;amp;#x2F; abs path
    crate::front_of_house::hosting::add_to_waitlist();
    &amp;amp;#x2F;&amp;amp;#x2F; relative path
    front_of_house::hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一种方式使用绝对路径调用函数。&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;函数和&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;函数定义在同一个 crate 中，因此可以使用&amp;lt;code&amp;gt;crate&amp;lt;&amp;#x2F;code&amp;gt;关键字作为绝对路径的开头。紧接着引入连续的模块名直到该函数的位置，和文件系统路径很相似。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第二种方式使用相对路径调用函数。路径是以&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;开头的，&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块和&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;函数定义在同一层级。这和文件系统中，使用相同层级文件的引入方式类似。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;具体使用哪种方式调用模块取决于你的项目结构。通常倾向于使用绝对路径，这种调用方式下，代码定义和模块引用更加独立。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;目前这个代码还是编译不通过的，编译器此时会报错说 hosting 模块是 private 的。此时我们的调用路径没有错，但是我们并没有该模块的访问权限。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;模块不光能很好的组织代码，它同时具有定义&amp;lt;em&amp;gt;privacy boundary&amp;lt;&amp;#x2F;em&amp;gt;权限界限的功能。具体的实现代码不允许外部代码访问，调用和依赖。如果你想让你的某些内容变为私有，将它封装到一个模块里就行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 权限系统默认所有实体（方法、结构体、变量、枚举等）都是私有的。父模块中不能调用子模块的内容，但是子模块可以调用父模块的内容。原因在于子模块隐藏了自己的实现细节，但是它可以访问自己定义所在的上下文环境。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;exposing-paths-with-the-pub-keyword&amp;quot;&amp;gt;Exposing Paths with the pub Keyword&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以使用&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字将默认私有的内容对外暴露。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此时编译代码，编译器依旧报错，此时错误是函数&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;是私有的。&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;模块对外暴露模块时，它里面的内容依旧默认是私有的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因此把&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;函数也用&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字修饰。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们再通过绝对路径和相对路径回顾一下引用过程。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在绝对路径中，路径用模块树的根节点&amp;lt;code&amp;gt;crate&amp;lt;&amp;#x2F;code&amp;gt;开头。然后是定义在根节点中的&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块。&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;是私有模块，但是由于&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;模块是跟它定义在同一个模块中的，因此在他们之间可以调用。接下来是&amp;lt;code&amp;gt;hosting&amp;lt;&amp;#x2F;code&amp;gt;公共模块，最后是&amp;lt;code&amp;gt;ad_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;公共方法，此时函数调用生效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在相对路径中，除了第一步以外。其余逻辑和绝对路径中是一样的。相对路径中使用&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;作为路径的开头。&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;是定义在同一个模块中的，因此以它们的父模块作为相对路径的开始是正常的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;starting-relative-paths-with-super&amp;quot;&amp;gt;Starting Relative Paths with super&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以使用&amp;lt;code&amp;gt;super&amp;lt;&amp;#x2F;code&amp;gt;关键字来代表父模块。这个关键字和文件系统中的&amp;lt;code&amp;gt;..&amp;lt;&amp;#x2F;code&amp;gt;语法类似。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fix_incorrect_order&amp;lt;&amp;#x2F;code&amp;gt;函数定义在&amp;lt;code&amp;gt;back_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块中。可以使用&amp;lt;code&amp;gt;super&amp;lt;&amp;#x2F;code&amp;gt;进入到它的父模块&amp;lt;code&amp;gt;crate&amp;lt;&amp;#x2F;code&amp;gt;，也就是根模块中。在根模块中就可以引用到&amp;lt;code&amp;gt;serve_order&amp;lt;&amp;#x2F;code&amp;gt;方法了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;making-structs-and-enums-public&amp;quot;&amp;gt;Making Structs and Enums Public&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字也可以用来修饰结构体和枚举，但是另外有一些细节需要注意。&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字修饰的结构体，它的字段依旧是私有的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod back_of_house {
    pub struct Breakfast {
        pub toast: String,

        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;amp;amp;str) -&amp;amp;gt; Beakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&amp;amp;quot;peaches&amp;amp;quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer(&amp;amp;quot;Rye&amp;amp;quot;);

    meal.toast = String::from(&amp;amp;quot;Wheat&amp;amp;quot;);

    println!(&amp;amp;quot;I&amp;amp;#x27;d like {} toast please&amp;amp;quot;, meal.toast);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;函数中可以访问&amp;lt;code&amp;gt;back_of_house::Breakfast&amp;lt;&amp;#x2F;code&amp;gt;的&amp;lt;code&amp;gt;toast&amp;lt;&amp;#x2F;code&amp;gt;字段，因为它是公开的，但是我们不能访问&amp;lt;code&amp;gt;seasonal_fruit&amp;lt;&amp;#x2F;code&amp;gt;字段，因为字段默认都是私有的。同时，由于&amp;lt;code&amp;gt;back_of_house::Breakfast&amp;lt;&amp;#x2F;code&amp;gt;具有一个私有字段，因此这个结构体需要提供一个作用类似于工厂函数的方法，用来创建实例，这里是&amp;lt;code&amp;gt;summer&amp;lt;&amp;#x2F;code&amp;gt;方法。如果结构体没有提供这样的方法，那么我们将无法实例化它，因为在外部无法对私有字段进行赋值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在枚举类型中，&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;字段修饰的枚举类型，它下面的字段同时也都是公开的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }

    pub fn eat_at_restaurant() {
        let order1 = back_of_house::Appetizer::Soup;
        let order2 = back_of_house::APpetizer::Salad;
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果&amp;lt;code&amp;gt;enum&amp;lt;&amp;#x2F;code&amp;gt;里的字段是私有的，那么这个 enum 就没有任何的意义，所有当&amp;lt;code&amp;gt;enum&amp;lt;&amp;#x2F;code&amp;gt;被修饰为&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;时，它内部的字段都自动转为公开。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-bringing-paths-into-scope-with-the-use-keyword&amp;quot;&amp;gt;Section 4 - Bringing Paths into Scope with the use Keyword&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，我们写的模块引用代码中，模块路径很长而且很多内容都是重复的。使用&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字将模块路径导入到当前模块中，可以解决这个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字和一个路径名称，类似于文件系统中创建一个符号链接。也可以通过&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字引入一个相对路径：&amp;lt;code&amp;gt;use self::front_of_house::hosting;&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-idiomatic-use-paths&amp;quot;&amp;gt;Creating Idiomatic use Paths&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;思考一个问题——为什么要通过&amp;lt;code&amp;gt;use crate::front_of_house::hosting&amp;lt;&amp;#x2F;code&amp;gt;引入模块然后再通过&amp;lt;code&amp;gt;hosting&amp;lt;&amp;#x2F;code&amp;gt;模块调用&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;方法。而不是直接引入&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;方法进行调用呢？引入要调用函数的父模块是惯用的方式，因为这样能让我们在调用时清楚的知道这个函数的归属。而引入结构体、枚举以及一些其他内容时，惯用的方式是直接引入全部的路径。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里没有强制性的要求，只不过这种方式是 Rust 代码惯用的方式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;有一种例外情况是，我们引入了两个模块中名称相同的两个内容，此时需要明确其父模块，因为 Rust 是不允许同名的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt;
use std::io;

fn function1() -&amp;amp;gt; fmt::Result{}

fn function2() -&amp;amp;gt; io::Result{}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;providing-new-names-with-the-as-keyword&amp;quot;&amp;gt;Providing New Names with the as Keyword&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;引入不同模块的同名内容的另一个解决方案是通过&amp;lt;code&amp;gt;as&amp;lt;&amp;#x2F;code&amp;gt;关键字对其重新命名一个本地使用名称，或者说是别名。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&amp;amp;gt; Result{}

fn function2() -&amp;amp;gt; IoResult&amp;amp;lt;()&amp;amp;gt;{}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;re-exporting-names-with-pub-use&amp;quot;&amp;gt;Re-exporting Names with pub use&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当我们使用&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字引入一个模块时，它仅在当前模块中是可用的。为了让调用我们自己模块的代码也能够使用这个模块名称，我们可以通过&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;关键字对其进行二次导出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;using-nested-paths-to-clean-up-large-use-lists&amp;quot;&amp;gt;Using Nested Paths to Clean Up Large use Lists&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果我们引入一个模块中的多个内容，每行引入一个模块会让我们的文件内容变得很长。例如：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::cmp::Ordering;
use std::io;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以通过嵌套的方式引入同一个模块中的多个内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::{cmp::Ordering, io};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在大型项目中，这种方式能有效减少 use 语句的数量。同时嵌套引用允许我们在任意的层级进行嵌套。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::io::{self, Write};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;the-glob-operator&amp;quot;&amp;gt;The Glob Operator&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果想要引入模块下的所有&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;的内容，可以使用通配符&amp;lt;code&amp;gt;*&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::*;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这种方式需要谨慎使用，因为有可能会跟你本地的一些名称冲突。这种引入方式一般用在测试模块中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-5-separating-modules-into-different-files&amp;quot;&amp;gt;Section 5 - Separating Modules into Different Files&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;当模块越来越大，你就需要分别将这些代码分割到不同的文件中去了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;front_of_house.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub mod hosting {
    pub fn add_to_waitlist() {}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;mod front_of_house&amp;lt;&amp;#x2F;code&amp;gt;后接一个分号，此时 Rust 会加载跟这个模块名称相同的文件内容。我们可以将 front_of_house 文件再分割。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;front_of_house.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub mod hosting;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;front_of_house&amp;#x2F;hosting.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_to_waitlist() {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Iterators and Closures</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;10-iterators-and-closures&#x2F;"/>
            <updated>2020-12-28T08:26:58+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;10-iterators-and-closures&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-10-functional-language-features-iterators-and-closures&amp;quot;&amp;gt;Chapter 10 - Functional Language Features: Iterators and Closures&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Rust 的灵感来自于现有的许多语言和技术，其中一个最重要的概念就是&amp;lt;em&amp;gt;函数式编程（functional programming）&amp;lt;&amp;#x2F;em&amp;gt;。函数式编程包括，把函数当作参数传递给其他函数；从函数中返回一个函数；把函数赋值给变量延迟调用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面会介绍一些跟其他函数式语言类似的概念：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;闭包，结构类似于函数，可以存储在变量中。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;迭代器，处理一系列数据的一种方式。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;这两者的性能。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-closures-anonymous-functions-that-can-capture-their-environment&amp;quot;&amp;gt;Section 1 - Closures: Anonymous Functions that Can Capture Their Environment&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 的闭包是一个匿名函数，你可以把它存进变量或者当作参数传给其他函数。闭包的定义和调用可以在不同时间点，不同上下文中。跟函数不同的是，闭包可以捕获他们定义所在上下文中的变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;例如有这样一个场景：要开发一个 app 来为用户生成自定义的训练计划。后台使用 Rust，生成算法考虑了很多因素，例如用户年龄，体重，运动经历，当前训练计划和用户自定义的强度指数等。假设这个算法需要运行几秒钟，我们只想在初始化的时候调用算法一次，免得让用户不必要的等待结果。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;假设用函数&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;模拟算法调用：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&amp;amp;gt; u32 {
    println!(&amp;amp;quot;执行算法&amp;amp;quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来是&amp;lt;code&amp;gt;main&amp;lt;&amp;#x2F;code&amp;gt;函数，包含了用户在调用训练计划时要执行的代码。*闭包（closure）*的使用和前端交互没啥关系，因此这里硬编码参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来模拟一下生成训练计划的算法函数&amp;lt;code&amp;gt;generate_workout&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &amp;amp;lt; 25 {
        println!(
            &amp;amp;quot;Today, do {} pushups!&amp;amp;quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &amp;amp;quot;Next, do {} situps!&amp;amp;quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(
                &amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个代码已经实现了业务方的需求。假设大数据团队想要我们在以后修改&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;的调用方式。为了简化升级流程，需要重构代码，让&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;只执行一次。并且多次调用的地方也需要删除掉。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;refactoring-using-functions&amp;quot;&amp;gt;Refactoring Using Functions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;首先，可以将&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;函数的执行结果存储在变量中，需要的时候直接使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity &amp;amp;lt; 25 {
        println!(&amp;amp;quot;Today, do {} pushups!&amp;amp;quot;, expensive_result);
        println!(&amp;amp;quot;Next, do {} situps!&amp;amp;quot;, expensive_result);
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(&amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;, expensive_result);
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个解决方式统一了&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;函数的调用，并且解决了&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;代码块中函数不必要的多次调用。但是，这种解决方案需要所有条件下的情况等待算法执行结果，哪怕最终我们不需要这个结果。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所以，我们想让代码只在需要结果的时候被调用一次。这个场景就很适用于&amp;lt;em&amp;gt;闭包（closure）&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;refactoring-with-closures-to-store-code&amp;quot;&amp;gt;Refactoring with Closures to Store Code&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;定义和储存闭包：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let expensive_closure = |num| {
    println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;闭包定义被赋值给变量&amp;lt;code&amp;gt;expensive_closure&amp;lt;&amp;#x2F;code&amp;gt;。闭包定义又两个竖线&amp;lt;code&amp;gt;|&amp;lt;&amp;#x2F;code&amp;gt;开头，竖线中间是传给闭包的参数。选择这种语法是因为它跟 Smalltalk 和 Ruby 相似。这个闭包有一个参数&amp;lt;code&amp;gt;num&amp;lt;&amp;#x2F;code&amp;gt;，如果需要传多个参数，可以&amp;lt;code&amp;gt;|p1, p2, ...|&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;然后用花括号包住闭包体，可以看到就是函数中的内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;现在&amp;lt;code&amp;gt;let&amp;lt;&amp;#x2F;code&amp;gt;语句意味着&amp;lt;code&amp;gt;expensive_closure&amp;lt;&amp;#x2F;code&amp;gt;变量包含一个匿名函数的定义，而不是函数的运行结果。也就是说需要在后面执行的代码存储在这个变量中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来修改&amp;lt;code&amp;gt;generate_workout&amp;lt;&amp;#x2F;code&amp;gt;函数中算法调用的部分。闭包调用和函数调用一样。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &amp;amp;lt; 25 {
        println!(&amp;amp;quot;Today, do {} pushups!&amp;amp;quot;, expensive_closure(intensity));
        println!(&amp;amp;quot;Next, do {} situps!&amp;amp;quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(
                &amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;,
                expensive_closure(intensity)
            );
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;现在，又引入了多次调用的问题。昂贵的计算操作会被调用多次，用户等待的时长更久。我们可以在内部的&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;块中创建一个变量存储计算结果。但是闭包提供了更好的解决方案。稍后会介绍该方案。目前先套路一下为什么闭包定义没有类型声明，也没有相关的 trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;closure-type-inference-and-annotation&amp;quot;&amp;gt;Closure Type Inference and Annotation&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;闭包不会像函数一样要求你声明参数和返回值的类型。函数要求声明类型是因为它是显式接口的一部分。严格地定义接口能够保证所有的调用者都按照你的预期来传递参数和处理返回值。但是闭包不是用于对外接口的，它是给库内部用的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们也可以为闭包声明类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let expensive_closure = |num: u32| -&amp;amp;gt; u32 {
    println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;增加了类型声明之后，闭包定义更接近函数定义了。下面是函数声明语法和闭包的一个垂直对比。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn  add_one_v1   (x: u32) -&amp;amp;gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&amp;amp;gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第二行是完整声明定义，跟函数一样。第三行去掉了类型声明。第四行去掉了花括号，因为闭包内容只有一个表达式，此时可以将花括号也省略。这些声明都是有效的而且功能都是完全一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;闭包对参数和返回值都有具体的类型推断。当我们没有指定类型时，如果我们调用了两次闭包，第一次调用时候的类型，会被编译器锁定在闭包中，如果后续调用我们用其它类型的参数，编译器就报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;storing-closures-using-generic-parameters-and-the-fn-traits&amp;quot;&amp;gt;Storing Closures Using Generic Parameters and the Fn Traits&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，闭包被多次调用。我们可以创建一个结构体来存储闭包和闭包的运行结果。只有当结构体中还没有缓存结果值时，才会运行闭包。这种模式称为备忘录或者懒加载。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;结构体存储闭包时，闭包定义需要添加类型声明。因为结构体定义中，字段类型是必须的。每个闭包示例都有唯一的匿名类型，这意味着，就算两个闭包的类型定义都一致，编译器还是认为它们是不同的类型。在结构体，枚举和函数参数中定义闭包，需要用到泛型和 trait 绑定。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 由标准库提供。所有闭包至少需要实现&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;FnMut&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;FnOnce&amp;lt;&amp;#x2F;code&amp;gt;trait 之一。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 绑定上声明类型，代表闭包的参数类型和返回值类型必须和该绑定。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Cacher&amp;amp;lt;T&amp;amp;gt;
where
    T: Fn(u32) -&amp;amp;gt; u32,
{
    calculation: T,
    value: Option&amp;amp;lt;u32&amp;amp;gt;,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;结构体有一个&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型的&amp;lt;code&amp;gt;calculation&amp;lt;&amp;#x2F;code&amp;gt;字段。trait 绑定在&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型上表示这个字段是实现了&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 的闭包。如果我们想要在这个字段上存储闭包，那么这个闭包必须符合一个&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;参数和一个&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;返回值的声明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Value&amp;lt;&amp;#x2F;code&amp;gt;字段的类型是&amp;lt;code&amp;gt;Option&amp;amp;lt;u32&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，初始值是&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;。当其他代码需要&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;中存储的闭包的运算结果时，&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;会运行它存储的闭包，并且将结果返回和缓存。当再次调用&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;获取闭包运算结果时，就将之前的计算结果返回。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;T&amp;amp;gt; Cacher&amp;amp;lt;T&amp;amp;gt;
where
    T: Fn(u32) -&amp;amp;gt; u32,
{
    fn new(calculation: T) -&amp;amp;gt; Cacher&amp;amp;lt;T&amp;amp;gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;amp;amp;mut self, arg: u32) -&amp;amp;gt; u32 {
        match self.value {
            Some(v) =&amp;amp;gt; v,
            None =&amp;amp;gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们希望&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;自身来管理字段值，而不是让外部代码去修改，因此这些字段都是私有的，通过方法返回。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;然后再修改&amp;lt;code&amp;gt;generate_workout&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &amp;amp;lt; 25 {
        println!(&amp;amp;quot;Today, do {} pushups!&amp;amp;quot;, expensive_result.value(intensity));
        println!(&amp;amp;quot;Next, do {} situps!&amp;amp;quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(
                &amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;limitations-of-the-cacher-implementation&amp;quot;&amp;gt;Limitations of the &amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt; Implementation&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;目前这个&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;实现还有两个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第一个问题是，无论&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;实例接收什么参数，都返回的是第一个参数计算的结果。比如下面的测试用例会失败&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;将&amp;lt;code&amp;gt;value&amp;lt;&amp;#x2F;code&amp;gt;字段改为哈希表类型，通过参数来映射计算值就能解决这个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第二个问题是这个&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;只能存储&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;参数类型和&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;返回值类型的闭包。但是我们可能想存储其他类型。为了解决这个问题，可以使用多个泛型类型参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;capturing-the-environment-with-closures&amp;quot;&amp;gt;Capturing the Environment with Closures&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，我们把闭包当作匿名函数使用。闭包还有一个函数不具备的功能：闭包可以捕获它定义所在的上下文并且可以访问变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子中，&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;变量不是闭包的参数，但是仍然可以被闭包访问。因为&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;变量和闭包是定义在同一个上下文环境中的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当闭包捕获上下文的变量时，会将这些变量存储到内存中使用。大多数情况下代码执行不需要捕获上下文变量，这种内存开销是不必要的。因为函数不允许捕获它的上下文，因此执行函数不会引起这些额外的内存开销。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;闭包可以通过三种方式捕获上下文信息，跟函数获取参数的三种方式对应：获取所有权、可变引用和不可变引用。这三种方式分别封装在三种&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;FnOnce&amp;lt;&amp;#x2F;code&amp;gt;消费捕获的变量时，必须获取上下文变量的所有权并且传递到闭包中。Once 表示闭包不能对同一个变量获取两次及以上所有权。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;FnMut&amp;lt;&amp;#x2F;code&amp;gt;能够改变能够改变上下文中的变量值。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;不可以改变上下文中的变量值。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;创建闭包时，Rust 会根据你使用变量的方式来推断你使用的是哪个 trait。所有闭包都实现&amp;lt;code&amp;gt;FnOnce&amp;lt;&amp;#x2F;code&amp;gt;因为至少可以被调用一次。不获取所有权的闭包实现&amp;lt;code&amp;gt;FnMut&amp;lt;&amp;#x2F;code&amp;gt;trait。不改变外部变量的闭包实现&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果想要闭包强制获取所有权，可以在参数列表前使用&amp;lt;code&amp;gt;move&amp;lt;&amp;#x2F;code&amp;gt;关键字。当把闭包传递给新线程，让新线程获取所有权时，这种方法很有用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面是一个强制传递 vec 数据所有权的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&amp;amp;quot;can&amp;amp;#x27;t use x here: {:?}&amp;amp;quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;的所有权被传递给了闭包，在&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;中使用会报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-processing-a-series-of-items-with-iterators&amp;quot;&amp;gt;Section 2 - Processing a Series of Items with Iterators&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;迭代器模式可以让你在一个有序列表上依次执行一些任务。迭代器主要负责序列中每个项目要执行的操作和控制序列的退出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 中迭代器是惰性的。意味着只要你不调用消费迭代器的方法，它就不会执行任何操作。比如这个代码就没有任何实际作用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当我们创建迭代器后，有许多方法可以去消费它。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环，在每个元素上执行一些操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&amp;amp;quot;Got: {}&amp;amp;quot;, val);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;迭代器可以让你更灵活的在不同序列上使用相同的逻辑，不光是在数组这样的数据结构上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;iteratortrait-he-next-fang-fa&amp;quot;&amp;gt;&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;Trait 和&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt; 方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;所有的迭代器都实现  了标准库提供的&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait。它的定义大致是：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;
pub trait Iterator {
    type Item;

    fn next(&amp;amp;amp;mut self) -&amp;amp;gt; Option&amp;amp;lt;Self::Item&amp;amp;gt;;

    &amp;amp;#x2F;&amp;amp;#x2F; methods with default implementations elided
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;有两个新语法&amp;lt;code&amp;gt;type Item&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Self::Item&amp;lt;&amp;#x2F;code&amp;gt;，它定义了一个 trait 的关联类型。因此，实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 需要你定义一个&amp;lt;code&amp;gt;Item&amp;lt;&amp;#x2F;code&amp;gt;类型，这个类型会在&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法的返回值类型中使用。也就是说，&amp;lt;code&amp;gt;Item&amp;lt;&amp;#x2F;code&amp;gt;类型是迭代器的返回类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 只有&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法是必须实现的，这个方法一次返回一个迭代器中的元素，用&amp;lt;code&amp;gt;Some&amp;lt;&amp;#x2F;code&amp;gt;包裹；当迭代结束时，返回&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;可以直接通过迭代器调用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;amp;amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;amp;amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;amp;amp;3));
    assert_eq!(v1_iter.next(), None);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法时，迭代器需要&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字定义。next 方法会改变迭代器中用来追踪目前所迭代的位置状态，也可以说这是一种*消费（consumes）*行为。在&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环中，迭代器定义不需要&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字，因为&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环会获取迭代器的所有权，隐式地将其转为 mutable 的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法返回的数据是原序列中元素的不可变引用。&amp;lt;code&amp;gt;iter&amp;lt;&amp;#x2F;code&amp;gt;在不可变引用上生成迭代器。如果我们想创建一个拥有原序列所有权的迭代器，可以调用&amp;lt;code&amp;gt;into_iter&amp;lt;&amp;#x2F;code&amp;gt;。如果想创建一个迭代器的可变引用，可以调用&amp;lt;code&amp;gt;iter_mut&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;xiao-fei-die-dai-qi-de-fang-fa&amp;quot;&amp;gt;消费迭代器的方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;标准库默认为&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 提供了许多方法。有些方法内部会调用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法，因此在实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 时，必须实现&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;调用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法的那些方法称为&amp;lt;em&amp;gt;消费型适配器（consuming adaptors）&amp;lt;&amp;#x2F;em&amp;gt;，因为它们在消耗迭代器。例如&amp;lt;code&amp;gt;sum&amp;lt;&amp;#x2F;code&amp;gt;方法：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;chan-sheng-xin-die-dai-qi-de-fang-fa&amp;quot;&amp;gt;产生新迭代器的方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;还有一些&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 上定义方法，称之为&amp;lt;em&amp;gt;迭代器适配器（iterator adaptors）&amp;lt;&amp;#x2F;em&amp;gt;，这些方法可以把迭代器转换成其他类型的迭代器。迭代器适配器可以链式调用，这样可以提高一组复杂操作的可读性。由于迭代器是惰性的，因此你最终需要调用消费适配器，这一组操作才会真正起作用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1: Vec&amp;amp;lt;i32&amp;amp;gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码编译器会给出一个警告：&amp;lt;code&amp;gt;iterators are lazy and do nothing unless consumed&amp;lt;&amp;#x2F;code&amp;gt;。也就是说这个代码不会起任何作用，定义的闭包也根本没有被执行。我们可以通过调用消费适配器，比如&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法来解决这个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1: Vec&amp;amp;lt;i32&amp;amp;gt; = vec![1, 2, 3];

let v2: Vec&amp;amp;lt;_&amp;amp;gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-bi-bao-bu-huo-shang-xia-wen&amp;quot;&amp;gt;使用闭包捕获上下文&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;下面通过使用&amp;lt;code&amp;gt;filter&amp;lt;&amp;#x2F;code&amp;gt;迭代适配器来演示一个闭包捕获上下文的基本用法。&amp;lt;code&amp;gt;filter&amp;lt;&amp;#x2F;code&amp;gt;方法接收一个闭包，这个闭包的参数是迭代器中的元素，返回值是一个布尔值。如果闭包返回&amp;lt;code&amp;gt;true&amp;lt;&amp;#x2F;code&amp;gt;，则该元素会被包含在&amp;lt;code&amp;gt;filter&amp;lt;&amp;#x2F;code&amp;gt;方法返回的迭代器中，反之亦然。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&amp;amp;lt;Shoe&amp;amp;gt;, shoe_size: u32) -&amp;amp;gt; Vec&amp;amp;lt;Shoe&amp;amp;gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&amp;amp;quot;sneaker&amp;amp;quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&amp;amp;quot;sandal&amp;amp;quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&amp;amp;quot;boot&amp;amp;quot;),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&amp;amp;quot;sneaker&amp;amp;quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&amp;amp;quot;boot&amp;amp;quot;)
                },
            ]
        );
    }
}

fn main() {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-iteratortrait-shi-xian-zi-ding-yi-die-dai-qi&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 实现自定义迭代器&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，可以通过调用 Vec 类型上的&amp;lt;code&amp;gt;iter&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;iter_mut&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;into_iter&amp;lt;&amp;#x2F;code&amp;gt;来生成一个迭代器。你也可以为标准库中的其他类型来创建迭代器，例如哈希表。也可以在你自己的类型上，实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait，从而实现任何你想要的功能。唯一必须要被实现的方法是&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法，当你实现&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法后，就可以调用其他&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 实现的默认方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;实现一个从 1 累加到 5 的迭代器来演示一下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&amp;amp;gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;amp;amp;mut self) -&amp;amp;gt; Option&amp;amp;lt;Self::Item&amp;amp;gt; {
        if self.count &amp;amp;lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}

fn main() {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;shi-yong-iteratortrait-de-qi-ta-fang-fa&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 的其他方法&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait，也定义了&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法，因此我们可以调用&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 上，由标准库默认实现的任意方法，因为它们使用的都是&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法的功能。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();
    assert_eq!(18, sum);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码将两个 Counter 迭代器组合为元组数组，并且第二个 Counter 的第一个元素被跳过，因此最后一组元组是&amp;lt;code&amp;gt;(5, None)&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;code&amp;gt;zip&amp;lt;&amp;#x2F;code&amp;gt;方法不会返回元组中带有&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;的元素。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Cargo and Crates.io</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;11-cargo-and-crates-io&#x2F;"/>
            <updated>2020-12-15T07:21:19+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;11-cargo-and-crates-io&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-11-guan-yu-cargo-he-crates-io&amp;quot;&amp;gt;Chapter 11 - 关于 Cargo 和 Crates.io&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;目前为止我们只使用到 cargo 创建、运行、测试、构建等基础功能。本章会介绍它的其他功能。包括：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;使用配置文件定制构建&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;在&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;发布库&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;使用工作空间管理大型项目&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;安装&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;上的可执行文件&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;定制化命令扩展 cargo&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;可以在&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;cargo&amp;#x2F;&amp;quot;&amp;gt;cargo 官方文档&amp;lt;&amp;#x2F;a&amp;gt;查看全部功能说明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-shi-yong-pei-zhi-wen-jian-ding-zhi-gou-jian&amp;quot;&amp;gt;Section 1 - 使用配置文件定制构建&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 中，*配置文件（release profiles）*是预定义的、可自定义的文件，不同的配置选项可以对代码编译进行控制。每个文件的配置都是独立的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;cargo 有两个主要的配置文件&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;dev&amp;lt;&amp;#x2F;code&amp;gt;配置文件。&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;命令会使用这个配置文件。包含针对开发环境的默认配置&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;release&amp;lt;&amp;#x2F;code&amp;gt;配置文件。&amp;lt;code&amp;gt;cargo build --release&amp;lt;&amp;#x2F;code&amp;gt;命令会使用这个配置文件。包含针对发布环境的默认配置。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;当&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中没有&amp;lt;code&amp;gt;[profile.*]&amp;lt;&amp;#x2F;code&amp;gt;声明时，cargo 会使用默认配置。对想要修改的配置文件加&amp;lt;code&amp;gt;[profile.*]&amp;lt;&amp;#x2F;code&amp;gt;声明，就可以对默认配置进行覆盖和定制化。例如：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;分别对&amp;lt;code&amp;gt;dev&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;release&amp;lt;&amp;#x2F;code&amp;gt;配置文件，针对&amp;lt;code&amp;gt;opt-level&amp;lt;&amp;#x2F;code&amp;gt;配置进行了定制化。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-fa-bu-crate-dao-crates-io&amp;quot;&amp;gt;Section 2 - 发布 Crate 到 Crates.io&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 和 Cargo 有很多功能，辅助包发布和查找。首先介绍三个功能然后再介绍如何发布自己的包。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;you-yong-de-wen-dang-zhu-shi&amp;quot;&amp;gt;有用的文档注释&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;准确描述你的包有助于让其他人更容易地了解如何使用、何时使用你的包，所以有用的文档很有必要。代码注释时使用双斜线&amp;lt;code&amp;gt;&amp;#x2F;&amp;#x2F;&amp;lt;&amp;#x2F;code&amp;gt;，Rust 也有专门针对文档的注释，称之为&amp;lt;em&amp;gt;文档注释（documentation comment）&amp;lt;&amp;#x2F;em&amp;gt;，文档注释会用来生成 html 页面。html 展示了你对公开 API 的介绍，文档内容应当是介绍如何使用你的 API，而不是描述你如何实现的这些 API。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;文档注释使用三斜线&amp;lt;code&amp;gt;&amp;#x2F;&amp;#x2F;&amp;#x2F;&amp;lt;&amp;#x2F;code&amp;gt;，并且支持 md 语法。文档注释放置于被描述对象之前。例如我们创建一个&amp;lt;code&amp;gt;my_crate&amp;lt;&amp;#x2F;code&amp;gt;库，里面包含一个&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; Adds one to the number given.
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; # Examples
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; ```
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; let arg = 5;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; let answer = my_crate::add_one(arg);
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; assert_eq!(6, answer);
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; ```
pub fn add_one(x: i32) -&amp;amp;gt; i32 {
    x + 1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们描述了&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;函数的功能是什么，然后&amp;lt;code&amp;gt;Examples&amp;lt;&amp;#x2F;code&amp;gt;下面是一个示例代码块。&amp;lt;code&amp;gt;cargo doc&amp;lt;&amp;#x2F;code&amp;gt;命令可以基于这些描述生成 html 文档。这个命令运行了 Rust 提供的&amp;lt;code&amp;gt;rustdoc&amp;lt;&amp;#x2F;code&amp;gt;工具，并且将生成的 html 文件放置于&amp;lt;em&amp;gt;target&amp;#x2F;doc&amp;lt;&amp;#x2F;em&amp;gt;目录下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;--open&amp;lt;&amp;#x2F;code&amp;gt;参数会在文档创建完成之后打开浏览器，效果如下：
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-165110@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;chang-yong-mo-kuai&amp;quot;&amp;gt;常用模块&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们已经使用&amp;lt;code&amp;gt;# Examples&amp;lt;&amp;#x2F;code&amp;gt;md 语法，创建了一个示例代码模块，下面还有一些常用的模块：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Panics&amp;lt;&amp;#x2F;strong&amp;gt;：会导致代码出错的场景。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Errors&amp;lt;&amp;#x2F;strong&amp;gt;：如果函数返回的是一个&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;，描述一下返回的错误类型，以及如何处理这些错误。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Safety&amp;lt;&amp;#x2F;strong&amp;gt;：如果这个函数调用是&amp;lt;code&amp;gt;unsafe&amp;lt;&amp;#x2F;code&amp;gt;的，应当描述函数为何是&amp;lt;code&amp;gt;unsale&amp;lt;&amp;#x2F;code&amp;gt;，以及涵盖希望由调用者维护的不变性（invariants）。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h4 id=&amp;quot;wen-dang-zhu-shi-ce-shi-yong-li&amp;quot;&amp;gt;文档注释测试用例&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;命令会将文档注释中 examples 模块下的示例代码作为测试用例运行。这会保证你的代码和示例代码是同步的，因为当你修改其中任意部分时，如果出错文档测试会捕获到。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;mu-lu-xing-miao-shu&amp;quot;&amp;gt;目录性描述&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;对 crate 包含内容的一个总体描述。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F;! # My Crate
&amp;amp;#x2F;&amp;amp;#x2F;!
&amp;amp;#x2F;&amp;amp;#x2F;! `my_crate` is a collection of utilities to make performing certain
&amp;amp;#x2F;&amp;amp;#x2F;! calculations more convenient.

&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; Adds one to the number given.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-171515@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-pub-usedao-chu-gong-you-api&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;导出公有 API&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在写代码时，你的代码结构可能自己比较清楚，但对于使用者来说可能不是特别方便。在组织代码时，可能进行了很深的模块嵌套，但是当使用者想要使用一个定义的很深的 API 时，找到它就比较费劲了。例如：&amp;lt;code&amp;gt;use my_crate::some_module::another_module::UsefulType;&amp;lt;&amp;#x2F;code&amp;gt;。显然&amp;lt;code&amp;gt;use my_crate::UsefulType&amp;lt;&amp;#x2F;code&amp;gt;对调用者更加的友好。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因此当发布包时，API 的结构是首先要考虑的问题。因为使用者不会像你一样熟悉你的代码结构。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当一个 API 对调用者不太友好时，你不需要修改你的代码组织，你可以使用&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;二次导出。&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;导入一个共有 API，并且将其再对外公开暴露。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;创建一个&amp;lt;code&amp;gt;art&amp;lt;&amp;#x2F;code&amp;gt;包，它的内容如下所示：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F;! # Art
&amp;amp;#x2F;&amp;amp;#x2F;!
&amp;amp;#x2F;&amp;amp;#x2F;! A library for modeling artistic concepts.

pub mod kinds {
    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; Combines two primary colors in equal amounts to create
    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&amp;amp;gt; SecondaryColor {
        &amp;amp;#x2F;&amp;amp;#x2F; --snip--
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;查看它的文档：
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-173414@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;PrimaryColor&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;SecondaryColor&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;mix&amp;lt;&amp;#x2F;code&amp;gt;都没有在首页展示出来，需要我们手动点入这些模块。并且其他模块调用我们的包时，引用的链路特别长：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;为了移除这个调用者冗长的调用链路，我们可以在自己的包中，将这些 API 进行二次导出：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;PrimaryColor&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;SecondaryColor&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;mix&amp;lt;&amp;#x2F;code&amp;gt;都更容易找到了，文档如下：
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-174144@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;并且调用者在引用代码，代码量也更少：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use art::PrimaryColor;
use art::mix;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;chuang-jian-crates-io-zhang-hao&amp;quot;&amp;gt;创建 Crates.io 账号&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;首先去&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;注册一个账号，验证邮箱之后，获取 API token。然后在终端使用 token 登陆。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;cargo login abcdefghijklmnopqrstuvwxyz012345
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;token 会被存储在*~&amp;#x2F;.cargo&amp;#x2F;credentials.*文件下。注意不要将 token 分享出去。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;wei-xin-bao-tian-jia-yuan-shu-ju&amp;quot;&amp;gt;为新包添加元数据&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;发布之前需要在&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件的[package]模块下追加一些元数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;注意你的包名必须是唯一的。当你在本地开发时，跟目录名称可以随意，但是在发布时，元数据当中的包名称必须是唯一的，不能跟别人的包名称冲突。因此在发布之前可以去网站上先搜索一下你的名字有没有被使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件下的[package]模块中定义包名称：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[package]
name = &amp;amp;quot;ksleo_public_test&amp;amp;quot;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当你选好唯一的名称之后，使用&amp;lt;code&amp;gt;cargo publish&amp;lt;&amp;#x2F;code&amp;gt;发布，会出现一个错误&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;cargo&amp;#x2F;reference&amp;#x2F;manifest.html for how to upload metadata&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;因为你的项目还缺少一些关键信息：描述和证书。描述你的包是做什么用，并且你的包是基于什么证书给别人使用的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[package]
license = &amp;amp;quot;MIT&amp;amp;quot;
description = &amp;amp;quot;just for pub test&amp;amp;quot;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在[package]模块下加入这些内容后，就可以成功发布了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fa-bu-xin-ban-ben&amp;quot;&amp;gt;发布新版本&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;修改&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件下的版本号，重新发布即可。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-cargo-yankjin-yong-ban-ben&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;cargo yank&amp;lt;&amp;#x2F;code&amp;gt;禁用版本&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;cargo 不支持删除某个历史版本，但可以将历史版本禁用，防止其他人将该版本加入依赖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;yanking 只能防止新项目将该版本作为依赖，已存在的项目依旧可以下载该版本。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面的命令就将 1.0.1 版本禁用了，任何新项目都不能再依赖该版本&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;$ cargo yank –vers 1.0.1&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;如果要撤销某个版本的禁用，可以使用&amp;lt;code&amp;gt;--undo&amp;lt;&amp;#x2F;code&amp;gt;参数&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;$ cargo yank –vers 1.0.1 –undo&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-cargo-gong-zuo-kong-jian&amp;quot;&amp;gt;Section 3 - Cargo 工作空间&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;在开发过程中，你的包会变得越来越大，此时应该对它们进一步切分。在这种场景下，Cargo 提供了*工作空间（work space）*的功能让你来管理一些相关的包。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;chuang-jian-gong-zuo-kong-jian&amp;quot;&amp;gt;创建工作空间&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;工作空间是一组共享&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件和输出目录的包集合。创建工作空间有很多方式，下面展示最常用的一种。我们将创建包含 1 个可执行 crate 和 1 个库 crate 的工作空间。可执行 crate 提供入口函数&amp;lt;code&amp;gt;main&amp;lt;&amp;#x2F;code&amp;gt;，其余库 crate 提供方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;首先创建一个&amp;lt;em&amp;gt;add&amp;lt;&amp;#x2F;em&amp;gt;目录。然后进入目录创建&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。这个 toml 文件不会包含之前出现的[package]块，或者其他元数据。它以[workspace]块开始，下面会定义工作空间所包含的成员。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[workspace]

members = [
    &amp;amp;quot;adder&amp;amp;quot;,
]
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;然后在&amp;lt;em&amp;gt;add&amp;lt;&amp;#x2F;em&amp;gt;目录下新建一个可执行包&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;。最后使用&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;创建工作空间，此时项目结构应该如下：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;工作空间根目录有一个放置编译结果的&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录，adder 包内部没有&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录了。就算我们进入&amp;lt;em&amp;gt;adder&amp;lt;&amp;#x2F;em&amp;gt;项目运行&amp;lt;code&amp;gt;Cargo build&amp;lt;&amp;#x2F;code&amp;gt;，编译结果还是会被存放到根目录下的&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录中，而不是&amp;lt;em&amp;gt;add&amp;#x2F;adder&amp;#x2F;target&amp;lt;&amp;#x2F;em&amp;gt;目录。Cargo 这样组织&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录是因为，工作空间下的包是相互依赖的，如果每个包都有自己的&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录来存放编译结果，则所有的包都需要互相为其他包构建一份。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;chuang-jian-di-er-ge-bao&amp;quot;&amp;gt;创建第二个包&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;接下来创建工作空间下的第二个包&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;。修改根目录下的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[workspace]

members = [
    &amp;amp;quot;adder&amp;amp;quot;,
    &amp;amp;quot;add-one&amp;amp;quot;,
]
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;然后创建一个库 crate。&amp;lt;code&amp;gt;cargo new add_one --lib&amp;lt;&amp;#x2F;code&amp;gt;。现在目录应该包含以下内容&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;em&amp;gt;add-one&amp;#x2F;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;文件中添加一个&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_one(x:i32) -&amp;amp;gt; i32 {
    x + 1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来可执行 crate 可以对库 crate 进行依赖，首先在需要引入依赖的 crate 的 toml 文件中，定义[dependencies]模块。指定库 crate 的路径。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[dependencies]

add-one = { path = &amp;amp;quot;..&amp;amp;#x2F;add-one&amp;amp;quot; }
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Cargo 不会对依赖进行解析，所以需要我们明确指定 crate 间的依赖关系。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来可以在&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;crate 中通过&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;引入&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;模块了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use add_one;

fn main() {
    let num = 10;
    println!(
        &amp;amp;quot;Hello, world! {} plus one is {}!&amp;amp;quot;,
        num,
        add_one::add_one(num)
    );
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;最后在根目录下运行&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;构建。使用&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;命令运行代码，使用&amp;lt;code&amp;gt;-p&amp;lt;&amp;#x2F;code&amp;gt;参数指定运行的包：&amp;lt;code&amp;gt;cargo run -p adder&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;yi-lai-wai-bu-bao&amp;quot;&amp;gt;依赖外部包&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;整个工作空间只有根目录下有&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;文件，这样保证所有包使用的外部依赖都是相同的版本。如果你在每个包目录下的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中都指定了外部依赖，Cargo 会将他们处理成统一的版本并记录在根目录下的&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;文件中。这样保证所有包使用的依赖都是兼容的。下面我们先在&amp;lt;em&amp;gt;add-one&amp;#x2F;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中添加一个&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;外部依赖。然后在文件中引用这个依赖并执行编译。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[dependencies]
rand = &amp;amp;quot;0.5.5&amp;amp;quot;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;  Updating crates.io index
Downloaded libc v0.2.76
 Compiling rand v0.5.6
 Compiling add-one v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;add&amp;amp;#x2F;add-one)
 Compiling adder v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;add&amp;amp;#x2F;adder)
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;现在根目录下的&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;已经有了&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;依赖&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;包的信息。尽管&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;包以及在工作空间内部使用了，但是在&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;以外的包中，引入&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;包还是会报错，除非我们在他们的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中也指定&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;依赖。此时&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;文件中也会记录&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;引用&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;的信息，但是不会重新下载多余的代码。这种方式既保证所有包都使用同一个版本的外部依赖，又不会因为代码拷贝从而对空间造成浪费。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;wei-gong-zuo-kong-jian-tian-jia-ce-shi&amp;quot;&amp;gt;为工作空间添加测试&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;为&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;包的公有方法添加一个测试用例&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_one(x: i32) -&amp;amp;gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;add_one-f0253159197f7841
running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;adder-d6b6ef1ba6873bae

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

  Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一块内容表示&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;包有一个测试用例被运行；第二块表示&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;包中没有测试用例可以执行；第三块表示&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;包中没有文档测试可以执行。在工作空间中执行测试，会将工作空间下所有包的测试用例都执行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;也可以使用&amp;lt;code&amp;gt;-p&amp;lt;&amp;#x2F;code&amp;gt;参数指定测试的包，与&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;使用方式一样。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果你要发布你的包，那么你需要对每个包分别执行发布操作，&amp;lt;code&amp;gt;cargo publish&amp;lt;&amp;#x2F;code&amp;gt;没有&amp;lt;code&amp;gt;--all&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;-p&amp;lt;&amp;#x2F;code&amp;gt;参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-shi-yong-cargo-installcong-crates-io-an-zhuang-ke-zhi-xing-wen-jian&amp;quot;&amp;gt;Section 4 - 使用&amp;lt;code&amp;gt;cargo install&amp;lt;&amp;#x2F;code&amp;gt;从 crates.io 安装可执行文件&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo install&amp;lt;&amp;#x2F;code&amp;gt;命令可以让你在本地下载和使用可执行 crate。只能安装带有可执行编译目标的包。可执行编译目标是由具有&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，或者其他被指定为可执行文件的包，编译而来的可执行程序。相对应的库 crate 则不能独立运行，只能被其他 crate 引用。通常 crate 都会又 README 文件说明，crate 是可执行 crate 还是库 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;可执行文件被下载到安装目录的&amp;lt;em&amp;gt;bin&amp;lt;&amp;#x2F;em&amp;gt;目录下，如果你没有进行过任何自定义配置，这个目录是$HOME&amp;#x2F;.cargo&amp;#x2F;bin。确保该路径被添加进&amp;lt;code&amp;gt;$PATH&amp;lt;&amp;#x2F;code&amp;gt;环境变量了，否则可能无法运行可执行文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-5-zi-ming-ling-kuo-zhan-cargo&amp;quot;&amp;gt;Section 5 - 子命令扩展 Cargo&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Cargo 被设计为你不需要修改 Cargo 本身就可以扩展很多子命令，如果你的&amp;lt;code&amp;gt;$PATH&amp;lt;&amp;#x2F;code&amp;gt;中有个可执行程序叫&amp;lt;code&amp;gt;cargo-something&amp;lt;&amp;#x2F;code&amp;gt;，你可以用类似子命令的方式运行它&amp;lt;code&amp;gt;cargo something&amp;lt;&amp;#x2F;code&amp;gt;。可以通过&amp;lt;code&amp;gt;cargo --list&amp;lt;&amp;#x2F;code&amp;gt;命令列出所有 cargo 扩展命令。使用&amp;lt;code&amp;gt;cargo install&amp;lt;&amp;#x2F;code&amp;gt;来安装这些可执行扩展，就像使用内置工具一样方便。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
        
        <entry>
            <title>Common Concepts</title>
            <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;01-common-concepts&#x2F;"/>
            <updated>2020-12-10T23:03:29+0800</updated>
            <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;01-common-concepts&#x2F;</id>
            <content type="html">&amp;lt;h1 id=&amp;quot;chapter-1-common-concepts&amp;quot;&amp;gt;Chapter 1 - Common Concepts&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-variables-and-mutability&amp;quot;&amp;gt;Section 1 - Variables and Mutability&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;h3 id=&amp;quot;bian-liang-ding-yi&amp;quot;&amp;gt;变量定义&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 定义变量的方式&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 10
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 的变量默认是 Immutable，可通过&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字修改。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 10
x = 20 &amp;amp;#x2F;&amp;amp;#x2F;error: cannot assign twice to immutable variable

let mut x = 10
x = 20 &amp;amp;#x2F;&amp;amp;#x2F;success
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;immutable-yu-const-de-qu-bie&amp;quot;&amp;gt;Immutable 与 const 的区别&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 变量默认不可重复赋值，const 常量同样也不允许重复赋值，这二者的区别在于：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;变量用&amp;lt;code&amp;gt;let&amp;lt;&amp;#x2F;code&amp;gt;关键字，常量用&amp;lt;code&amp;gt;const&amp;lt;&amp;#x2F;code&amp;gt;关键字。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;变量可以用&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字修饰，常量不行。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;常量初始化要带数据类型声明，例如：&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;const NUM:i32 = 10
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;常量可以在任何上下文中定义，变量不能在定义在全局上下文中。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;常量大部分情况下只用于常量赋值表达式，而不会用于赋值函数运算结果等运行时计算的表达式。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h3 id=&amp;quot;bian-liang-fu-gai-shadows&amp;quot;&amp;gt;变量覆盖（Shadows）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;let 关键字可重复声明同一变量名，后声明的会覆盖之前声明的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;

let x = x + 1;

println!(&amp;amp;quot;The value of x is: {}&amp;amp;quot;, x);

let x = x * 2;

println!(&amp;amp;quot;The value of x is: {}&amp;amp;quot;, x);

&amp;amp;#x2F;&amp;amp;#x2F; output
&amp;amp;#x2F;&amp;amp;#x2F; The value of x is: 6
&amp;amp;#x2F;&amp;amp;#x2F; The value of x is: 12
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;之前提到，设置一个变量 mutable 可以用关键字&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;，可以对其进行重复赋值。变量覆盖看起来功能相似，但是它在改变了变量值的同时，保持了 Rust 的 Immutable 特性，其安全性没有降低。另外，变量覆盖本质上是定义了一个新的变量，因此我们可以用同一个变量名但是使用不同的数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;

println!(&amp;amp;quot;{}&amp;amp;quot;, x);

let x = &amp;amp;quot;string&amp;amp;quot;;

println!(&amp;amp;quot;{}&amp;amp;quot;, x);

&amp;amp;#x2F;&amp;amp;#x2F;output
&amp;amp;#x2F;&amp;amp;#x2F; 5
&amp;amp;#x2F;&amp;amp;#x2F; string
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-data-types&amp;quot;&amp;gt;Section 2 - Data Types&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;h3 id=&amp;quot;zheng-xing-integer&amp;quot;&amp;gt;整型（Integer）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Length&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Signed&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Unsigned&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;&amp;lt;&amp;#x2F;thead&amp;gt;&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;8-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i8&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u8&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;16-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i16&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u16&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;32-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i32&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u32&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;64-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i64&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u64&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;128-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i128&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u128&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;arch&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;isize&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;usize&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;tbody&amp;gt;&amp;lt;&amp;#x2F;table&amp;gt;
&amp;lt;p&amp;gt;无符号整型范围：0 ~ $2^n - 1$，有符号整型范围：$-2^{n-1}$ ~ $2^{n-1} - 1$&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;zheng-xing-zi-mian-liang&amp;quot;&amp;gt;整型字面量&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Number&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;literals Example&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;&amp;lt;&amp;#x2F;thead&amp;gt;&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Decimal&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;98_222&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Hex&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;0xff&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Octal&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;0o77&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Binary&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;0b1111_0000&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Byte&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;(u8 only) b’A’&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;tbody&amp;gt;&amp;lt;&amp;#x2F;table&amp;gt;
&amp;lt;p&amp;gt;:::tip 溢出（Integer Overflow）
当发生整型溢出，debug 模式程序会报错退出，release 编译模式会将高位截断（&amp;lt;code&amp;gt;u8&amp;lt;&amp;#x2F;code&amp;gt;256 -&amp;amp;gt; 0）。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fu-dian-floating-point&amp;quot;&amp;gt;浮点（Floating—Point）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;浮点数表示遵循 IEEE-754 标准，浮点数有两种基本类型&amp;lt;code&amp;gt;f32&amp;lt;&amp;#x2F;code&amp;gt;单精度浮点和&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;双精度浮点，Rust 默认是&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;，因为在现代 cpu 中，&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;的运算速度和&amp;lt;code&amp;gt;f32&amp;lt;&amp;#x2F;code&amp;gt;相当，同时具有更高的精度。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;bu-er-boolean&amp;quot;&amp;gt;布尔（Boolean）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;只有&amp;lt;code&amp;gt;true&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;false&amp;lt;&amp;#x2F;code&amp;gt;两个值，大小为 1byte。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zi-fu-character&amp;quot;&amp;gt;字符（Character）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;用单引号表示 char 类型（双引号是 string），大小为 4byte，为 Unicode 编码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;yuan-zu-tuple&amp;quot;&amp;gt;元组（Tuple）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;元组是常用的将一组数字类型（浮点、整型）的数据组合的类型，不可动态扩容。解构元组时定义的变量要和元组的数据量对应，或者用&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位，也可以通过索引访问。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
&amp;amp;#x2F;&amp;amp;#x2F; tuple声明
let x = (1,2,3);
&amp;amp;#x2F;&amp;amp;#x2F; 解构
let (a, b, c) = x;

let (a, _, _) = x;
let (_, b, _) = x;
let (_, _, c) = x;

let first = x.0;
let second = x.1;
let third = x.2;

&amp;amp;#x2F;&amp;amp;#x2F;let (a, b) = x; error
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shu-zu-array&amp;quot;&amp;gt;数组（Array）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;数组中的元素类型必须一致，不可动态扩容。与 Vector 不同，Vector 是标准库提供的一种数据存储结构，支持动态扩容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h5 id=&amp;quot;shu-zu-ding-yi-fang-shi&amp;quot;&amp;gt;数组定义方式&amp;lt;&amp;#x2F;h5&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; 编译器推断类型和数量
let x = [1, 2, 3];
&amp;amp;#x2F;&amp;amp;#x2F; 指定类型和数量
let x:[i32; 3] = [1, 2, 3];
&amp;amp;#x2F;&amp;amp;#x2F; 所有元素都是相同的
let x = [3; 5];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;shu-zu-fang-wen&amp;quot;&amp;gt;数组访问&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;通过下标的形式，不允许越界。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;x[0]

x[5] &amp;amp;#x2F;&amp;amp;#x2F;error bounds:
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-functions&amp;quot;&amp;gt;Section 3 - Functions&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;函数由&amp;lt;code&amp;gt;fn&amp;lt;&amp;#x2F;code&amp;gt;关键字、函数名、参数列表（parameters）、返回类型、作用域块组成。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
println!(&amp;amp;quot;Hello, world!&amp;amp;quot;);

another_function();
}

fn another_function() {
println!(&amp;amp;quot;Another function.&amp;amp;quot;);
}

&amp;amp;#x2F;&amp;amp;#x2F; output
&amp;amp;#x2F;&amp;amp;#x2F; Hello, world!
&amp;amp;#x2F;&amp;amp;#x2F; Another function.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 对声明顺序不敏感，调用的函数只要有声明就行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-can-shu&amp;quot;&amp;gt;函数参数&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数的参数列表是函数声明的一部分，参数列表多个参数用逗号分割。形参（parameters），实参（arguments）。函数参数列表（parameters）必须指明参数类型&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-ti&amp;quot;&amp;gt;函数体&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数体由表达式（expression）结尾的一系列语句（statement）组成。statement 表示执行某些操作，不会返回值；expression 会进行计算并返回值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = (let y = 6);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;以上代码会报错，&amp;lt;code&amp;gt;let y = 6&amp;lt;&amp;#x2F;code&amp;gt;是一个声明语句（statement），statement 是不能作为赋值语句的右值的，因为赋值语句的右值必须能返回值赋给左值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;函数调用和作用域块都是表达式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; function invoke
let y = func();

&amp;amp;#x2F;&amp;amp;#x2F; block scope
let y = {
let x = 3;
x + 1
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意 x + 1 后面没有分号，这也是表达式和语句的区别，语句都以分号结尾，而表达式不包含分号。表达式加分号会成为语句。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;:::tip tip
Rust 中有一个空类型&amp;lt;code&amp;gt;()&amp;lt;&amp;#x2F;code&amp;gt;，所有语句和没有返回值的函数，Rust 会自动返回空类型。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-fan-hui-zhi&amp;quot;&amp;gt;函数返回值&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数返回类型定义在参数列表（parameters）之后。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn func() -&amp;amp;gt; i32 {
1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 在函数体最后可以用表达式代替 return 关键字返回值（该表达式不能加分号，否则会变成语句，且该表达式只能位于函数体最后）。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-comments&amp;quot;&amp;gt;Section 4 - Comments&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;注释，对代码加以说明，起辅助作用，给人读的内容而不是机器。用&amp;lt;code&amp;gt;&amp;#x2F;&amp;#x2F;&amp;lt;&amp;#x2F;code&amp;gt;开头，不能跨行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; 一行注释
let a = 10;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h2 id=&amp;quot;section-5-control-flow&amp;quot;&amp;gt;Section 5 - Control Flow&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;h3 id=&amp;quot;if-tiao-jian-biao-da-shi&amp;quot;&amp;gt;if 条件表达式&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;由关键字&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;开始，后面紧跟一个条件表达式，该表达式返回值只能是&amp;lt;code&amp;gt;boolean&amp;lt;&amp;#x2F;code&amp;gt;类型。之后跟一个作用域块，条件不匹配时使用&amp;lt;code&amp;gt;else&amp;lt;&amp;#x2F;code&amp;gt;关键字，后面接一个作用域块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let number = 3;

if number &amp;amp;lt; 5 {
println!(&amp;amp;quot;condition was true&amp;amp;quot;);
} else {
println!(&amp;amp;quot;condition was false&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;duo-tiao-jian-shi-yong-else-if&amp;quot;&amp;gt;多条件时用&amp;lt;code&amp;gt;else if&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let number = 6;

if number % 4 == 0 {
println!(&amp;amp;quot;number is divisible by 4&amp;amp;quot;);
} else if number % 3 == 0 {
println!(&amp;amp;quot;number is divisible by 3&amp;amp;quot;);
} else if number % 2 == 0 {
println!(&amp;amp;quot;number is divisible by 2&amp;amp;quot;);
} else {
println!(&amp;amp;quot;number is not divisible by 4, 3, or 2&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;zai-letyu-ju-zhong-shi-yong-if-biao-da-shi&amp;quot;&amp;gt;在&amp;lt;code&amp;gt;let&amp;lt;&amp;#x2F;code&amp;gt;语句中使用 if 表达式&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;由于 if 是一个表达式，所以它可以用于 let 语句的右值。这种情况下，if 表达式各条件分支返回的数据类型必须一致，这是因为在编译阶段 Rust 必须确定变量的类型，编译器不支持运行时动态确定变量类型，这样会使编译器更加复杂并且安全性降低。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let condition = true;
let number = if condition { 5 } else { 6 };

let number = if condition { 5 } else { &amp;amp;quot;six&amp;amp;quot; };
&amp;amp;#x2F;&amp;amp;#x2F; error if and else have incompatible types
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;xun-huan&amp;quot;&amp;gt;循环&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 有三种执行循环的方式，&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;,&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;loop&amp;quot;&amp;gt;loop&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;loop {
&amp;amp;#x2F;&amp;amp;#x2F; do something
if condition {
break &amp;amp;#x2F;&amp;amp;#x2F;something
}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;循环执行同一段代码块。可以通过 break 关键字从&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;循环中返回一个值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;while&amp;quot;&amp;gt;while&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
let mut number = 3;

while number != 0 {
println!(&amp;amp;quot;{}!&amp;amp;quot;, number);

number -= 1;
}

println!(&amp;amp;quot;LIFTOFF!!!&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;循环整合了&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;else&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;break&amp;lt;&amp;#x2F;code&amp;gt;的功能，让代码块更清晰，没有很深的嵌套。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h5 id=&amp;quot;for&amp;quot;&amp;gt;for&amp;lt;&amp;#x2F;h5&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
let a = [10, 20, 30, 40, 50];

for element in a.iter() {
println!(&amp;amp;quot;the value is: {}&amp;amp;quot;, element);
}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;用来遍历集合中的元素。同&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;通过下标访问的方式相比，&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;更快更安全，原因在于：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;编译器会加入 runtime 代码，在每次&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;循环时检查循环条件。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;通过下标访问难免出现越界和遗漏等 bug。
基于以上优点，&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环使用的频率最高，就算在非遍历集合的场景下。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
for number in (1..4).rev() {
println!(&amp;amp;quot;{}!&amp;amp;quot;, number);
}
println!(&amp;amp;quot;LIFTOFF!!!&amp;amp;quot;);
}
&amp;amp;#x2F;&amp;amp;#x2F; 3!
&amp;amp;#x2F;&amp;amp;#x2F; 2!
&amp;amp;#x2F;&amp;amp;#x2F; 1!
&amp;amp;#x2F;&amp;amp;#x2F; LIFTOFF!!!
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面代码中&amp;lt;code&amp;gt;(1..4)&amp;lt;&amp;#x2F;code&amp;gt;是标准库中的&amp;lt;code&amp;gt;Range&amp;lt;&amp;#x2F;code&amp;gt;类型。按顺序生成&amp;lt;strong&amp;gt;左闭右开&amp;lt;&amp;#x2F;strong&amp;gt;的集合序列，可以通过&amp;lt;code&amp;gt;rev&amp;lt;&amp;#x2F;code&amp;gt;方法进行逆转。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
        </entry>
        
    
    
    
        
        
            
            <entry>
                <title>Writing Automated Tests</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;09-write-tests&#x2F;"/>
                <updated>2021-08-16T04:00:31+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;09-write-tests&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-9-writing-automated-tests&amp;quot;&amp;gt;Chapter 9 - Writing Automated Tests&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;程序的正确性是它按我们的预期运行的程度。Rust 被设计为高度关注程序正确性的语言，但正确性很复杂而且不容易实现。Rust 的类型系统承担了大部分的工作，但是类型系统不能够捕获所有可能的错误。因此，Rust 支持编写自动测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-ru-he-bian-xie-ce-shi-yong-li&amp;quot;&amp;gt;Section - 1 如何编写测试用例&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;测试用例是用来验证代码是否按预期设计运行的函数。测试用例通常包含三部分：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;初始化需要的数据和状态。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;运行需要测试的代码。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;断言结果是否正确。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ol&amp;gt;
&amp;lt;p&amp;gt;接下来看一下 Rust 为编写测试用例特别提供的功能。包括&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;属性，一些宏和&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;属性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;the-anatomy-of-a-test-function&amp;quot;&amp;gt;The Anatomy of a Test Function&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;最简单的情况，Rust 中一个测试用例就是一个带&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;属性的函数。属性是关于代码片段的元数据。在函数定义前加一行&amp;lt;code&amp;gt;#[test]&amp;lt;&amp;#x2F;code&amp;gt;，这个函数就是测试用例函数。然后当你执行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;，Rust 创建一个用来执行测试用例的可执行文件，这个文件会调用被&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;属性标记的函数，并且报告这些测试的结果是成功还是失败。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当我们使用&amp;lt;code&amp;gt;Cargo&amp;lt;&amp;#x2F;code&amp;gt;创建库项目时，会自动生成一个测试模块，你可以自己添加其他的测试模块和函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;首先创建一个库项目。&amp;lt;code&amp;gt;cargo new adder --lib&amp;lt;&amp;#x2F;code&amp;gt;。然后可以看到默认创建好的测试模块和用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;先把注意力集中到测试用例上。函数上面一行的&amp;lt;code&amp;gt;#[test]&amp;lt;&amp;#x2F;code&amp;gt;表明这个函数是一个测试用例，test runner 会在测试的时候执行这个函数。测试模块中也可以包含普通的函数，用于初始化或者提供普通的操作。因此需要在测试用例前用属性指明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;函数体中使用到了&amp;lt;code&amp;gt;assert_eq!&amp;lt;&amp;#x2F;code&amp;gt;宏。这个断言是一个典型的测试用例。运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;会得到以下输出信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;$ cargo test
Compiling adder v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;rust_learn&amp;amp;#x2F;adder)
 Finished test [unoptimized + debuginfo] target(s) in 0.57s
  Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到在&amp;lt;code&amp;gt;running 1 test&amp;lt;&amp;#x2F;code&amp;gt;这一行下面，显示运行了一个测试用例&amp;lt;code&amp;gt;it_works&amp;lt;&amp;#x2F;code&amp;gt;，并且运行结果是&amp;lt;code&amp;gt;ok&amp;lt;&amp;#x2F;code&amp;gt;。测试用例的运行结果汇总统计在下面一行。&amp;lt;code&amp;gt;test result: ok&amp;lt;&amp;#x2F;code&amp;gt;表示所有的测试用例都通过了测试，并且后面&amp;lt;code&amp;gt;1 passed; 0 failed;&amp;lt;&amp;#x2F;code&amp;gt;统计了成功和失败的数量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;测试输出的下一个部分是&amp;lt;code&amp;gt;Doc-tests&amp;lt;&amp;#x2F;code&amp;gt;，这个是文档测试的结果。我们这里没有文档测试，Rust 能在 API 文档里生成示例代码。这个功能让代码和文档保持同步。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;再添加一个失败结果的测试用例。每一个测试用例都跑在单独的线程中，主线程如果发现有一个测试线程失败，就把测试结果标记为失败。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&amp;amp;quot;Make this test fail&amp;amp;quot;);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;再运行测试用例，会得到如下输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::it_works ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
thread &amp;amp;#x27;tests::another&amp;amp;#x27; panicked at &amp;amp;#x27;Make this test fail&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到有两块&amp;lt;code&amp;gt;failures&amp;lt;&amp;#x2F;code&amp;gt;内容是之前没有的。第一部分是失败用例的文件路径和产生错误的代码位置。第二块是失败的用例名列表，当失败的用例非常多时，这个列表就很有用了。我们可以通过单独运行某个用例获取更多的错误信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面的摘要行显示，测试结果是&amp;lt;code&amp;gt;FAILED&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;yong-assert-hong-duan-yan-jie-guo&amp;quot;&amp;gt;用&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏断言结果&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏是由标准库提供的，用于在测试中确定运行结果是否为真。&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;一个返回布尔值的表达式。如果返回值是&amp;lt;code&amp;gt;true&amp;lt;&amp;#x2F;code&amp;gt;，它不会做任何特殊处理，并且该测试用例结果为&amp;lt;code&amp;gt;ok&amp;lt;&amp;#x2F;code&amp;gt;。如果为&amp;lt;code&amp;gt;false&amp;lt;&amp;#x2F;code&amp;gt;，它会调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏来让测试用例失败。使用&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;断言来检测函数是否按照我们的预期设计执行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面写一些测试用例，用来测试之前章节中定义的&amp;lt;code&amp;gt;Rectangle&amp;lt;&amp;#x2F;code&amp;gt;结构体。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;amp;amp;self, other: &amp;amp;amp;Rectangle) -&amp;amp;gt; bool {
        self.width &amp;amp;gt; other.width &amp;amp;amp;&amp;amp;amp; self.height &amp;amp;gt; other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;amp;amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;amp;amp;larger));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意在测试模块中引入了待测试模块的命名空间。测试模块跟普通模块一样，也要遵循命名空间规则。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-assert-eq-he-assert-ne-duan-yan-xiang-deng-xing&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;assert_eq!&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;assert_ne!&amp;lt;&amp;#x2F;code&amp;gt;断言相等性&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;判断相等性可以在&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏中传入一个&amp;lt;code&amp;gt;==&amp;lt;&amp;#x2F;code&amp;gt;表达式。但是由于这种判断是一个常用场景，因此标准库提供了专门用来判断相等性的宏。这两个宏接收两个参数来判断它们是否相等。断言失败时它们会打印出参数值，可以更清楚的知道测试用例为什么失败。而&amp;lt;code&amp;gt;assert!&amp;lt;&amp;#x2F;code&amp;gt;宏的话，只能表示它的参数&amp;lt;code&amp;gt;==&amp;lt;&amp;#x2F;code&amp;gt;表达式返回了一个&amp;lt;code&amp;gt;false&amp;lt;&amp;#x2F;code&amp;gt;，而不能确定导致它失败的具体参数是什么。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;比如写一个函数，将它的参数+2。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_two(a:i32) -&amp;amp;gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
    #[test]
    fn it_adds_three() {
        assert_eq!(5, add_two(2));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;测试用例运行结果为如下&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::it_adds_two ... ok
test tests::it_adds_three ... FAILED

failures:

---- tests::it_adds_three stdout ----
thread &amp;amp;#x27;tests::it_adds_three&amp;amp;#x27; panicked at &amp;amp;#x27;assertion failed: `(left == right)`
left: `5`,
right: `4`&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:16:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_three

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一个用例通过。第二个用例，由于我们断言传的参数&amp;lt;code&amp;gt;add_two&amp;lt;&amp;#x2F;code&amp;gt;的结果为 5，因此测试结果为失败。并且指出它的错误原因是左右值不想等，且&amp;lt;code&amp;gt;left&amp;lt;&amp;#x2F;code&amp;gt;是 5，&amp;lt;code&amp;gt;right&amp;lt;&amp;#x2F;code&amp;gt;是 4。一些测试框架和语言中，可能把相等性判断的两个参数称为&amp;lt;code&amp;gt;expected&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;actual&amp;lt;&amp;#x2F;code&amp;gt;。Rust 中称为&amp;lt;code&amp;gt;left&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;right&amp;lt;&amp;#x2F;code&amp;gt;。参数传递的顺序对测试结果没有影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;assert_ne!&amp;lt;&amp;#x2F;code&amp;gt;宏跟它的作用一样，逻辑相反。一般 ne 函数用于那些我们不确定结果是什么值，但是可以确定结果不该是某个值的情况下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在接口底层，&amp;lt;code&amp;gt;assert_eq!&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;assert_ne!&amp;lt;&amp;#x2F;code&amp;gt;分别使用的是&amp;lt;code&amp;gt;==&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;!=&amp;lt;&amp;#x2F;code&amp;gt;运算符。当测试不通过时，这些宏通过 debug 格式化来打印参数信息，也就是说用于比较的参数值必须实现&amp;lt;code&amp;gt;PartialEq&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Debug&amp;lt;&amp;#x2F;code&amp;gt;两个 trait。所有基础类型和大部分标准库提供的类型都实现了这两个 trait。你自己定义的 struct 和 enum，需要你自己实现&amp;lt;code&amp;gt;PartialEq&amp;lt;&amp;#x2F;code&amp;gt;trait 来定义相等性。如果你需要测试不通过时打印参数信息，你还需要实现&amp;lt;code&amp;gt;Debug&amp;lt;&amp;#x2F;code&amp;gt;模块。由于这两个模块都是可派生模块，可以直接在自定义的 struct 和 enum 前面加&amp;lt;code&amp;gt;#[derive(PartialEq, Debug)]&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;tian-jia-zi-ding-yi-cuo-wu-xin-xi&amp;quot;&amp;gt;添加自定义错误信息&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏语法，将错误信息加在断言函数的最后。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn greeting(name: &amp;amp;amp;str) -&amp;amp;gt; String {
    String::from(&amp;amp;quot;Hello!&amp;amp;quot;)
}
&amp;amp;#x2F;&amp;amp;#x2F; 省略
assert!(
    result.contains(&amp;amp;quot;Carol&amp;amp;quot;),
    &amp;amp;#x2F;&amp;amp;#x2F; 错误信息
    &amp;amp;quot;Greeting did not contain name, value was `{}`&amp;amp;quot;,
    result
);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;checking-for-panics-with-should-panic&amp;quot;&amp;gt;Checking for Panics with should_panic&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;属性来检测，代码是不是按照预期发生了 panic。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&amp;amp;gt; Guess {
        if value &amp;amp;lt; 1 || value &amp;amp;gt; 100 {
            panic!(&amp;amp;quot;Guess value must be between 1 and 100, got {}.&amp;amp;quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;运行结果为 ok。我们传的值是 200，符合 panic 的条件，因此函数调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏。这个错误被&amp;lt;code&amp;gt;#[should_panic]&amp;lt;&amp;#x2F;code&amp;gt;捕获到了，测试结果跟我们预期的一样，因此它是一个成功的测试用例。换句话说，&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;只用来检测那些会 panic 的情况，如果没有发生 panic，那么这个用例就是失败。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;仅使用&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;来检测 panic 不是很精确，因为可能代码中 panic 没有携带有用信息。&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;可以接收参数，在 panic 发生时，这个参数会跟错误信息一起打印出来。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zai-ce-shi-yong-li-zhong-shi-yong-result-t-e&amp;quot;&amp;gt;在测试用例中使用&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;可以在测试用例中&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;来替代断言宏。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&amp;amp;gt; Result&amp;amp;lt;(), String&amp;amp;gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&amp;amp;quot;two plus two does not equal four&amp;amp;quot;))
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个测试用例返回一个&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;。同时可以在测试用例内部使用问号操作符。当使用&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;时，不能使用&amp;lt;code&amp;gt;should_panic&amp;lt;&amp;#x2F;code&amp;gt;属性，此时必须显式地返回一个&amp;lt;code&amp;gt;Err&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-controlling-how-tests-are-run&amp;quot;&amp;gt;Section 2 - Controlling How Tests Are Run&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;编译代码并且运行结果可执行文件，同样的，&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;在测试模式编译代码然后运行测试用例可执行文件。你可以通过指定命令参数，来改变&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;的默认行为。&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;编译生成的可执行文件的默认行为是：并行运行所有测试用例，捕获测试用例的输出信息，并加工成跟测试用例相关联的，阅读友好的输出信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;某些命令行参数是给&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;执行的，而某些是给编译完的可执行文件执行的。为了区分这两种类型的参数，用于&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;执行的参数跟在&amp;lt;code&amp;gt;--&amp;lt;&amp;#x2F;code&amp;gt;后面，然后后面再跟的是给可执行文件执行的参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;bing-xing-he-chuan-xing&amp;quot;&amp;gt;并行和串行&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当执行多个测试用例，默认的行为是多线程并行执行。因此测试代码可以最快运行完毕并且输出测试反馈。由于每个测试用例是单独一个线程的，所以保证每个用例是独立的，没有共享状态或者共享环境等。比如多个测试用例是对一个文件进行读写，当并发进行时，有可能进程 A 在读的时候，文件被进程 B 覆盖了，导致进程 A 测试失败。然而这并不是由于逻辑代码引起的错误。解决方法是所有测试用例隔离测试环境，或者串行测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;用参数&amp;lt;code&amp;gt;cargo test -- --test-threads=1&amp;lt;&amp;#x2F;code&amp;gt;指定执行的线程数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;xian-shi-bei-ce-shi-han-shu-de-shu-chu-xin-xi&amp;quot;&amp;gt;显示被测试函数的输出信息&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;默认情况下，Rust 会将测试通过用例下的函数输出信息全部捕获，只输出测试通过的信息。而测试用例失败时，所有信息信息都会被输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;
fn prints_and_returns_10(a: i32) -&amp;amp;gt; i32 {
    println!(&amp;amp;quot;I got the value {}&amp;amp;quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;默认测试上面的代码。输出以下信息&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread &amp;amp;#x27;main&amp;amp;#x27; panicked at &amp;amp;#x27;assertion failed: `(left == right)`
left: `5`,
right: `10`&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;cargo test -- --show-output&amp;lt;&amp;#x2F;code&amp;gt;参数，输出测试用例信息以及函数本身的输出信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread &amp;amp;#x27;main&amp;amp;#x27; panicked at &amp;amp;#x27;assertion failed: `(left == right)`
left: `5`,
right: `10`&amp;amp;#x27;, src&amp;amp;#x2F;lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &amp;amp;#x27;--lib&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;running-a-subset-of-tests-by-name&amp;quot;&amp;gt;Running a Subset of Tests by Name&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过指定测试用例名称来运行特定的测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_two(a: i32) -&amp;amp;gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;默认运行测试用例&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时，所有的用例都会被执行：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;yun-xing-dan-ge-ce-shi&amp;quot;&amp;gt;运行单个测试&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo test [test_name]&amp;lt;&amp;#x2F;code&amp;gt;，例如&amp;lt;code&amp;gt;cargo test one_hundred&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到输出信息中说明&amp;lt;code&amp;gt;2 filtered out&amp;lt;&amp;#x2F;code&amp;gt;，有两个用例被过滤掉了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;yun-xing-duo-ge-ce-shi&amp;quot;&amp;gt;运行多个测试&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们可以在指定测试用例名称时，只指定其中的一部分名称。Rust 会运行所有名称包含我们参数的测试用例。例如&amp;lt;code&amp;gt;cargo test add&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;有两个用例名称包含 add，所以他们都被运行了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mo-ren-guo-lu-mou-xie-yong-li-chu-fei-ming-que-zhi-ding&amp;quot;&amp;gt;默认过滤某些用例除非明确指定&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在测试用例前加&amp;lt;code&amp;gt;ignore&amp;lt;&amp;#x2F;code&amp;gt;参数来默认跳过该用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    &amp;amp;#x2F;&amp;amp;#x2F; code that takes an hour to run
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时，输出如下&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看出&amp;lt;code&amp;gt;expensive_test&amp;lt;&amp;#x2F;code&amp;gt;显示被跳过了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;增加&amp;lt;code&amp;gt;cargo test -- --ignore&amp;lt;&amp;#x2F;code&amp;gt;参数，运行有&amp;lt;code&amp;gt;ignore&amp;lt;&amp;#x2F;code&amp;gt;属性的测试用例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以将一些耗时任务标记为&amp;lt;code&amp;gt;ignore&amp;lt;&amp;#x2F;code&amp;gt;单独执行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-test-organization&amp;quot;&amp;gt;Section 3 - Test Organization&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 社区认为测试主要分为：单元测试和集成测试。单元测试更小更集中，同一时间只隔离测试一个模块，并且可以测试私有接口。集成测试更系统化，包含范围可能延展到我们整个库，且仅测试公有接口。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;dan-yuan-ce-shi&amp;quot;&amp;gt;单元测试&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;单元测试的目的是为了在隔离环境下快速地测试某个单一模块是否能按预期运行。单元测试放在 src 目录下的每个文件中，里面包含要测试的代码。最方便的方法是每个文件中都创建一个 test 模块，并且带测试模块前加&amp;lt;code&amp;gt;#[cfg(test)]&amp;lt;&amp;#x2F;code&amp;gt;注释。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;the-tests-module-and-cfg-test&amp;quot;&amp;gt;The Tests Module and #[cfg(test)]&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;#[cfg(test)]&amp;lt;&amp;#x2F;code&amp;gt;注释告诉编译器，只有当运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;命令时，才进行这些测试用例，&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;的时候不运行这些测试用例。这样可以缩短编译时间，而且不包含测试用例代码，也控制了编译结果文件的大小。由于集成测试在其他的目录中，所以不需要这个注释。由于单元测试和逻辑代码是在一起的，因此需要将他们标记，不要构建到最终的结果中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前我们新建 lib 项目时，cargo 自动生成了一个测试模块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cfg&amp;lt;&amp;#x2F;code&amp;gt;代表配置并且告诉编译器下面的内容只有满足了该配置时，才会被编译。在这个例子中，模块配置是&amp;lt;code&amp;gt;test&amp;lt;&amp;#x2F;code&amp;gt;，这是 Rust 提供的用来编译和执行测试用例的。只有当我们运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时 Cargo 才会编译该测试代码。除了测试模块下的测试用例不会被编译，其他的一些帮助函数也不会被编译。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;testing-private-functions&amp;quot;&amp;gt;Testing Private Functions&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;社区一直有争论，私有接口应不应该直接去测试私有接口。其他语言测试私有接口是很困难的。不论你持何种观念，Rust 私有规则都允许你直接测试私有接口。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_two(a: i32) -&amp;amp;gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&amp;amp;gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;internal_adder&amp;lt;&amp;#x2F;code&amp;gt;函数没有&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字，但是依然可以在&amp;lt;code&amp;gt;tests&amp;lt;&amp;#x2F;code&amp;gt;模块中引入测试。Rust 不强制测试私有接口。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;ji-cheng-ce-shi&amp;quot;&amp;gt;集成测试&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 中的集成测试代码完全处于你的库之外。集成测试调用库的方式和其他代码一样，也就是说集成测试可以只调用部分 API。集成测试的目的是检测你的库中多个模块一起工作时正确与否。即使单元测试通过，集成测试有可能也会出现问题。创建集成测试首先需要创建&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;tests-mu-lu&amp;quot;&amp;gt;tests 目录&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;在于&amp;lt;em&amp;gt;src&amp;lt;&amp;#x2F;em&amp;gt;目录同级的根目录下创建&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录，Cargo 会在这个目录下查找集成测试文件。然后可以任意在这个目录下添加测试文件，Cargo 会将这些文件编译成独立的 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;让我们来创建一个集成测试目录，并创建一个新文件&amp;lt;em&amp;gt;tests&amp;#x2F;integration_test.rs&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个文件中的代码不需要用&amp;lt;code&amp;gt;#[cfg(test)]&amp;lt;&amp;#x2F;code&amp;gt;标注，Rust 会对&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录下的文件特殊处理，只有运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;的时候才会编译这个目录下的文件。运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;看下效果。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;  Compiling adder v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;rust_learn&amp;amp;#x2F;adder)
   Finished test [unoptimized + debuginfo] target(s) in 1.07s
    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;adder-9d658908b5cc4b63

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;integration_test-48170a4e87fe33c4

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

    Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到有三块内容输出：单元测试、集成测试和文档测试。使用&amp;lt;code&amp;gt;--test &amp;amp;lt;testname&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;可以仅执行某部分集成测试。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;submodules-in-integration-tests&amp;quot;&amp;gt;Submodules in Integration Tests&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当你的集成测试越来越多时，你可能想要把这些测试组织到&amp;lt;em&amp;gt;test&amp;lt;&amp;#x2F;em&amp;gt;目录下不同的文件中。比如，可以按照测试的函数功能来组织测试用例。之前已经提到过，集成测试会被编译成单独的 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;把集成测试当作独立的 crate，有助于创建独立的作用域，让集成测试的场景更接近其他用户调用你的 crate 的真实场景。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当我们在&amp;lt;em&amp;gt;tests&amp;lt;&amp;#x2F;em&amp;gt;目录下，想抽象一些通用代码供各个集成测试调用时，Rust 会把这写通用代码也当作集成测试编译成单独的 crate。例如，创建&amp;lt;em&amp;gt;tests&amp;#x2F;common.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，并写入一个&amp;lt;code&amp;gt;setup&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn setup() {
    &amp;amp;#x2F;&amp;amp;#x2F; something
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;时，会发现测试结果输出多了一块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;common.rs&amp;lt;&amp;#x2F;em&amp;gt;中的内容被当作测试用例执行和打印不是我们想要的结果。我们只想它里面的代码供其他测试用例调用。可以通过创建&amp;lt;em&amp;gt;tests&amp;#x2F;mod&amp;#x2F;common.rs&amp;lt;&amp;#x2F;em&amp;gt;来代替，Rust 不会将这个目录下的文件当作集成测试来处理。此时，测试结果输出中也不会包含相应的内容了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当我们创建这个通用代码之后，就可以在其他集成测试文件中调用。例如：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;注意&amp;lt;code&amp;gt;mod common;&amp;lt;&amp;#x2F;code&amp;gt;的写法，之前讲过分号结尾是将该模块引入。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;h3 id=&amp;quot;integration-tests-for-binary-crates&amp;quot;&amp;gt;Integration Tests for Binary Crates&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果你的项目只有&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;，即你的项目是一个可执行 crate，此时不能创建集成测试。只有库 crate 才能创建集成测试，库 crate 导出的方法才能被其他 crate 用 use 导入和使用。可执行 crate 导出的函数只能内部使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这也是 Rust 项目在&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;文件中只调用&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;逻辑的原因之一。使用这种架构的话，集成测试来测试占绝大部分比例的库 crate 代码中的功能，而&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;中极少比例且几乎不含功能逻辑的调用代码不需要测试，仅需要阅读就可以判断其是否正确运行。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Error Handling</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;07-error-handling&#x2F;"/>
                <updated>2021-02-20T01:17:20+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;07-error-handling&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-7-error-handling&amp;quot;&amp;gt;Chapter 7 - Error Handling&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Rust 的可靠性之一就在于它的错误处理。在很多情况下，Rust 要求你在代码编译之前对所有可能的错误情况进行处理。在部署到生产环境之前确保发现并处理错误，这让你的代码健壮性更强。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 将错误分为两个大类：&amp;lt;em&amp;gt;recoverable&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;unrecoverable&amp;lt;&amp;#x2F;em&amp;gt;。前者例如读取不存在的文件，将该错误上报并且重试这个操作是合理的行为。后者一半是由于代码逻辑 bug，例如数组越界访问。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;大多数语言不会对这两个大类进行区分，一般都是采用同一套解决方式，例如异常机制。Rust 没有异常机制，Rust 用&amp;lt;code&amp;gt;Result&amp;amp;lt;U,E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;处理 recoverable 类型的错误，用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏处理 unrecoverable 类型的错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-unrecoverable-errors-with-panic&amp;quot;&amp;gt;Section 1 - Unrecoverable Errors with panic!&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;当出现一些意料之外的错误，并且没有后续的处理逻辑或者不知道该如何处理时，Rust 有&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏。当&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏调用时，打印出错误信息，然后释放清空堆栈内存退出程序。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;:::details Unwinding the Stack or Aborting in Response to a Panic
一般来说，当 panic 发生后，Rust 会进入&amp;lt;em&amp;gt;unwinding&amp;lt;&amp;#x2F;em&amp;gt;阶段，它需要到堆栈顶部，开始遍历堆栈清空数据和函数，这是一个很费时的操作。另一种方案是&amp;lt;em&amp;gt;abort&amp;lt;&amp;#x2F;em&amp;gt;，即程序退出时 Rust 不会清空堆栈，而将这个操作交给操作系统。如果你需要你的项目编译结果尽可能小，你可以通过设置&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件来让你的程序为 abort 模式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;[profile.release]
panic = &amp;amp;#x27;abort&amp;amp;#x27;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面简单调用一下&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏来看一看它的输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    panic!(&amp;amp;quot;crash&amp;amp;quot;);
}
&amp;amp;#x2F;&amp;amp;#x2F; thread &amp;amp;#x27;main&amp;amp;#x27; panicked at &amp;amp;#x27;crash&amp;amp;#x27;, src&amp;amp;#x2F;main.rs:17:9
&amp;amp;#x2F;&amp;amp;#x2F; note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看到&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;输出了两行信息，第一行是错误信息和错误在源代码在文件中的位置。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在这个例子中，我们可以跟踪代码在对应的位置找到导致&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏调用的代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;using-a-panic-backtrace&amp;quot;&amp;gt;Using a &amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt; Backtrace&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以设置&amp;lt;code&amp;gt;RUST_BACKTRACE&amp;lt;&amp;#x2F;code&amp;gt;环境变量来获取发生错误的完整调用链路。它是一个函数的调用堆栈列表，从栈顶开始一直到我们自己的代码文件。这个链路中可能包含核心文件、标准库文件、其他你使用到的第三方模块代码。你所在文件那一行上面的内容是你的代码调用的文件，下面的内容是调用你代码的文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;stack backtrace:
    0: backtrace::backtrace::libunwind::trace
                at &amp;amp;#x2F;Users&amp;amp;#x2F;runner&amp;amp;#x2F;.cargo&amp;amp;#x2F;registry&amp;amp;#x2F;src&amp;amp;#x2F;github.com-1ecc6299db9ec823&amp;amp;#x2F;backtrace-0.3.46&amp;amp;#x2F;src&amp;amp;#x2F;backtrace&amp;amp;#x2F;libunwind.rs:86
    1: backtrace::backtrace::trace_unsynchronized
                at &amp;amp;#x2F;Users&amp;amp;#x2F;runner&amp;amp;#x2F;.cargo&amp;amp;#x2F;registry&amp;amp;#x2F;src&amp;amp;#x2F;github.com-1ecc6299db9ec823&amp;amp;#x2F;backtrace-0.3.46&amp;amp;#x2F;src&amp;amp;#x2F;backtrace&amp;amp;#x2F;mod.rs:66
    2: std::sys_common::backtrace::_print_fmt
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:78
    3: &amp;amp;lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&amp;amp;gt;::fmt
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:59
    4: core::fmt::write
                at src&amp;amp;#x2F;libcore&amp;amp;#x2F;fmt&amp;amp;#x2F;mod.rs:1076
    5: std::io::Write::write_fmt
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;io&amp;amp;#x2F;mod.rs:1537
    6: std::sys_common::backtrace::_print
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:62
    7: std::sys_common::backtrace::print
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;sys_common&amp;amp;#x2F;backtrace.rs:49
    8: std::panicking::default_hook::{{closure}}
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:198
    9: std::panicking::default_hook
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:218
    10: std::panicking::rust_panic_with_hook
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:486
    11: rust_begin_unwind
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:388
    12: core::panicking::panic_fmt
                at src&amp;amp;#x2F;libcore&amp;amp;#x2F;panicking.rs:101
    13: core::panicking::panic_bounds_check
                at src&amp;amp;#x2F;libcore&amp;amp;#x2F;panicking.rs:73
    14: &amp;amp;lt;usize as core::slice::SliceIndex&amp;amp;lt;[T]&amp;amp;gt;&amp;amp;gt;::index
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libcore&amp;amp;#x2F;slice&amp;amp;#x2F;mod.rs:2872
    15: core::slice::&amp;amp;lt;impl core::ops::index::Index&amp;amp;lt;I&amp;amp;gt; for [T]&amp;amp;gt;::index
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libcore&amp;amp;#x2F;slice&amp;amp;#x2F;mod.rs:2732
    16: &amp;amp;lt;alloc::vec::Vec&amp;amp;lt;T&amp;amp;gt; as core::ops::index::Index&amp;amp;lt;I&amp;amp;gt;&amp;amp;gt;::index
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;liballoc&amp;amp;#x2F;vec.rs:1942
    17: p::main
                at src&amp;amp;#x2F;main.rs:5
    18: std::rt::lang_start::{{closure}}
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:67
    19: std::rt::lang_start_internal::{{closure}}
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:52
    20: std::panicking::try::do_call
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:297
    21: std::panicking::try
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panicking.rs:274
    22: std::panic::catch_unwind
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;panic.rs:394
    23: std::rt::lang_start_internal
                at src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:51
    24: std::rt::lang_start
                at &amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;.rustup&amp;amp;#x2F;toolchains&amp;amp;#x2F;stable-x86_64-apple-darwin&amp;amp;#x2F;lib&amp;amp;#x2F;rustlib&amp;amp;#x2F;src&amp;amp;#x2F;rust&amp;amp;#x2F;src&amp;amp;#x2F;libstd&amp;amp;#x2F;rt.rs:67
    25: main
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;为了获取这个输出，debug 标识必须是 enable 的，在运行&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;的并且不带&amp;lt;code&amp;gt;--release&amp;lt;&amp;#x2F;code&amp;gt;选项的时候，该标识默认是 enable 的。具体的输出内容和你的操作系统以及 Rust 版本有关。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-recoverable-errors-with-result&amp;quot;&amp;gt;Section 2 - Recoverable Errors with &amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;大多数错误抛出的时候，都没有必要将程序退出。比如，当读取的文件不存在时，可以考虑创建该文件而不是终止进程。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;枚举有两个值，&amp;lt;code&amp;gt;Ok&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Err&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Result&amp;amp;lt;T, E&amp;amp;gt; {
    Ok(T),
    Err(E),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;T 和 E 是泛型变量。T 代表成功情况下返回值的类型，E 代表失败情况下错误的返回类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如何知道&amp;lt;code&amp;gt;File::open&amp;lt;&amp;#x2F;code&amp;gt;函数返回的是一个&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;枚举呢？一种方式是查看标准库 API 文档，另外一种方式是给变量&amp;lt;code&amp;gt;f&amp;lt;&amp;#x2F;code&amp;gt;指定一个其他的数据类型。然后编译代码，编译器会给出类型不匹配的错误信息。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这里泛型变量&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;会被填充为成功值的类型，在这里是一个&amp;lt;code&amp;gt;std::fs::File&amp;lt;&amp;#x2F;code&amp;gt;类型的文件句柄，&amp;lt;code&amp;gt;E&amp;lt;&amp;#x2F;code&amp;gt;则是&amp;lt;code&amp;gt;std::io::Error&amp;lt;&amp;#x2F;code&amp;gt;类型。这意味着&amp;lt;code&amp;gt;File::open&amp;lt;&amp;#x2F;code&amp;gt;函数可能会返回一个文件句柄，可以用来进行读写。或者可能返回一个 io 错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因此我们需要用&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式对&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;的所有情况进行覆盖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);

    let f = match f {
        Ok(file) =&amp;amp;gt; file,
        Err(error) =&amp;amp;gt; panic!(&amp;amp;quot;Problem opening the file: {:?}&amp;amp;quot;, error),
    };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;matching-on-different-errors&amp;quot;&amp;gt;Matching on Different Errors&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;上面的代码，当打开文件出错时，不论何种错误都会调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏然后退出程序。而我们的期望时根据不同的错误类型，有不同的处理方案。比如因为文件不存在，我们希望创建文件；如果是因为没有权限，则调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏退出程序。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);

    let f = match f {
        Ok(file) =&amp;amp;gt; file,
        Err(error) =&amp;amp;gt; match error.kind() {
            ErrorKind::NotFound =&amp;amp;gt; match File::create(&amp;amp;quot;hello.txt&amp;amp;quot;) {
                Ok(fc) =&amp;amp;gt; fc,
                Err(e) =&amp;amp;gt; panic!(&amp;amp;quot;Problem creating the file: {:?}&amp;amp;quot;, e),
            },
            other_error =&amp;amp;gt; {
                panic!(&amp;amp;quot;Problem opening the file: {:?}&amp;amp;quot;, other_error)
            }
        },
    };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;File::open&amp;lt;&amp;#x2F;code&amp;gt;函数返回的是一个标准库提供的&amp;lt;code&amp;gt;io::Error&amp;lt;&amp;#x2F;code&amp;gt;类型的错误。这个类型上有一个&amp;lt;code&amp;gt;kind&amp;lt;&amp;#x2F;code&amp;gt;方法用来获取&amp;lt;code&amp;gt;io::ErrorKind&amp;lt;&amp;#x2F;code&amp;gt;类型的值。这个类型也由标准库提供，枚举了一些 io 操作可能出现的错误类型。我们想要在&amp;lt;code&amp;gt;ErrorKind::NotFound&amp;lt;&amp;#x2F;code&amp;gt;错误类型出现时，创建一个新文件。由于&amp;lt;code&amp;gt;File::create&amp;lt;&amp;#x2F;code&amp;gt;方法也有可能失败，所以也需要用&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式覆盖可能出现的情况。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;但是这里出现了太多的&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式嵌套。后面会介绍*闭包（closure）*的用法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shortcuts-for-panic-on-error-unwrap-and-expect&amp;quot;&amp;gt;Shortcuts for Panic on Error: &amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt; and &amp;lt;code&amp;gt;expect&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式能够满足需求。但是太多的&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;显得太啰嗦，表意也不够清晰。&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上有许多工具函数，其中一个叫做&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;的函数可以作为&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式的语法糖使用。如果是成功状态，&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;方法会返回值；如果是失败状态，&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;会调用&amp;lt;code&amp;gt;panic!&amp;lt;&amp;#x2F;code&amp;gt;宏。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;).unwrap();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;另外一个&amp;lt;code&amp;gt;expect&amp;lt;&amp;#x2F;code&amp;gt;方法，作用和&amp;lt;code&amp;gt;unwrap&amp;lt;&amp;#x2F;code&amp;gt;一样，但是可以让我们指定错误输出信息。可以表达我们想表达的错误信息，在错误追踪时也比较容易。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;

fn main() {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;).expect(&amp;amp;quot;Failed to open hello.txt&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;propagating-errors&amp;quot;&amp;gt;Propagating Errors&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当你实现一个函数时，它的实现可能会抛出某些错误，与其在你的函数中捕获这个错误，不如把这个错误传递给调用者，好让调用者决定如何处理这个错误。这个被称为错误的&amp;lt;em&amp;gt;传递（propgation）&amp;lt;&amp;#x2F;em&amp;gt;，这给了调用者更多的控制权，它内部也许有更完善的信息和逻辑来处理错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;例如，我们要写一个函数，在一个文件中读取一些内容，如果读取错误，将这个错误抛给调用者。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&amp;amp;gt; Result&amp;amp;lt;String, io::Error&amp;amp;gt; {
    let f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;);

    let mut f = match f {
        Ok(file) =&amp;amp;gt; file,
        Err(e) =&amp;amp;gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;amp;amp;mut s) {
        Ok(_) =&amp;amp;gt; Ok(s),
        Err(e) =&amp;amp;gt; Err(e),
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;a-shortcut-for-propagating-errors-the-operator&amp;quot;&amp;gt;A Shortcut for Propagating Errors: the ? Operator&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&amp;amp;gt; Result&amp;amp;lt;String, io::Error&amp;amp;gt; {
    let mut f = File::open(&amp;amp;quot;hello.txt&amp;amp;quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;amp;amp;mut s)?;
    Ok(s)
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符跟在&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型之后，当&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;值是&amp;lt;code&amp;gt;Ok&amp;lt;&amp;#x2F;code&amp;gt;时，它的值会作为表达式的值返回；当值是&amp;lt;code&amp;gt;Err&amp;lt;&amp;#x2F;code&amp;gt;时，会将这个错误作为整个函数的返回值抛出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式和&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符还有一点不同：&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符抛出的错误会经过一个由标准库&amp;lt;code&amp;gt;From&amp;lt;&amp;#x2F;code&amp;gt;trait 提供的，名称为&amp;lt;code&amp;gt;from&amp;lt;&amp;#x2F;code&amp;gt;的函数处理，它将原始的错误类型转换成我们当前函数声明中定义的错误类型。只要错误类型实现了&amp;lt;code&amp;gt;from&amp;lt;&amp;#x2F;code&amp;gt;方法，&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符就会调用它来进行错误类型转换。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;?&amp;lt;&amp;#x2F;code&amp;gt;操作符使函数体更加简洁，上面这个例子还可以更加简洁。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&amp;amp;gt; Result&amp;amp;lt;String, io::Error&amp;amp;gt; {
    let mut s = String::new();
    File::open(&amp;amp;quot;hello.txt&amp;amp;quot;)?.read_to_string(&amp;amp;amp;mut s)?;
    Ok(s)
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Enums and Pattern Matching</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;04-enums-and-pattern-matching&#x2F;"/>
                <updated>2022-01-20T08:01:35+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;04-enums-and-pattern-matching&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-4-enums-and-pattern-matching&amp;quot;&amp;gt;Chapter 4 - Enums and Pattern Matching&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;enumerations 枚举&amp;lt;&amp;#x2F;em&amp;gt;定义一个类型，用来穷举所有可能的数据。很多语言都有枚举类型，但它们的含义和用法有些差别。Rust 更接近于函数式编程语言中的枚举类型，&amp;lt;em&amp;gt;algebraic data types&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-ding-yi-yi-ge-mei-ju&amp;quot;&amp;gt;Section 1 - 定义一个枚举&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;先考虑一个场景，在这个场景下枚举比结构体更适合，比如需要做一个 IP 地址相关的功能。目前 IP 地址有个两个版本在使用中，V4 和 V6。所有 IP 地址只可能是这两个版本其中之一，所以我们可以用枚举穷举所有可能性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;IP 地址这种确定性（只能在这两个版本中，总的集合确定）和互斥性（只能是其中之一）是枚举类型最好的使用场景。而且不管是哪个版本，归根结底它都是 IP 地址，它们属于同一类型，所以在编码过程中需要把它们当作同一个类型去操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面用代码说明，首先创建一个 IP 地址枚举类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4,
    V6,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;mei-ju-zhi&amp;quot;&amp;gt;枚举值&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;实例化枚举值&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v4 = IpAddrKind::V4;
let v6 = IpAddrKind::V6;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意这两个值都是在&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;命名空间下的。这表示 V4 和 V6 都是同一类型的值，这种方式是很有用的，在后续处理中可以把它们都当作&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;类型来处理。比如定义一个函数接受&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;类型的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn route(address: IpAddrKind) {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数可以这样调用：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;route(IpAddrKind::V4);
route(IpAddrKind::V6);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用枚举还有很多其他好处。比如，我们在存储 IP 地址时，不知道它是 V4 还是 V6 版本的，只知道是一个 IP 地址，也就是说我们只知道它的类型。我们使用之前的结构体来写一下代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    type: IpAddrKind,
    address: String,
}

let home = IpAddr {
    type: IpAddrKind::V4,
    address: String::from(&amp;amp;quot;127.0.0.1&amp;amp;quot;),
}

let loopback = IpAddr {
    type: IpAddrKind::V6,
    address: String::from(&amp;amp;quot;::1&amp;amp;quot;),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里定义了一个&amp;lt;code&amp;gt;IpAddr&amp;lt;&amp;#x2F;code&amp;gt;类型来存储 IP 地址数据，它有两个字段：&amp;lt;code&amp;gt;type&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;类型的 IP 地址版本，&amp;lt;code&amp;gt;address&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型的 IP 地址数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;有一种更简洁的方式，仅用枚举类型来表示，而不需要结构体嵌套枚举类型。这种方式是将数据直接存入枚举变体的实例中。&amp;lt;code&amp;gt;IpAddrKind&amp;lt;&amp;#x2F;code&amp;gt;枚举的定义也需要更改一下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4(String),
    V6(String),
}

let home = IpAddrKind::V4(String::from(&amp;amp;quot;127.0.0.1&amp;amp;quot;));
let loopback = IpAddrKind::V6(String::from(&amp;amp;quot;::1&amp;amp;quot;));
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此外还有一种方式。枚举类型变体可以拥有不同的类型和数据量，因此我们可以将&amp;lt;code&amp;gt;V4&amp;lt;&amp;#x2F;code&amp;gt;类型定义成由 4 个整型数据组成的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum IpAddrKind {
    V4(u8, u8, u8, u8)
}
let home = IpAddrKind::V4(127, 0, 0, 1);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;IP 地址的存取是一个非常常用的功能，因此标准库已经实现了相关定义，编码人员可以直接使用。可以看看标准库是如何实现 IP 地址数据的定义的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Ipv4Addr {

}

struct Ipv6Addr {

}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;再来看另外一个例子，这个枚举类型下面有更多的字段和数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Message {
    Quit,
    Move {x: i32, y: i32},
    Write(String),
    ChangeColor(i32,i32,i32),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这些字段都有不同的数据类型：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Quit&amp;lt;&amp;#x2F;code&amp;gt;没有数据与它关联。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Move&amp;lt;&amp;#x2F;code&amp;gt;包含了一个匿名结构。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Write&amp;lt;&amp;#x2F;code&amp;gt;包含了一个字符串。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ChangeColor&amp;lt;&amp;#x2F;code&amp;gt;包含了 3 个&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;整数。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;这种方式与定义 4 个不同的结构体相似，不同点在于，枚举将他们都涵盖在了同一个类型&amp;lt;code&amp;gt;Message&amp;lt;&amp;#x2F;code&amp;gt;下。下面都结构体定义可以与枚举变体存储一样都数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct QuitMessage; &amp;amp;#x2F;&amp;amp;#x2F; unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); &amp;amp;#x2F;&amp;amp;#x2F; tuple struct
struct ChangeColorMessage(i32, i32, i32); &amp;amp;#x2F;&amp;amp;#x2F; tuple struct
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;枚举和结构体还有一个相似之处，都可以通过&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字对其进行方法扩展。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Message {
    fn call(&amp;amp;amp;self) {
        &amp;amp;#x2F;&amp;amp;#x2F; method body would be defined here
    }
}

let m = Message::Write(String::from(&amp;amp;quot;hello&amp;amp;quot;));
m.call();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来再看另外一个标准库中很常用的枚举类：&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;optionmei-ju-lei-ji-ta-dui-nullde-you-shi&amp;quot;&amp;gt;&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;枚举类及它对&amp;lt;code&amp;gt;Null&amp;lt;&amp;#x2F;code&amp;gt;的优势&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Option 枚举类在很多地方都会用到，因为它编码了一个很常见的情景：对变量的空值判断。用类型系统涵盖这个概念，代表编译器帮我们做了空值检查，可以在编译阶段就抛出错误，避免运行时 bug。并且 Rust 没有其他语言中&amp;lt;code&amp;gt;null&amp;lt;&amp;#x2F;code&amp;gt;的功能。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;null 值的问题在于，当你把 null 作为一个非 null 变量使用时，会抛出一个类型错误。因为变量的空和非空是很常见的场景，很容易导致 bug。但是 null 却描述了一个很有用的概念：一个变量因为某些原因此时不可用或不存在。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所以真正的问题不在于概念本身，而在于它的实现。因此 Rust 没有 null 值，取而代之是标准库实现的枚举类型用来描述值是否存在。这个枚举类型是&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，它的定义如下&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Option&amp;amp;lt;T&amp;amp;gt; {
    Some&amp;amp;lt;T&amp;amp;gt;,
    None,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;是默认引入的，不需要手动引入命名空间，它的枚举变体也是默认引入的，调用时不需要加&amp;lt;code&amp;gt;Option::&amp;lt;&amp;#x2F;code&amp;gt;前缀。&amp;lt;code&amp;gt;&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;是一个泛型参数，它可以代表任何类型，表示&amp;lt;code&amp;gt;Some&amp;lt;&amp;#x2F;code&amp;gt;可以存储任何类型的数据。下面是一些使用的例子&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let some_number = Some(5);
let some_str = Some(&amp;amp;quot;a string&amp;amp;quot;);

let absent_num: Option&amp;amp;lt;i32&amp;amp;gt; = None;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当使用&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;时，需要指定泛型是哪种数据类型，因为编译器无法通过&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;去推断&amp;lt;code&amp;gt;Some&amp;lt;&amp;#x2F;code&amp;gt;的正确类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;为何使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;要优于使用 null 值？简单来说，&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;不是同一类型，编译器不会让我们使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的值，就算它是一个有效值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x:i8 = 5;
let y:Option&amp;amp;lt;i8&amp;amp;gt; = Some(10);
let sum = x + y;

&amp;amp;#x2F;&amp;amp;#x2F; error[E0277]: cannot add `std::option::Option&amp;amp;lt;i8&amp;amp;gt;` to `i8`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果运行这段代码，编译器会直接抛错。编译器不知道如何将&amp;lt;code&amp;gt;i8&amp;lt;&amp;#x2F;code&amp;gt;类型和&amp;lt;code&amp;gt;Option&amp;amp;lt;i8&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的数据作加法计算。当变量是&amp;lt;code&amp;gt;i8&amp;lt;&amp;#x2F;code&amp;gt;类型时，编译器可以保证此时一定是一个有效值，所以不需要担心值不存在。当使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的变量时，我们需要考虑值不存在的情况，编译器需要确保我们对这种情况做了处理。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;也就是说，在使用之前，需要先将&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;转换成&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型。在这个过程中可以捕获最常见的值为空但被错误使用的错误情况。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果一个值可能为空，首先必须手动指定该值为&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型。然后在使用该值时，处理值为空的逻辑是必须的。所以任何非&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的数据，都可以被认为是非 null 的。这是 Rust 刻意的设计，为了限制代码中 null 值泛滥，增强代码的安全性。&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;有很多的方法扩展，可以读一下它的&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;option&amp;#x2F;enum.Option.html&amp;quot;&amp;gt;文档&amp;lt;&amp;#x2F;a&amp;gt;。熟悉&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;的内部方法对学习 Rust 很有好处。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通常为了使用&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;内部的&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;值，你的代码需要覆盖所有的枚举变体。某些代码仅在&amp;lt;code&amp;gt;Some&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;运行，此时代码能够访问到内部的&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;数据。某些代码仅在&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;运行，作空值逻辑处理。&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式是可以实现上述需求的一个控制流程。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-matchliu-cheng-kong-zhi-biao-da-shi&amp;quot;&amp;gt;Section 2 - &amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;流程控制表达式&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;可以通过许多的*patterns（匹配模型）*去对比，并在相应的匹配模型命中的情况下执行某些代码。匹配模型可以是字面量值、变量、通配符等等。&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;流程控制强大之处在于丰富的匹配模型，以及编译器可以确认所有的可能情况都被涵盖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&amp;amp;gt; i8 {
    match coin {
        Coin::Penny =&amp;amp;gt; 1,
        Coin::Nickel =&amp;amp;gt; 5,
        Coin::Dime =&amp;amp;gt; 10,
        Coin::Quarter =&amp;amp;gt; 25,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;分析一下这段代码。&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;后紧跟一个表达式，在这里是变量&amp;lt;code&amp;gt;coin&amp;lt;&amp;#x2F;code&amp;gt;。这里跟&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;有点类似，但是&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;后的表达式需要返回&amp;lt;code&amp;gt;bool&amp;lt;&amp;#x2F;code&amp;gt;值，而&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;后可以返回任何类型的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来是&amp;lt;em&amp;gt;match arms&amp;lt;&amp;#x2F;em&amp;gt;。每个 arm 由两个部分组成：一个匹配模型、一部分代码，两部分用&amp;lt;code&amp;gt;=&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符分割。arm 之间使用逗号分割。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式执行时，首先将结果值和匹配模型对比，如果某个匹配模型被命中，则它后面的代码会被执行，否则进入下一个 arm 进行对比。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;每个 arm 要执行的代码是一个表达式，其返回值作为&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式的返回值。如果需要执行多行代码，可以用花括号组成代码块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;pi-pei-mo-xing-bang-ding-de-shu-ju&amp;quot;&amp;gt;匹配模型绑定的数据&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式的匹配模型可以绑定一些数据，这也是提取枚举变体中数据的方式。修改一下代码&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    &amp;amp;#x2F;&amp;amp;#x2F; --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&amp;amp;gt; u8 {
    match coin {
        Coin::Penny =&amp;amp;gt; 1,
        Coin::Nickel =&amp;amp;gt; 5,
        Coin::Dime =&amp;amp;gt; 10,
        Coin::Quarter(state) =&amp;amp;gt; {
            println!(&amp;amp;quot;State quarter from {:?}!&amp;amp;quot;, state);
            25
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码在&amp;lt;code&amp;gt;Coin::Quarter&amp;lt;&amp;#x2F;code&amp;gt;匹配模型中绑定了一个变量&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;，当该匹配模型命中时，&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;变量会绑定&amp;lt;code&amp;gt;Quarter&amp;lt;&amp;#x2F;code&amp;gt;枚举变体中存储的数据，并且在该匹配模型后面的代码中，我们可以通过&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;变量使用这个数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;假如调用&amp;lt;code&amp;gt;value_in_cents(Coin::Quarter(UsState::Alabama));&amp;lt;&amp;#x2F;code&amp;gt;，变量&amp;lt;code&amp;gt;coin&amp;lt;&amp;#x2F;code&amp;gt;的值为&amp;lt;code&amp;gt;Coin::Quarter(UsState::Alabama)&amp;lt;&amp;#x2F;code&amp;gt;。在 match 表达式中，最后一个匹配模型会命中，此时&amp;lt;code&amp;gt;state&amp;lt;&amp;#x2F;code&amp;gt;变量绑定的值将会是&amp;lt;code&amp;gt;UsState::Alabama&amp;lt;&amp;#x2F;code&amp;gt;，然后可以在&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;表达式中使用该匹配模型内部绑定的状态值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;matching-with-option&amp;quot;&amp;gt;Matching with Option&amp;lt;T&amp;gt;&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;实现一个函数接受一个&amp;lt;code&amp;gt;Option&amp;amp;lt;i32&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;作为参数，如果内部有值则+1，如果没有值则不做任何逻辑且返回&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn plus_one(x: Option&amp;amp;lt;i32&amp;amp;gt;) -&amp;amp;gt; Option&amp;amp;lt;i32&amp;amp;gt; {
    match x {
        None =&amp;amp;gt; None,
        Some(i) =&amp;amp;gt; Some(i + 1),
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;matches-yao-quan-mian&amp;quot;&amp;gt;Matches 要全面&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn plus_one(x: Option&amp;amp;lt;i32&amp;amp;gt;) -&amp;amp;gt; Option&amp;amp;lt;i32&amp;amp;gt; {
    match x {
        Some(i) =&amp;amp;gt; Some(i + 1),
    }
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0004]: non-exhaustive patterns: `None` not covered
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码中，&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;的情况没有被覆盖到，因此有可能会出现 bug。好在 Rust 在编译阶段就能指出这个地方有问题。在&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式中必须涵盖任何一种可能的情况，以保证代码的安全和健壮。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zhan-wei-fu&amp;quot;&amp;gt;&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位符&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当不想列举一些可能情况时，可以用占位符&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;来替代。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let some_u8_value = 0u8;
match some_u8_value {
    1 =&amp;amp;gt; println!(&amp;amp;quot;one&amp;amp;quot;),
    3 =&amp;amp;gt; println!(&amp;amp;quot;three&amp;amp;quot;),
    5 =&amp;amp;gt; println!(&amp;amp;quot;five&amp;amp;quot;),
    7 =&amp;amp;gt; println!(&amp;amp;quot;seven&amp;amp;quot;),
    _ =&amp;amp;gt; (),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位符会匹配所有的情况，因此需要将它放在最后面，以免覆盖我们想要处理的情况。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当只需要处理所有情况之中的一种时，&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;表达式就显得有些啰嗦了。所以在这种场景下，Rust 为我们提供了&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-if-letliu-cheng-kong-zhi-biao-da-shi&amp;quot;&amp;gt;Section 3 - &amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;流程控制表达式&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;表达式可以让我们只关注一种需要处理的情况而忽略其他所有的情况。比如之前的例子&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&amp;amp;gt; println!(&amp;amp;quot;three&amp;amp;quot;),
    _ =&amp;amp;gt; (),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里只处理了值为 3 的情况，其余情况都被省略了，此时&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;要比&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;在书写上更加简洁。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;if let Some(3) = some_u8_value {
    println!(&amp;amp;quot;three&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以将&amp;lt;code&amp;gt;if let&amp;lt;&amp;#x2F;code&amp;gt;理解为&amp;lt;code&amp;gt;match&amp;lt;&amp;#x2F;code&amp;gt;的一种语法糖。还可以在后面加&amp;lt;code&amp;gt;else&amp;lt;&amp;#x2F;code&amp;gt;分支，它的作用和&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位符是一样的效果。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Common Concepts</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;01-common-concepts&#x2F;"/>
                <updated>2020-12-10T23:03:29+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;01-common-concepts&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-1-common-concepts&amp;quot;&amp;gt;Chapter 1 - Common Concepts&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-variables-and-mutability&amp;quot;&amp;gt;Section 1 - Variables and Mutability&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;h3 id=&amp;quot;bian-liang-ding-yi&amp;quot;&amp;gt;变量定义&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 定义变量的方式&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 10
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 的变量默认是 Immutable，可通过&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字修改。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 10
x = 20 &amp;amp;#x2F;&amp;amp;#x2F;error: cannot assign twice to immutable variable

let mut x = 10
x = 20 &amp;amp;#x2F;&amp;amp;#x2F;success
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;immutable-yu-const-de-qu-bie&amp;quot;&amp;gt;Immutable 与 const 的区别&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 变量默认不可重复赋值，const 常量同样也不允许重复赋值，这二者的区别在于：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;变量用&amp;lt;code&amp;gt;let&amp;lt;&amp;#x2F;code&amp;gt;关键字，常量用&amp;lt;code&amp;gt;const&amp;lt;&amp;#x2F;code&amp;gt;关键字。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;变量可以用&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字修饰，常量不行。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;常量初始化要带数据类型声明，例如：&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;const NUM:i32 = 10
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;常量可以在任何上下文中定义，变量不能在定义在全局上下文中。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;常量大部分情况下只用于常量赋值表达式，而不会用于赋值函数运算结果等运行时计算的表达式。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h3 id=&amp;quot;bian-liang-fu-gai-shadows&amp;quot;&amp;gt;变量覆盖（Shadows）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;let 关键字可重复声明同一变量名，后声明的会覆盖之前声明的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;

let x = x + 1;

println!(&amp;amp;quot;The value of x is: {}&amp;amp;quot;, x);

let x = x * 2;

println!(&amp;amp;quot;The value of x is: {}&amp;amp;quot;, x);

&amp;amp;#x2F;&amp;amp;#x2F; output
&amp;amp;#x2F;&amp;amp;#x2F; The value of x is: 6
&amp;amp;#x2F;&amp;amp;#x2F; The value of x is: 12
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;之前提到，设置一个变量 mutable 可以用关键字&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;，可以对其进行重复赋值。变量覆盖看起来功能相似，但是它在改变了变量值的同时，保持了 Rust 的 Immutable 特性，其安全性没有降低。另外，变量覆盖本质上是定义了一个新的变量，因此我们可以用同一个变量名但是使用不同的数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;

println!(&amp;amp;quot;{}&amp;amp;quot;, x);

let x = &amp;amp;quot;string&amp;amp;quot;;

println!(&amp;amp;quot;{}&amp;amp;quot;, x);

&amp;amp;#x2F;&amp;amp;#x2F;output
&amp;amp;#x2F;&amp;amp;#x2F; 5
&amp;amp;#x2F;&amp;amp;#x2F; string
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-data-types&amp;quot;&amp;gt;Section 2 - Data Types&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;h3 id=&amp;quot;zheng-xing-integer&amp;quot;&amp;gt;整型（Integer）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Length&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Signed&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Unsigned&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;&amp;lt;&amp;#x2F;thead&amp;gt;&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;8-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i8&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u8&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;16-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i16&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u16&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;32-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i32&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u32&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;64-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i64&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u64&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;128-bit&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;i128&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;u128&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;arch&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;isize&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;usize&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;tbody&amp;gt;&amp;lt;&amp;#x2F;table&amp;gt;
&amp;lt;p&amp;gt;无符号整型范围：0 ~ $2^n - 1$，有符号整型范围：$-2^{n-1}$ ~ $2^{n-1} - 1$&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;zheng-xing-zi-mian-liang&amp;quot;&amp;gt;整型字面量&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;Number&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;th style=&amp;quot;text-align: left&amp;quot;&amp;gt;literals Example&amp;lt;&amp;#x2F;th&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;&amp;lt;&amp;#x2F;thead&amp;gt;&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Decimal&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;98_222&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Hex&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;0xff&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Octal&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;0o77&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Binary&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;0b1111_0000&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;Byte&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;td style=&amp;quot;text-align: left&amp;quot;&amp;gt;(u8 only) b’A’&amp;lt;&amp;#x2F;td&amp;gt;&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;tbody&amp;gt;&amp;lt;&amp;#x2F;table&amp;gt;
&amp;lt;p&amp;gt;:::tip 溢出（Integer Overflow）
当发生整型溢出，debug 模式程序会报错退出，release 编译模式会将高位截断（&amp;lt;code&amp;gt;u8&amp;lt;&amp;#x2F;code&amp;gt;256 -&amp;amp;gt; 0）。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fu-dian-floating-point&amp;quot;&amp;gt;浮点（Floating—Point）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;浮点数表示遵循 IEEE-754 标准，浮点数有两种基本类型&amp;lt;code&amp;gt;f32&amp;lt;&amp;#x2F;code&amp;gt;单精度浮点和&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;双精度浮点，Rust 默认是&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;，因为在现代 cpu 中，&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;的运算速度和&amp;lt;code&amp;gt;f32&amp;lt;&amp;#x2F;code&amp;gt;相当，同时具有更高的精度。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;bu-er-boolean&amp;quot;&amp;gt;布尔（Boolean）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;只有&amp;lt;code&amp;gt;true&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;false&amp;lt;&amp;#x2F;code&amp;gt;两个值，大小为 1byte。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zi-fu-character&amp;quot;&amp;gt;字符（Character）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;用单引号表示 char 类型（双引号是 string），大小为 4byte，为 Unicode 编码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;yuan-zu-tuple&amp;quot;&amp;gt;元组（Tuple）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;元组是常用的将一组数字类型（浮点、整型）的数据组合的类型，不可动态扩容。解构元组时定义的变量要和元组的数据量对应，或者用&amp;lt;code&amp;gt;_&amp;lt;&amp;#x2F;code&amp;gt;占位，也可以通过索引访问。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
&amp;amp;#x2F;&amp;amp;#x2F; tuple声明
let x = (1,2,3);
&amp;amp;#x2F;&amp;amp;#x2F; 解构
let (a, b, c) = x;

let (a, _, _) = x;
let (_, b, _) = x;
let (_, _, c) = x;

let first = x.0;
let second = x.1;
let third = x.2;

&amp;amp;#x2F;&amp;amp;#x2F;let (a, b) = x; error
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shu-zu-array&amp;quot;&amp;gt;数组（Array）&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;数组中的元素类型必须一致，不可动态扩容。与 Vector 不同，Vector 是标准库提供的一种数据存储结构，支持动态扩容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h5 id=&amp;quot;shu-zu-ding-yi-fang-shi&amp;quot;&amp;gt;数组定义方式&amp;lt;&amp;#x2F;h5&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; 编译器推断类型和数量
let x = [1, 2, 3];
&amp;amp;#x2F;&amp;amp;#x2F; 指定类型和数量
let x:[i32; 3] = [1, 2, 3];
&amp;amp;#x2F;&amp;amp;#x2F; 所有元素都是相同的
let x = [3; 5];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;shu-zu-fang-wen&amp;quot;&amp;gt;数组访问&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;通过下标的形式，不允许越界。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;x[0]

x[5] &amp;amp;#x2F;&amp;amp;#x2F;error bounds:
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-functions&amp;quot;&amp;gt;Section 3 - Functions&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;函数由&amp;lt;code&amp;gt;fn&amp;lt;&amp;#x2F;code&amp;gt;关键字、函数名、参数列表（parameters）、返回类型、作用域块组成。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
println!(&amp;amp;quot;Hello, world!&amp;amp;quot;);

another_function();
}

fn another_function() {
println!(&amp;amp;quot;Another function.&amp;amp;quot;);
}

&amp;amp;#x2F;&amp;amp;#x2F; output
&amp;amp;#x2F;&amp;amp;#x2F; Hello, world!
&amp;amp;#x2F;&amp;amp;#x2F; Another function.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 对声明顺序不敏感，调用的函数只要有声明就行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-can-shu&amp;quot;&amp;gt;函数参数&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数的参数列表是函数声明的一部分，参数列表多个参数用逗号分割。形参（parameters），实参（arguments）。函数参数列表（parameters）必须指明参数类型&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-ti&amp;quot;&amp;gt;函数体&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数体由表达式（expression）结尾的一系列语句（statement）组成。statement 表示执行某些操作，不会返回值；expression 会进行计算并返回值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = (let y = 6);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;以上代码会报错，&amp;lt;code&amp;gt;let y = 6&amp;lt;&amp;#x2F;code&amp;gt;是一个声明语句（statement），statement 是不能作为赋值语句的右值的，因为赋值语句的右值必须能返回值赋给左值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;函数调用和作用域块都是表达式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; function invoke
let y = func();

&amp;amp;#x2F;&amp;amp;#x2F; block scope
let y = {
let x = 3;
x + 1
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意 x + 1 后面没有分号，这也是表达式和语句的区别，语句都以分号结尾，而表达式不包含分号。表达式加分号会成为语句。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;:::tip tip
Rust 中有一个空类型&amp;lt;code&amp;gt;()&amp;lt;&amp;#x2F;code&amp;gt;，所有语句和没有返回值的函数，Rust 会自动返回空类型。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-fan-hui-zhi&amp;quot;&amp;gt;函数返回值&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数返回类型定义在参数列表（parameters）之后。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn func() -&amp;amp;gt; i32 {
1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 在函数体最后可以用表达式代替 return 关键字返回值（该表达式不能加分号，否则会变成语句，且该表达式只能位于函数体最后）。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-comments&amp;quot;&amp;gt;Section 4 - Comments&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;注释，对代码加以说明，起辅助作用，给人读的内容而不是机器。用&amp;lt;code&amp;gt;&amp;#x2F;&amp;#x2F;&amp;lt;&amp;#x2F;code&amp;gt;开头，不能跨行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; 一行注释
let a = 10;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h2 id=&amp;quot;section-5-control-flow&amp;quot;&amp;gt;Section 5 - Control Flow&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;h3 id=&amp;quot;if-tiao-jian-biao-da-shi&amp;quot;&amp;gt;if 条件表达式&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;由关键字&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;开始，后面紧跟一个条件表达式，该表达式返回值只能是&amp;lt;code&amp;gt;boolean&amp;lt;&amp;#x2F;code&amp;gt;类型。之后跟一个作用域块，条件不匹配时使用&amp;lt;code&amp;gt;else&amp;lt;&amp;#x2F;code&amp;gt;关键字，后面接一个作用域块。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let number = 3;

if number &amp;amp;lt; 5 {
println!(&amp;amp;quot;condition was true&amp;amp;quot;);
} else {
println!(&amp;amp;quot;condition was false&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;duo-tiao-jian-shi-yong-else-if&amp;quot;&amp;gt;多条件时用&amp;lt;code&amp;gt;else if&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let number = 6;

if number % 4 == 0 {
println!(&amp;amp;quot;number is divisible by 4&amp;amp;quot;);
} else if number % 3 == 0 {
println!(&amp;amp;quot;number is divisible by 3&amp;amp;quot;);
} else if number % 2 == 0 {
println!(&amp;amp;quot;number is divisible by 2&amp;amp;quot;);
} else {
println!(&amp;amp;quot;number is not divisible by 4, 3, or 2&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;zai-letyu-ju-zhong-shi-yong-if-biao-da-shi&amp;quot;&amp;gt;在&amp;lt;code&amp;gt;let&amp;lt;&amp;#x2F;code&amp;gt;语句中使用 if 表达式&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;由于 if 是一个表达式，所以它可以用于 let 语句的右值。这种情况下，if 表达式各条件分支返回的数据类型必须一致，这是因为在编译阶段 Rust 必须确定变量的类型，编译器不支持运行时动态确定变量类型，这样会使编译器更加复杂并且安全性降低。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let condition = true;
let number = if condition { 5 } else { 6 };

let number = if condition { 5 } else { &amp;amp;quot;six&amp;amp;quot; };
&amp;amp;#x2F;&amp;amp;#x2F; error if and else have incompatible types
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;xun-huan&amp;quot;&amp;gt;循环&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 有三种执行循环的方式，&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;,&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;loop&amp;quot;&amp;gt;loop&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;loop {
&amp;amp;#x2F;&amp;amp;#x2F; do something
if condition {
break &amp;amp;#x2F;&amp;amp;#x2F;something
}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;循环执行同一段代码块。可以通过 break 关键字从&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;循环中返回一个值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;while&amp;quot;&amp;gt;while&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
let mut number = 3;

while number != 0 {
println!(&amp;amp;quot;{}!&amp;amp;quot;, number);

number -= 1;
}

println!(&amp;amp;quot;LIFTOFF!!!&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;循环整合了&amp;lt;code&amp;gt;loop&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;else&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;break&amp;lt;&amp;#x2F;code&amp;gt;的功能，让代码块更清晰，没有很深的嵌套。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h5 id=&amp;quot;for&amp;quot;&amp;gt;for&amp;lt;&amp;#x2F;h5&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
let a = [10, 20, 30, 40, 50];

for element in a.iter() {
println!(&amp;amp;quot;the value is: {}&amp;amp;quot;, element);
}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;用来遍历集合中的元素。同&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;通过下标访问的方式相比，&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;更快更安全，原因在于：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;编译器会加入 runtime 代码，在每次&amp;lt;code&amp;gt;while&amp;lt;&amp;#x2F;code&amp;gt;循环时检查循环条件。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;通过下标访问难免出现越界和遗漏等 bug。
基于以上优点，&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环使用的频率最高，就算在非遍历集合的场景下。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
for number in (1..4).rev() {
println!(&amp;amp;quot;{}!&amp;amp;quot;, number);
}
println!(&amp;amp;quot;LIFTOFF!!!&amp;amp;quot;);
}
&amp;amp;#x2F;&amp;amp;#x2F; 3!
&amp;amp;#x2F;&amp;amp;#x2F; 2!
&amp;amp;#x2F;&amp;amp;#x2F; 1!
&amp;amp;#x2F;&amp;amp;#x2F; LIFTOFF!!!
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面代码中&amp;lt;code&amp;gt;(1..4)&amp;lt;&amp;#x2F;code&amp;gt;是标准库中的&amp;lt;code&amp;gt;Range&amp;lt;&amp;#x2F;code&amp;gt;类型。按顺序生成&amp;lt;strong&amp;gt;左闭右开&amp;lt;&amp;#x2F;strong&amp;gt;的集合序列，可以通过&amp;lt;code&amp;gt;rev&amp;lt;&amp;#x2F;code&amp;gt;方法进行逆转。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Generic Types, Traits, and Lifetimes</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;08-generic-types-traits-and-lifetimes&#x2F;"/>
                <updated>2021-10-05T14:38:34+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;08-generic-types-traits-and-lifetimes&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-8-generic-types-traits-and-lifetimes&amp;quot;&amp;gt;Chapter 8 - Generic Types, Traits, and Lifetimes&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;每种语言都有针对概念抽象的有效工具。Rust 中的工具之一是&amp;lt;em&amp;gt;generic（泛型）&amp;lt;&amp;#x2F;em&amp;gt;。泛型是对类型或其他属性的抽象。在编码时，我们可以专注于表达泛型的行为或者与其他泛型之间的关系，而不用在意它在运行时代表的是什么类型的数据。函数也可以接收一些泛型参数而不是具体类型的参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;chou-xiang-han-shu-shan-chu-zhong-fu-dai-ma&amp;quot;&amp;gt;抽象函数删除重复代码&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在学习泛型之前，我们先看一下如何通过函数抽象来解决代码重复的问题，然后我们会将泛型参数再加入进来。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;先看一个寻找数组中最大数的示例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &amp;amp;gt; largest {
            largest = number;
        }
    }

    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, largest);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果我们要寻找另外一个数组中的最大数，可以重复这段代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &amp;amp;gt; largest {
            largest = number;
        }
    }

    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &amp;amp;gt; largest {
            largest = number;
        }
    }

    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, largest);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以看出除了数组中的数据不同，其他地方的逻辑完全是一样的。这样写代码虽然可以得出正确的结果，但是显得太过啰嗦而且容易出错。如果我们要修改其中的逻辑，比如改成寻找最小的数字，那么就得将所有重复的代码都改一遍。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;为了去除重复代码，我们可以通过抽象一个函数，把不变的逻辑部分封装起来，可变的部分（数组）通过参数传递。这让我们的代码更加简洁，表意清晰也易于维护。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数目前还不能编译通过，因为还需要用到一些之后会讲到的内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-fan-xing&amp;quot;&amp;gt;Section 1 - 泛型&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;泛型即通用类型，是在运行时才确定具体运算类型的技术。通过泛型声明函数和结构体，在调用时可以使用多种数据类型。首先看看如何通过泛型声明函数、结构体、枚举和方法等，之后再讨论一下泛型对于性能的影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-sheng-ming&amp;quot;&amp;gt;函数声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用泛型声明函数时，我们使用泛型变量来替代参数和返回值的数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest_i32(list: &amp;amp;amp;[i32]) -&amp;amp;gt; i32 {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;amp;amp;[char]) -&amp;amp;gt; char {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let char_list = vec![&amp;amp;#x27;y&amp;amp;#x27;, &amp;amp;#x27;m&amp;amp;#x27;, &amp;amp;#x27;a&amp;amp;#x27;, &amp;amp;#x27;q&amp;amp;#x27;];

    let result = largest_char(&amp;amp;amp;char_list);
    println!(&amp;amp;quot;The largest char is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面分别有两个函数&amp;lt;code&amp;gt;largest_i32&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;largest_char&amp;lt;&amp;#x2F;code&amp;gt;，它们接收不同的数据类型，但是内部所做的事是一样的逻辑。所以这两个函数可以通过泛型抽象成一个函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在函数中将类型参数化，需要对类型参数命名，就像对普通参数命名那样。可以用一个标识符来表示类型参数，习惯上我们会用&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;来表示，因为 T 是 type 的缩写。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在函数体中使用参数时，需要先在函数声明中对参数命名，好让编译器知道这个名称的含义是什么。同样的，当我们在函数声明中使用类型参数前，需要对其进行命名。类型参数需要用&amp;lt;code&amp;gt;&amp;amp;lt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;包起来，并且置于函数名和参数列表之间。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个声明的含义是，&amp;lt;code&amp;gt;largest&amp;lt;&amp;#x2F;code&amp;gt;函数接收一个泛型&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;，参数&amp;lt;code&amp;gt;list&amp;lt;&amp;#x2F;code&amp;gt;是泛型&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;的切片，函数返回一个&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型的值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来将&amp;lt;code&amp;gt;largest_i32&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;largest_char&amp;lt;&amp;#x2F;code&amp;gt;函数通过泛型抽象为一个函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let char_list = vec![&amp;amp;#x27;y&amp;amp;#x27;, &amp;amp;#x27;m&amp;amp;#x27;, &amp;amp;#x27;a&amp;amp;#x27;, &amp;amp;#x27;q&amp;amp;#x27;];

    let result = largest(&amp;amp;amp;char_list);
    println!(&amp;amp;quot;The largest char is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此时代码编译会提示一个错误&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;error[E0369]: binary operation &amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt; cannot be applied to type &amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;这里的出现错误的原因是，&amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符不能在所有可能的数据类型上运算。为了进行比较运算，标准库提供了&amp;lt;code&amp;gt;std::cmp::PartialOrd&amp;lt;&amp;#x2F;code&amp;gt;trait，类型实现它就可以获得进行比较运算的能力。这个在后续章节中会介绍到。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;jie-gou-ti-sheng-ming&amp;quot;&amp;gt;结构体声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们也可以使用泛型对结构体的字段进行声明。跟函数声明没什么不同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T&amp;amp;gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以使用多个泛型参数来代表多种不同的类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T, U&amp;amp;gt; {
    x: T,
    y: U,
}

fn main() {
    let integer = Point { x: 5, y: 10.0 };
    let float = Point { x: 1.0, y: 4 };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;但是泛型参数的数量不宜过多，否则代码可读性会变差。当你需要使用到多个泛型变量时，说明你的代码需要重构到更细颗粒度。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mei-ju-sheng-ming&amp;quot;&amp;gt;枚举声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;跟结构体声明一样，没有什么特别。比如之前多次使用到的&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Result&amp;amp;lt;T, E&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;枚举。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Option&amp;amp;lt;T&amp;amp;gt; {
    Some(T),
    None,
}

enum Result&amp;amp;lt;T, E&amp;amp;gt; {
    Ok(T),
    Err(E),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当你的代码出现多个相似的结构体和枚举，这些结构体和枚举仅仅只有数据类型不同时，就可以使用泛型对其进行抽象。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fang-fa-sheng-ming&amp;quot;&amp;gt;方法声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T&amp;amp;gt; {
    x: T,
    y: T,
}

impl&amp;amp;lt;T&amp;amp;gt; Point&amp;amp;lt;T&amp;amp;gt; {
    fn x(&amp;amp;amp;self) -&amp;amp;gt; &amp;amp;amp;T {
        &amp;amp;amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&amp;amp;quot;p.x = {}&amp;amp;quot;, p.x());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;泛型参数&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;被置于&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字之后，方法名之后的泛型参数就可以省略不写。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Point&amp;amp;lt;f32&amp;amp;gt; {
    fn distance_from_origin(&amp;amp;amp;self) -&amp;amp;gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这段代码的含义是，&amp;lt;code&amp;gt;Point&amp;amp;lt;f32&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上实现了一个方法&amp;lt;code&amp;gt;distance_from_origin&amp;lt;&amp;#x2F;code&amp;gt;，对于泛型&amp;lt;code&amp;gt;Point&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，当&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;f32&amp;lt;&amp;#x2F;code&amp;gt;以外的类型时，则它不具有&amp;lt;code&amp;gt;distance_from_origin&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;结构体的泛型参数不一定会被方法定义时全部使用。可以在方法上指定一些其他的泛型参数，这些泛型参数仅仅在该方法上生效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Point&amp;amp;lt;T, U&amp;amp;gt; {
    x: T,
    y: U,
}

impl&amp;amp;lt;T, U&amp;amp;gt; Point&amp;amp;lt;T, U&amp;amp;gt; {
    fn mixup&amp;amp;lt;V, W&amp;amp;gt;(self, other: Point&amp;amp;lt;V, W&amp;amp;gt;) -&amp;amp;gt; Point&amp;amp;lt;T, W&amp;amp;gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &amp;amp;quot;Hello&amp;amp;quot;, y: &amp;amp;#x27;c&amp;amp;#x27; };

    let p3 = p1.mixup(p2);

    println!(&amp;amp;quot;p3.x = {}, p3.y = {}&amp;amp;quot;, p3.x, p3.y);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-fan-xing-de-dai-ma-xing-neng&amp;quot;&amp;gt;使用泛型的代码性能&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;你可能会怀疑使用泛型会在运行时有一定的性能损耗。但是 Rust 在中使用泛型和特定的数据类型，在性能上没有任何区别。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 通过在编译阶段对使用了泛型的代码执行&amp;lt;em&amp;gt;monomorphization&amp;lt;&amp;#x2F;em&amp;gt;来完成性能优化。&amp;lt;em&amp;gt;monomorphization&amp;lt;&amp;#x2F;em&amp;gt;是在编译阶段将泛型替换成具体数据类型的进程。在这个进程中编译器执行与创建泛型函数相反的操作，编译器查看所有调用了泛型声明的代码，并且生成对应的具体数据类型的代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们通过一个例子来看看它的工作原理&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let integer = Some(5);
let float = Some(5.0);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当 Rust 编译这段代码，它会执行 monomorphization。编译器发现有两处代码调用了&amp;lt;code&amp;gt;Option&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;枚举的实体，编译器会针对这两处代码的类型分别生成对应的&amp;lt;code&amp;gt;Option&amp;lt;&amp;#x2F;code&amp;gt;枚举。可以看成是抽象代码的一个逆操作&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;由于 Rust 在编译阶段生成了相应的代码，因此在运行时就没有性能损耗了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-traits-defining-shared-behavior&amp;quot;&amp;gt;Section 2 - Traits: Defining Shared Behavior&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;trait&amp;lt;&amp;#x2F;em&amp;gt;告诉编译器特定的类型下具有什么功能，并且是否对外暴露。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;trait 与其他类型的&amp;lt;code&amp;gt;interface&amp;lt;&amp;#x2F;code&amp;gt;概念类似，但不完全相同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;h3 id=&amp;quot;ding-yi-trait&amp;quot;&amp;gt;定义 Trait&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;类型的行为取决于我们能在该类型上调用的方法。如果多种不同类型都可以调用同一个方法，那么它们就具有相同的行为。trait 就是将这些相同方法组织在一起，定义一个行为的集合。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;例如，有一些结构体能够存储一些类型和数量的文本，&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;可以存储一个新闻内容；&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;可以存储至多 280 个字符的文本内容，和标识它是新推文、转推还是回复其他推文的一些元数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们想做一个媒体聚合库，用来展示&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;实例的摘要内容。因此，这两种类型中都必须要有摘要数据，然后通过调用&amp;lt;code&amp;gt;summarize&amp;lt;&amp;#x2F;code&amp;gt;方法来获取实例上的摘要数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub trait Summary {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String;
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里用&amp;lt;code&amp;gt;trait&amp;lt;&amp;#x2F;code&amp;gt;关键字定义了一个 trait。在 trait 内部，声明了一个方法，实现这个 trait 的类型可以调用这个方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在方法声明后，没有方法体，而是用分号结束。任何实现了这个 trait 的类型都必须自己实现这个方法的方法体。编译器会强制限定类型中实现的方法和 trait 中的方法声明是完全一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;trait 可以声明多个方法，每个方法占一行并以分号结束。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lei-xing-shi-xian-trait&amp;quot;&amp;gt;类型实现 trait&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;{}, by {} ({})&amp;amp;quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;{}: {}&amp;amp;quot;, self.username, self.content)
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在类型上实现 trait 和普通的方法扩展类似。不同之处在于，在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;之后需要加上 trait 名称，然后在加上&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;关键字，最后是类型名称。在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块里有和 trait 一样的方法声明，但是此时需要实现方法体。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在实现 trait 后，就可以在&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;类型的实例上调用实现的方法了，调用方式和普通的方法一样。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let tweet = Tweet {
    username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
    content: String::from(
        &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
    ),
    reply: false,
    retweet: false,
};

println!(&amp;amp;quot;1 new tweet: {}&amp;amp;quot;, tweet.summarize());
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;注意由于我们所有代码写在一个文件中，因此我们可以直接使用，当其他人实现这个 trait 时，则需要通过之前章节讲的模块规则，把 trait 先引入然后才能使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;trait 实现的一条限制是，当被实现的 trait 或者要实现的类型是我们 crate 的本地 trait 或类型时，才可以进行实现。例如，可以在&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;上实现标准库的&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;trait，因为&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;是我们的本地类型；也可以在&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上实现&amp;lt;code&amp;gt;Summary&amp;lt;&amp;#x2F;code&amp;gt;trait，因为&amp;lt;code&amp;gt;Summary&amp;lt;&amp;#x2F;code&amp;gt;trait 是我们的本地 trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;但是我们不能在外部类型上实现外部 trait，例如在&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上实现&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;。这个限制是程序属性之一称之为&amp;lt;em&amp;gt;连贯性（coherence）&amp;lt;&amp;#x2F;em&amp;gt;，更准确的说应该称之为&amp;lt;em&amp;gt;孤儿规则（orphan rule）&amp;lt;&amp;#x2F;em&amp;gt;。这条规则确保别人不能修改你的代码，反之亦然。如果没有这条规则，那么两个 crate 可以同时给同一个类型实现同一个 trait，这样编译器就不知道要调用哪个实现了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mo-ren-shi-xian&amp;quot;&amp;gt;默认实现&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;有时在定义 trait 时，对它下面的方法实现默认的逻辑。之后，在我们实现 trait 时，可以选择保留或者覆盖默认实现。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub trait Summary {
    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        String::from(&amp;amp;quot;(Read more...)&amp;amp;quot;)
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在不覆盖默认实现时，&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;后面跟一个空的 block 就好。trait 进行方法的默认逻辑编写，不会影响我们实现该 trait 的代码，因为覆盖和实现 trait 在语法上都是一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;默认实现的方法中，可以调用 trait 中的其他方法，就算被调用的方法没有默认实现。通过这种方式，trait 可以提供很多有用的功能，而我们只需要实现其中一部分代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub trait Summary {
    fn summarize_author(&amp;amp;amp;self) -&amp;amp;gt; String;

    fn summarize(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;(Read more from {}...)&amp;amp;quot;, self.summarize_author())
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;要使用&amp;lt;code&amp;gt;summarize&amp;lt;&amp;#x2F;code&amp;gt;方法，需要先实现它调用的&amp;lt;code&amp;gt;summarize_author&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Summary for Tweet {
    fn summarize_author(&amp;amp;amp;self) -&amp;amp;gt; String {
        format!(&amp;amp;quot;@{}&amp;amp;quot;, self.username)
    }
}

let tweet = Tweet {
    username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
    content: String::from(
        &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
    ),
    reply: false,
    retweet: false,
};

println!(&amp;amp;quot;1 new tweet: {}&amp;amp;quot;, tweet.summarize());

&amp;amp;#x2F;&amp;amp;#x2F; output: 1 new tweet: (Read more from @horse_ebooks...)
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;覆盖实现的方法是不可能调用同一个默认方法的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;trait-zuo-wei-can-shu&amp;quot;&amp;gt;Trait 作为参数&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法将 trait 作为参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify(item: &amp;amp;amp;impl Summary) {
    println!(&amp;amp;quot;Breaking news! {}&amp;amp;quot;, item.summarize());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们在参数&amp;lt;code&amp;gt;item&amp;lt;&amp;#x2F;code&amp;gt;之后没有指定数据类型，而是用&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字和 trait 名称。这样这个参数就可以接收任何实现了这个 trait 的类型。在&amp;lt;code&amp;gt;notify&amp;lt;&amp;#x2F;code&amp;gt;函数体中，可以通过&amp;lt;code&amp;gt;item&amp;lt;&amp;#x2F;code&amp;gt;调用所有&amp;lt;code&amp;gt;Summary&amp;lt;&amp;#x2F;code&amp;gt;上被&amp;lt;code&amp;gt;item&amp;lt;&amp;#x2F;code&amp;gt;的类型实现了的方法或者默认方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;trait-bound-syntax&amp;quot;&amp;gt;Trait Bound Syntax&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;方法是另外一种形式的语法糖，该形式成为&amp;lt;em&amp;gt;trait 绑定（trait bound）&amp;lt;&amp;#x2F;em&amp;gt;。它的代码如下：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify&amp;amp;lt;T: Summary&amp;amp;gt;(item: &amp;amp;amp;T) {
    println!(&amp;amp;quot;Breaking news! {}&amp;amp;quot;, item.summarize());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这种形式跟&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法等价，但是比较冗长。&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法使用更方便，并且在大多数简单场景下代码更简洁。trait 绑定能解决更复杂的场景。比如两个参数的情况：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify(item1: &amp;amp;amp;impl Summary, item2: &amp;amp;amp;impl Summary) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果我们想要&amp;lt;code&amp;gt;item1&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;item2&amp;lt;&amp;#x2F;code&amp;gt;的类型是不同的，那么&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;方法更合适。但是如果需要强制两个参数的类型是一致的，那么只有 trait 绑定能实现。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify&amp;amp;lt;T: Summary&amp;amp;gt;(item: &amp;amp;amp;T) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;泛型参数&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;保证&amp;lt;code&amp;gt;item1&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;item2&amp;lt;&amp;#x2F;code&amp;gt;的类型必须是一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;tong-guo-yu-fa-sheng-ming-duo-ge-trait-bound&amp;quot;&amp;gt;通过&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;语法声明多个 trait bound&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们可以指定多个 trait bound。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify(item: &amp;amp;amp;(impl Summary + Display)) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;语法也适用于 trait bound&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn notify&amp;amp;lt;T: Summary + DisPlay&amp;amp;gt;(item: &amp;amp;amp;T) {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;shi-yong-wheretiao-jian-jian-hua-trait-bound&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;where&amp;lt;&amp;#x2F;code&amp;gt;条件简化 trait bound&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;使用太多 trait bound 也有缺点。每个泛型参数都有它自己的 trait bound，因此多个泛型参数的函数在泛型参数列表和参数列表中会包含很多 trait bound 信息，让函数声明变得冗长难以理解。因此，在函数声明后引入&amp;lt;code&amp;gt;where&amp;lt;&amp;#x2F;code&amp;gt;条件可以做到简化的作用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F; before
fn some_function&amp;amp;lt;T: Display + Clone, U: Clone + Debug&amp;amp;gt;(t: &amp;amp;amp;T, u: &amp;amp;amp;U) -&amp;amp;gt; i32 {
&amp;amp;#x2F;&amp;amp;#x2F; with where
fn some_function&amp;amp;lt;T, U&amp;amp;gt;(t: &amp;amp;amp;T, u: &amp;amp;amp;U) -&amp;amp;gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;returning-types-that-implement-traits&amp;quot;&amp;gt;Returning Types that Implement Traits&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法同样可以用在函数声明中的返回类型部分。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn returns_summarizable() -&amp;amp;gt; impl Summary {
    Tweet {
        username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
        content: String::from(
            &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
        ),
        reply: false,
        retweet: false,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;返回实现了特定 trait 类型的功能在闭包和迭代器的场景下非常有用。闭包和迭代器创建的类型只有编译器知道，或者列举这些类型会非常长。&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法让你只需要指定返回一个实现了&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型就好，不用写过长的类型代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;但是，&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法用于返回类型时，函数只能返回一种类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn returns_summarizable(switch: bool) -&amp;amp;gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &amp;amp;quot;Penguins win the Stanley Cup Championship!&amp;amp;quot;,
            ),
            location: String::from(&amp;amp;quot;Pittsburgh, PA, USA&amp;amp;quot;),
            author: String::from(&amp;amp;quot;Iceburgh&amp;amp;quot;),
            content: String::from(
                &amp;amp;quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&amp;amp;quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&amp;amp;quot;horse_ebooks&amp;amp;quot;),
            content: String::from(
                &amp;amp;quot;of course, as you probably already know, people&amp;amp;quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数返回&amp;lt;code&amp;gt;NewsArticle&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Tweet&amp;lt;&amp;#x2F;code&amp;gt;两种类型，由于被&amp;lt;code&amp;gt;impl Trait&amp;lt;&amp;#x2F;code&amp;gt;语法在编译器中的实现所限制，这个函数是不会编译通过的。在后面的章节会介绍到如何实现这种功能。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;xiu-gai-largesthan-shu&amp;quot;&amp;gt;修改&amp;lt;code&amp;gt;largest&amp;lt;&amp;#x2F;code&amp;gt;函数&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;现在我们可以修改本章开头的示例函数了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn largest&amp;amp;lt;T: PartialOrd + Copy&amp;amp;gt;(list: &amp;amp;amp;[T]) -&amp;amp;gt; T {
    let mut largest = list[0];

    for &amp;amp;amp;item in list {
        if item &amp;amp;gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;amp;amp;number_list);
    println!(&amp;amp;quot;The largest number is {}&amp;amp;quot;, result);

    let char_list = vec![&amp;amp;#x27;y&amp;amp;#x27;, &amp;amp;#x27;m&amp;amp;#x27;, &amp;amp;#x27;a&amp;amp;#x27;, &amp;amp;#x27;q&amp;amp;#x27;];

    let result = largest(&amp;amp;amp;char_list);
    println!(&amp;amp;quot;The largest char is {}&amp;amp;quot;, result);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;PartialOrd&amp;lt;&amp;#x2F;code&amp;gt;trait 限制参数类型要有&amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符计算的能力，&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;trait 限制参数类型只能是&amp;lt;em&amp;gt;stack-only&amp;lt;&amp;#x2F;em&amp;gt;的，或者可以用&amp;lt;code&amp;gt;Clone&amp;lt;&amp;#x2F;code&amp;gt;trait 替代。但是&amp;lt;code&amp;gt;clone&amp;lt;&amp;#x2F;code&amp;gt;方法会在 heap 上分配内存，如果数据量很大的话会有性能损耗。另外一种解决方案是通过返回引用&amp;lt;code&amp;gt;&amp;amp;amp;T&amp;lt;&amp;#x2F;code&amp;gt;而不是&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;。则可以省略&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;using-trait-bounds-to-conditionally-implement-methods&amp;quot;&amp;gt;Using Trait Bounds to Conditionally Implement Methods&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;将 Trait bound 用于&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;可以让我们有条件的实现 trait 中的方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt::Display;

struct Pair&amp;amp;lt;T&amp;amp;gt; {
    x: T,
    y: T,
}

impl&amp;amp;lt;T&amp;amp;gt; Pair&amp;amp;lt;T&amp;amp;gt; {
    fn new(x: T, y: T) -&amp;amp;gt; Self {
        Self { x, y }
    }
}

impl&amp;amp;lt;T: Display + PartialOrd&amp;amp;gt; Pair&amp;amp;lt;T&amp;amp;gt; {
    fn cmp_display(&amp;amp;amp;self) {
        if self.x &amp;amp;gt;= self.y {
            println!(&amp;amp;quot;The largest member is x = {}&amp;amp;quot;, self.x);
        } else {
            println!(&amp;amp;quot;The largest member is y = {}&amp;amp;quot;, self.y);
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Pair&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;上的 new 方法任何类型都会被实现，而&amp;lt;code&amp;gt;cmp_display&amp;lt;&amp;#x2F;code&amp;gt;方法只有&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型实现了&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;partialOrd&amp;lt;&amp;#x2F;code&amp;gt;trait 时才会被实现。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这个限制条件也可以用于给类型实现 trait 时。为某些满足 trait bound 条件的类型实现特定的 trait 在 Rust 中称为&amp;lt;em&amp;gt;blanket implementations&amp;lt;&amp;#x2F;em&amp;gt;，这个做法被广泛的应用于 Rust 标准库中。例如，标准库实现了为所有实现了&amp;lt;code&amp;gt;Display&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型实现了&amp;lt;code&amp;gt;ToString&amp;lt;&amp;#x2F;code&amp;gt;trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;T: Display&amp;amp;gt; ToString for T {
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Trait 和 trait bound 可以让我们通过泛型参数抽象代码，同时可以向编译器指明我们需要泛型类型具有什么样的功能。然后编译器就能根据我们提供的信息去检查我们具体使用的类型有没有实现这些功能。在动态类型语言中，如果我们调用一个类型上没有定义的方法，那么会在运行时出现错误。Rust 在编译阶段就解决了这些错误，它强制我们在代码运行之前解决这些潜在错误，因此我们也不需要再在运行时代码中检查方法是否存在。这样既提升了性能，又没有损失泛型的动态性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-yong-lifetimes-yan-zheng-yin-yong&amp;quot;&amp;gt;Section 3 - 用 Lifetimes 验证引用&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;我们在之前的&amp;lt;a href=&amp;quot;&amp;#x2F;Rust&amp;#x2F;02-ownership.html#section-2-references-and-borrowing&amp;quot;&amp;gt;章节&amp;lt;&amp;#x2F;a&amp;gt;中没有讲到的一个概念是，Rust 中的引用都有&amp;lt;em&amp;gt;生命周期（lifetimes）&amp;lt;&amp;#x2F;em&amp;gt;，是引用有效的作用域范围。大多数情况下，生命周期是隐式和被推断的，就像数据类型是被推断的一样。当类型有多种可能时，我们就必须指定类型。同样的，当生命周期通过集中不同的方式关联时，我们也必须指定。Rust 要求我们使用泛型生命周期参数指明关联方式来确保真正的引用在运行时是绝对有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;生命周期的概念与其他语言中的工具有些不同，可以说是 Rust 最独特的功能。这节不会介绍生命周期的全部内容，但是会对你有可能遇到的多种生命周期语法作讨论，好熟悉生命周期的概念。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fang-zhi-xuan-kong-zhi-zhen&amp;quot;&amp;gt;防止悬空指针&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;生命周期的主要目标是防止出现悬空指针。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let r;

    {
        let x = 5;
        r = &amp;amp;amp;x;
    }

    println!(&amp;amp;quot;r: {}&amp;amp;quot;, r);
    &amp;amp;#x2F;&amp;amp;#x2F; error[E0597]: `x` does not live long enough
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;假如我们运行这段代码，编译器会报一个错误。因为内部作用域结束时，x 和它的引用也被销毁了。如果这个代码能够运行，那么 r 将指向一块已经被释放的内存，之后代码的运行肯定不符合我们的预期。Rust 通过 borrow checker 判断代码是否有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;the-borrow-checker&amp;quot;&amp;gt;The Borrow Checker&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 编译器用&amp;lt;em&amp;gt;borrow checker&amp;lt;&amp;#x2F;em&amp;gt;来比较作用域，判断引用是否有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let r;                &amp;amp;#x2F;&amp;amp;#x2F; ---------+-- &amp;amp;#x27;a
                          &amp;amp;#x2F;&amp;amp;#x2F;          |
    {                     &amp;amp;#x2F;&amp;amp;#x2F;          |
        let x = 5;        &amp;amp;#x2F;&amp;amp;#x2F; -+-- &amp;amp;#x27;b  |
        r = &amp;amp;amp;x;           &amp;amp;#x2F;&amp;amp;#x2F;  |       |
    }                     &amp;amp;#x2F;&amp;amp;#x2F; -+       |
                          &amp;amp;#x2F;&amp;amp;#x2F;          |
    println!(&amp;amp;quot;r: {}&amp;amp;quot;, r); &amp;amp;#x2F;&amp;amp;#x2F;          |
}                         &amp;amp;#x2F;&amp;amp;#x2F; ---------+
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;用&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;代表 r 的生命周期，&amp;lt;code&amp;gt;&amp;#x27;b&amp;lt;&amp;#x2F;code&amp;gt;代表 x 的生命周期。可以看到，内部的&amp;lt;code&amp;gt;&amp;#x27;b&amp;lt;&amp;#x2F;code&amp;gt;生命周期是要比外部的&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;生命周期小的。在编译阶段，编译器会对比这两个变量的生命周期大小，它会发现&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;的生命周期更大，但是它指向了一个生命周期更小的内存区域，所以编译器会报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let x = 5;            &amp;amp;#x2F;&amp;amp;#x2F; ----------+-- &amp;amp;#x27;b
                          &amp;amp;#x2F;&amp;amp;#x2F;           |
    let r = &amp;amp;amp;x;           &amp;amp;#x2F;&amp;amp;#x2F; --+-- &amp;amp;#x27;a  |
                          &amp;amp;#x2F;&amp;amp;#x2F;   |       |
    println!(&amp;amp;quot;r: {}&amp;amp;quot;, r); &amp;amp;#x2F;&amp;amp;#x2F;   |       |
                          &amp;amp;#x2F;&amp;amp;#x2F; --+       |
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;的生命周期&amp;lt;code&amp;gt;&amp;#x27;b&amp;lt;&amp;#x2F;code&amp;gt;比&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;的生命周期&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;大，那么&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;可以指向&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;，因为当&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;有效时，它的引用&amp;lt;code&amp;gt;r&amp;lt;&amp;#x2F;code&amp;gt;也一定有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;han-shu-de-fan-xing-sheng-ming-zhou-qi&amp;quot;&amp;gt;函数的泛型生命周期&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;写一个比较两个字符串长度的函数&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;。接收两个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;参数，返回一个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest(x: &amp;amp;amp;str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {
    if x.len() &amp;amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;amp;quot;abcd&amp;amp;quot;);
    let string2 = &amp;amp;quot;xyz&amp;amp;quot;;

    let result = longest(string1.as_str(), string2);
    println!(&amp;amp;quot;The longest string is {}&amp;amp;quot;, result);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0106]: missing lifetime specifier

&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;函数的实现，编译阶段会报错。返回类型需要一个泛型生命周期参数，因为 Rust 不知道返回的引用指向&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;还是&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;。事实上因为&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;表达式，我们自己也不知道会指向哪一个。为了解决这个错误，需要定义泛型生命周期参数来确定引用之间的关系，然后&amp;lt;code&amp;gt;borrow checker&amp;lt;&amp;#x2F;code&amp;gt;才能进行分析。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;sheng-ming-zhou-qi-sheng-ming-yu-fa&amp;quot;&amp;gt;生命周期声明语法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;生命周期声明不会改变任何引用真正的生命周期。就像函数可以接收泛型类型参数来接收任何数据类型，通过定义泛型生命周期，函数也可以接收任何生命周期的引用。生命周期声明只描述了引用之间的生命周期关系，对运行时真正的生命周期没有影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;泛型生命周期的定义语法比较奇怪：生命周期参数的名称前面用一个单引号&amp;lt;code&amp;gt;&amp;#x27;&amp;lt;&amp;#x2F;code&amp;gt;开头，名称都是小写字母，并且像泛型参数一样名称长度很短。最常用的名称是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;。把生命周期参数放在引用的&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;符号后面，用空格将类型隔开。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;i32        &amp;amp;#x2F;&amp;amp;#x2F; a reference
&amp;amp;amp;&amp;amp;#x27;a i32     &amp;amp;#x2F;&amp;amp;#x2F; a reference with an explicit lifetime
&amp;amp;amp;&amp;amp;#x27;a mut i32 &amp;amp;#x2F;&amp;amp;#x2F; a mutable reference with an explicit lifetime
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;单独的生命周期声明没什么意义，因为它的作用是告知编译器引用之间的生命周期关系。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;zai-han-shu-sheng-ming-zhong-shi-yong-sheng-ming-zhou-qi-sheng-ming&amp;quot;&amp;gt;在函数声明中使用生命周期声明&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;现在开始在&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;函数上下文中定义生命周期。泛型生命周期参数需要像泛型类型参数一样，包在&amp;lt;code&amp;gt;&amp;amp;lt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;中。生命周期参数的声明中有一条限制是，所有的参数和返回值必须要有一致的生命周期参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt;(x:&amp;amp;amp;&amp;amp;#x27;a str, y:&amp;amp;amp;&amp;amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str {
    if x.len &amp;amp;gt; y.len {
        x
    } else {
        y
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;longest&amp;lt;&amp;#x2F;code&amp;gt;函数接收两个参数，且生命周期长度至少是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;，且返回值的生命周期也是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;。意味着函数返回值的生命周期和参数中生命周期较小的那个相等。记住，当我们定义声明生命周期参数时，对参数和返回值真正的生命周期没有任何影响。它的作用是我们指明 borrow checker 需要拒绝不符合这些限制的参数。函数不需要知道参数的确切生命周期，只需要把函数声明中符合条件的最小生命周期替换为&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;声明生命周期只需要在函数签名中，Rust 可以自动分析代码。然而当函数有外部代码或者引用的时候，Rust 编译器就不能靠自己分析生命周期了，所以需要手动指定。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;泛型生命周期会等于参数&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;中生命周期较小的那一个。因为我们指定返回值的生命周期也是&amp;lt;code&amp;gt;&amp;#x27;a&amp;lt;&amp;#x2F;code&amp;gt;，所以返回值的生命周期也和&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;中较小的那一个相等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们通过一个例子来看当参数真正的生命周期不相等时，生命周期参数如何对函数做限制。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let string1 = String::from(&amp;amp;quot;long string is long&amp;amp;quot;);

    {
        let string2 = String::from(&amp;amp;quot;xyz&amp;amp;quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&amp;amp;quot;The longest string is {}&amp;amp;quot;, result);
    }
}

&amp;amp;#x2F;&amp;amp;#x2F; output: The longest string is long string is long
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;string1&amp;lt;&amp;#x2F;code&amp;gt;的生命周期是外部作用域（main 函数）。&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;的生命周期是内部作用域（代码块）。&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;引用某个玩意儿，生命周期是内部作用域。这个代码能够正常执行并输出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来，把&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;的定义和&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;移到外部作用域。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let string1 = String::from(&amp;amp;quot;long string is long&amp;amp;quot;);
    let result;

    {
        let string2 = String::from(&amp;amp;quot;xyz&amp;amp;quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&amp;amp;quot;The longest string is {}&amp;amp;quot;, result);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0597]: `string2` does not live long enough
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这时候编译会报错。之前提到返回值的生命周期等于参数生命周期较小的那个，这里也就是&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;。但是当&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;的引用被使用时，&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;的生命周期已经结束，其内存已经被释放，所以&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;是一个悬空指针，Rust 编译器不会让这种情况通过编译。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这个错误表示，&amp;lt;code&amp;gt;result&amp;lt;&amp;#x2F;code&amp;gt;要在&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;宏调用它的时候有效，则&amp;lt;code&amp;gt;string2&amp;lt;&amp;#x2F;code&amp;gt;就必须在外部作用域结束前有效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;thinking-in-terms-of-lifetimes&amp;quot;&amp;gt;Thinking in Terms of Lifetimes&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;定义函数生命周期参数的方式取决于函数的具体功能。如果你的函数任何情况下都返回第一个参数，那么就不需要对第二个参数进行生命周期定义。因为第二个参数与第一个参数或者返回值没有任何生命周期关系。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;&amp;amp;#x27;a str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str {
    x
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当函数返回一个引用时，它的生命周期要和参数列表其中一个参数的生命周期匹配。如果函数的返回值没有指向任何参数，而是指向一个函数内部创建的值，那么这个返回值在函数结束后会成为一个悬空指针。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn longest&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str {
    let result = String::from(&amp;amp;quot;really long string&amp;amp;quot;);
    result.as_str()
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0515]: cannot return value referencing local variable `result`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;即使我们定义了泛型生命周期参数，编译器还是不会通过这个代码，因为返回值本质上和参数没有任何关联。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;总之，生命周期语法需要函数参数和返回值之间有所关联。只有这样 Rust 编译器才有足够的判断依据来允许执行内存安全的操作和禁止任何可能创建悬空指针的操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lifetime-annotations-in-struct-definitions&amp;quot;&amp;gt;Lifetime Annotations in Struct Definitions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;至今我们定义的结构体字段都是有所有权的，结构体字段也可以包含引用。当结构体字段包含引用的时候，需要对每个引用类型的字段定义生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct ImportantExcerpt&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; {
    part: &amp;amp;amp;&amp;amp;#x27;a str,
}

fn main() {
    let novel = String::from(&amp;amp;quot;Call me Ishmael. Some years ago...&amp;amp;quot;);
    let first_sentence = novel.split(&amp;amp;#x27;.&amp;amp;#x27;).next().expect(&amp;amp;quot;Could not find a &amp;amp;#x27;.&amp;amp;#x27;&amp;amp;quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个结构体有一个字段&amp;lt;code&amp;gt;part&amp;lt;&amp;#x2F;code&amp;gt;，存储一个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型的数据。泛型生命周期参数用&amp;lt;code&amp;gt;&amp;amp;lt;&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;包起来，放在结构体名称和结构体代码块之间。这个定义意味着，&amp;lt;code&amp;gt;ImportantExcerpt&amp;lt;&amp;#x2F;code&amp;gt;类型的实例，其生命周期不超过&amp;lt;code&amp;gt;part&amp;lt;&amp;#x2F;code&amp;gt;字段引用的生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;main&amp;lt;&amp;#x2F;code&amp;gt;方法创建了一个&amp;lt;code&amp;gt;ImportantExcerpt&amp;lt;&amp;#x2F;code&amp;gt;实例，并且将&amp;lt;code&amp;gt;novel&amp;lt;&amp;#x2F;code&amp;gt;变量的部分引用赋值给实例的字段。&amp;lt;code&amp;gt;novel&amp;lt;&amp;#x2F;code&amp;gt;在实例创建之前初始化，而且&amp;lt;code&amp;gt;novel&amp;lt;&amp;#x2F;code&amp;gt;在作用域执行结束，实例被释放后才会被释放，因此实例中的引用是有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lifetime-elision&amp;quot;&amp;gt;Lifetime Elision&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;现在了解了所有的引用都有生命周期，而且你需要为使用了引用的结构体和函数声明生命周期参数。之前我们写过一个获取句子中第一个单词的&amp;lt;a href=&amp;quot;https:&amp;#x2F;&amp;#x2F;leokang28.github.io&amp;#x2F;blog&amp;#x2F;08-generic-types-traits-and-lifetimes&amp;#x2F;Rust&amp;#x2F;2-ownership.html#section-3-the-slice-type&amp;quot;&amp;gt;方法&amp;lt;&amp;#x2F;a&amp;gt;，这个函数没有生命周期声明，而且编译通过了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;amp;amp;item) in bytes.iter().enumerate() {
        if item == b&amp;amp;#x27; &amp;amp;#x27; {
            return &amp;amp;amp;s[0..i];
        }
    }

    &amp;amp;amp;s[..]
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个函数没有生命周期声明但是编译通过是因为一些历史原因：早起的 Rust 版本（&amp;amp;lt;1.0）中，这个代码是不能编译通过的，因为要求所有引用都声明声明周期。在那个版本下，这个函数的签名是&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(s: &amp;amp;amp;&amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;&amp;#x27;a str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;在编写了大量的 Rust 代码之后，Rust 核心团队发现，Rust 程序员在一些特定场景下需要一直重复同样的生命周期声明。这些场景是可预测而且遵循特定的模式的。维护者将这些模式加入编译器，这样编译器就能对这些场景进行生命周期推断，而不需要程序员显式指定了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;今后可能还会出现其他特定的模式，然后被加入到编译器中。以后需要指定生命周期的场景可能会越来越少。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这些用来分析引用生命周期，被编写进 Rust 编译器的模式被称为&amp;lt;em&amp;gt;生命周期省略规则（lifetime elision rules）&amp;lt;&amp;#x2F;em&amp;gt;。这不是给程序员指定的规则，而是编译器的一个规则集合，编译器通过这个集合判断如果你的代码场景符合其中的某个模式，那么就不用显式声明生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;函数参数的生命周期称为&amp;lt;em&amp;gt;input lifetimes&amp;lt;&amp;#x2F;em&amp;gt;，函数返回值的生命周期称为&amp;lt;em&amp;gt;output lifetimes&amp;lt;&amp;#x2F;em&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当没有指定生命周期时，编译器通过三个规则来判断引用的生命周期。规则一适用于&amp;lt;em&amp;gt;input lifetimes&amp;lt;&amp;#x2F;em&amp;gt;，规则二三适用于&amp;lt;em&amp;gt;output lifetimes&amp;lt;&amp;#x2F;em&amp;gt;。如果通过三条规则编译器都不能确定引用的生命周期，则会报错退出。这三条规则同时适用于&amp;lt;code&amp;gt;fn&amp;lt;&amp;#x2F;code&amp;gt;声明和&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;声明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;规则一：每个引用参数都有它自己的生命周期。即，一个参数的函数可以获取到一个生命周期&amp;lt;code&amp;gt;fn foo&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a i32)&amp;lt;&amp;#x2F;code&amp;gt;，两个参数的函数获取到两个生命周期&amp;lt;code&amp;gt;fn foo&amp;amp;lt;&amp;#x27;a, &amp;#x27;b&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a i32, y: &amp;amp;amp;&amp;#x27;b i32)&amp;lt;&amp;#x2F;code&amp;gt;。依此类推。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;规则二：如果明确只有一个 input lifetime 参数，那么 output lifetime 跟它相同。&amp;lt;code&amp;gt;fn foo&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a i32) -&amp;amp;gt; &amp;amp;amp;&amp;#x27;a i32&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;规则三：如果有多个 input lifetime 参数，但是其中之一是&amp;lt;code&amp;gt;&amp;amp;amp;self&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;&amp;amp;amp;mut self&amp;lt;&amp;#x2F;code&amp;gt;，那么所有 output lifetimes 都跟&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;的生命周期相同。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;我们在编译器的角度看几个函数签名。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word(s: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;首先应用规则一，每个参数都有自己的生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(s:&amp;amp;amp;&amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;接着规则二也符合：只有一个参，那么返回值的生命周期也确定了&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn first_word&amp;amp;lt;&amp;#x27;a&amp;amp;gt;(s:&amp;amp;amp;&amp;#x27;a str) -&amp;amp;gt; &amp;amp;amp;&amp;#x27;a str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;在看另外一个例子：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn longest(x: &amp;amp;amp;str, y: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;首先规则一：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fn longest&amp;amp;lt;&amp;#x27;a, &amp;#x27;b&amp;amp;gt;(x: &amp;amp;amp;&amp;#x27;a str, y: &amp;amp;amp;&amp;#x27;b str) -&amp;amp;gt; &amp;amp;amp;str {&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;接下来规则二不适用，因为有两个参数；规则三也不适用，因为它不是一个方法，没有&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;参数。三条规则结束，还没能确定返回值的生命周期，此时编译器报错退出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;lifetime-annotations-in-method-definitions&amp;quot;&amp;gt;Lifetime Annotations in Method Definitions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当我们实现方法当时候声明其生命周期时，它的定义方式和泛型类型一样。我们在何处定义和使用生命周期参数取决于他们是否和方法的参数或者实例字段以及返回值相关。结构体字段的生命周期名称任何情况下都需要在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字后声明和在结构体名称中使用，因为它是结构体声明的一部分。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在方法签名中，引用可能会跟实例字段的生命周期绑定，也可能是独立的。此外，&amp;lt;em&amp;gt;生命周期省略规则&amp;lt;&amp;#x2F;em&amp;gt;通常使方法生命中不需要定义生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通过之前的&amp;lt;code&amp;gt;ImportantExcerpt&amp;lt;&amp;#x2F;code&amp;gt;结构体来看一些例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; ImportantExcerpt&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; {
    fn level(&amp;amp;amp;self) -&amp;amp;gt; i32 {
        3
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;后声明生命周期参数，在结构体名称后使用是必须的。但是由于生命周期省略规则一，不需要在方法签名中声明生命周期。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; ImportantExcerpt&amp;amp;lt;&amp;amp;#x27;a&amp;amp;gt; {
    fn announce_and_return_part(&amp;amp;amp;self, announcement: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str {
        println!(&amp;amp;quot;Attention please: {}&amp;amp;quot;, announcement);
        self.part
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面是一个符合生命周期省略规则三的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;the-static-lifetime&amp;quot;&amp;gt;The Static Lifetime&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;一个需要说明的特殊生命周期是&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;，意思是引用在整个程序执行期间都有效。字符串字面量的生命周期都是&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;let s: &amp;amp;amp;&amp;#x27;static str = &amp;quot;I have a static lifetime.&amp;quot;;&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;因为字符串字面量是直接写入可执行文件的，程序运行期间一直存在，所以它的生命周期是&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;可能在报错时你会看到编译器建议你使用&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;生命周期。但是这些问题可能是由于创建悬空指针或者生命周期不匹配造成的，首先应当解决真正的问题而不是无脑&amp;lt;code&amp;gt;static&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-generic-type-parameters-trait-bounds-and-lifetimes-together&amp;quot;&amp;gt;Section 4 - Generic Type Parameters, Trait Bounds, and Lifetimes Together&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;让我们把这三个概念使用在一个函数定义中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt::Display;

fn longest_with_an_announcement&amp;amp;lt;&amp;amp;#x27;a, T&amp;amp;gt;(
    x: &amp;amp;amp;&amp;amp;#x27;a str,
    y: &amp;amp;amp;&amp;amp;#x27;a str,
    ann: T,
) -&amp;amp;gt; &amp;amp;amp;&amp;amp;#x27;a str
where
    T: Display,
{
    println!(&amp;amp;quot;Announcement! {}&amp;amp;quot;, ann);
    if x.len() &amp;amp;gt; y.len() {
        x
    } else {
        y
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Cargo and Crates.io</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;11-cargo-and-crates-io&#x2F;"/>
                <updated>2020-12-15T07:21:19+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;11-cargo-and-crates-io&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-11-guan-yu-cargo-he-crates-io&amp;quot;&amp;gt;Chapter 11 - 关于 Cargo 和 Crates.io&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;目前为止我们只使用到 cargo 创建、运行、测试、构建等基础功能。本章会介绍它的其他功能。包括：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;使用配置文件定制构建&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;在&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;发布库&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;使用工作空间管理大型项目&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;安装&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;上的可执行文件&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;定制化命令扩展 cargo&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;可以在&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;cargo&amp;#x2F;&amp;quot;&amp;gt;cargo 官方文档&amp;lt;&amp;#x2F;a&amp;gt;查看全部功能说明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-shi-yong-pei-zhi-wen-jian-ding-zhi-gou-jian&amp;quot;&amp;gt;Section 1 - 使用配置文件定制构建&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 中，*配置文件（release profiles）*是预定义的、可自定义的文件，不同的配置选项可以对代码编译进行控制。每个文件的配置都是独立的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;cargo 有两个主要的配置文件&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;dev&amp;lt;&amp;#x2F;code&amp;gt;配置文件。&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;命令会使用这个配置文件。包含针对开发环境的默认配置&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;release&amp;lt;&amp;#x2F;code&amp;gt;配置文件。&amp;lt;code&amp;gt;cargo build --release&amp;lt;&amp;#x2F;code&amp;gt;命令会使用这个配置文件。包含针对发布环境的默认配置。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;当&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中没有&amp;lt;code&amp;gt;[profile.*]&amp;lt;&amp;#x2F;code&amp;gt;声明时，cargo 会使用默认配置。对想要修改的配置文件加&amp;lt;code&amp;gt;[profile.*]&amp;lt;&amp;#x2F;code&amp;gt;声明，就可以对默认配置进行覆盖和定制化。例如：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;分别对&amp;lt;code&amp;gt;dev&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;release&amp;lt;&amp;#x2F;code&amp;gt;配置文件，针对&amp;lt;code&amp;gt;opt-level&amp;lt;&amp;#x2F;code&amp;gt;配置进行了定制化。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-fa-bu-crate-dao-crates-io&amp;quot;&amp;gt;Section 2 - 发布 Crate 到 Crates.io&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 和 Cargo 有很多功能，辅助包发布和查找。首先介绍三个功能然后再介绍如何发布自己的包。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;you-yong-de-wen-dang-zhu-shi&amp;quot;&amp;gt;有用的文档注释&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;准确描述你的包有助于让其他人更容易地了解如何使用、何时使用你的包，所以有用的文档很有必要。代码注释时使用双斜线&amp;lt;code&amp;gt;&amp;#x2F;&amp;#x2F;&amp;lt;&amp;#x2F;code&amp;gt;，Rust 也有专门针对文档的注释，称之为&amp;lt;em&amp;gt;文档注释（documentation comment）&amp;lt;&amp;#x2F;em&amp;gt;，文档注释会用来生成 html 页面。html 展示了你对公开 API 的介绍，文档内容应当是介绍如何使用你的 API，而不是描述你如何实现的这些 API。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;文档注释使用三斜线&amp;lt;code&amp;gt;&amp;#x2F;&amp;#x2F;&amp;#x2F;&amp;lt;&amp;#x2F;code&amp;gt;，并且支持 md 语法。文档注释放置于被描述对象之前。例如我们创建一个&amp;lt;code&amp;gt;my_crate&amp;lt;&amp;#x2F;code&amp;gt;库，里面包含一个&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; Adds one to the number given.
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; # Examples
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; ```
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; let arg = 5;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; let answer = my_crate::add_one(arg);
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F;
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; assert_eq!(6, answer);
&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; ```
pub fn add_one(x: i32) -&amp;amp;gt; i32 {
    x + 1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们描述了&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;函数的功能是什么，然后&amp;lt;code&amp;gt;Examples&amp;lt;&amp;#x2F;code&amp;gt;下面是一个示例代码块。&amp;lt;code&amp;gt;cargo doc&amp;lt;&amp;#x2F;code&amp;gt;命令可以基于这些描述生成 html 文档。这个命令运行了 Rust 提供的&amp;lt;code&amp;gt;rustdoc&amp;lt;&amp;#x2F;code&amp;gt;工具，并且将生成的 html 文件放置于&amp;lt;em&amp;gt;target&amp;#x2F;doc&amp;lt;&amp;#x2F;em&amp;gt;目录下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;--open&amp;lt;&amp;#x2F;code&amp;gt;参数会在文档创建完成之后打开浏览器，效果如下：
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-165110@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;chang-yong-mo-kuai&amp;quot;&amp;gt;常用模块&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们已经使用&amp;lt;code&amp;gt;# Examples&amp;lt;&amp;#x2F;code&amp;gt;md 语法，创建了一个示例代码模块，下面还有一些常用的模块：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Panics&amp;lt;&amp;#x2F;strong&amp;gt;：会导致代码出错的场景。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Errors&amp;lt;&amp;#x2F;strong&amp;gt;：如果函数返回的是一个&amp;lt;code&amp;gt;Result&amp;lt;&amp;#x2F;code&amp;gt;，描述一下返回的错误类型，以及如何处理这些错误。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Safety&amp;lt;&amp;#x2F;strong&amp;gt;：如果这个函数调用是&amp;lt;code&amp;gt;unsafe&amp;lt;&amp;#x2F;code&amp;gt;的，应当描述函数为何是&amp;lt;code&amp;gt;unsale&amp;lt;&amp;#x2F;code&amp;gt;，以及涵盖希望由调用者维护的不变性（invariants）。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h4 id=&amp;quot;wen-dang-zhu-shi-ce-shi-yong-li&amp;quot;&amp;gt;文档注释测试用例&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;命令会将文档注释中 examples 模块下的示例代码作为测试用例运行。这会保证你的代码和示例代码是同步的，因为当你修改其中任意部分时，如果出错文档测试会捕获到。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;mu-lu-xing-miao-shu&amp;quot;&amp;gt;目录性描述&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;对 crate 包含内容的一个总体描述。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F;! # My Crate
&amp;amp;#x2F;&amp;amp;#x2F;!
&amp;amp;#x2F;&amp;amp;#x2F;! `my_crate` is a collection of utilities to make performing certain
&amp;amp;#x2F;&amp;amp;#x2F;! calculations more convenient.

&amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; Adds one to the number given.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-171515@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-pub-usedao-chu-gong-you-api&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;导出公有 API&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在写代码时，你的代码结构可能自己比较清楚，但对于使用者来说可能不是特别方便。在组织代码时，可能进行了很深的模块嵌套，但是当使用者想要使用一个定义的很深的 API 时，找到它就比较费劲了。例如：&amp;lt;code&amp;gt;use my_crate::some_module::another_module::UsefulType;&amp;lt;&amp;#x2F;code&amp;gt;。显然&amp;lt;code&amp;gt;use my_crate::UsefulType&amp;lt;&amp;#x2F;code&amp;gt;对调用者更加的友好。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因此当发布包时，API 的结构是首先要考虑的问题。因为使用者不会像你一样熟悉你的代码结构。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当一个 API 对调用者不太友好时，你不需要修改你的代码组织，你可以使用&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;二次导出。&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;导入一个共有 API，并且将其再对外公开暴露。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;创建一个&amp;lt;code&amp;gt;art&amp;lt;&amp;#x2F;code&amp;gt;包，它的内容如下所示：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;&amp;amp;#x2F;&amp;amp;#x2F;! # Art
&amp;amp;#x2F;&amp;amp;#x2F;!
&amp;amp;#x2F;&amp;amp;#x2F;! A library for modeling artistic concepts.

pub mod kinds {
    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; Combines two primary colors in equal amounts to create
    &amp;amp;#x2F;&amp;amp;#x2F;&amp;amp;#x2F; a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&amp;amp;gt; SecondaryColor {
        &amp;amp;#x2F;&amp;amp;#x2F; --snip--
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;查看它的文档：
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-173414@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;PrimaryColor&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;SecondaryColor&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;mix&amp;lt;&amp;#x2F;code&amp;gt;都没有在首页展示出来，需要我们手动点入这些模块。并且其他模块调用我们的包时，引用的链路特别长：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;为了移除这个调用者冗长的调用链路，我们可以在自己的包中，将这些 API 进行二次导出：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;PrimaryColor&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;SecondaryColor&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;mix&amp;lt;&amp;#x2F;code&amp;gt;都更容易找到了，文档如下：
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;cargo&amp;#x2F;QQ20200901-174144@2x.png&amp;quot; alt=&amp;quot;rust doc&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;并且调用者在引用代码，代码量也更少：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use art::PrimaryColor;
use art::mix;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;chuang-jian-crates-io-zhang-hao&amp;quot;&amp;gt;创建 Crates.io 账号&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;首先去&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;注册一个账号，验证邮箱之后，获取 API token。然后在终端使用 token 登陆。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;cargo login abcdefghijklmnopqrstuvwxyz012345
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;token 会被存储在*~&amp;#x2F;.cargo&amp;#x2F;credentials.*文件下。注意不要将 token 分享出去。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;wei-xin-bao-tian-jia-yuan-shu-ju&amp;quot;&amp;gt;为新包添加元数据&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;发布之前需要在&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件的[package]模块下追加一些元数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;注意你的包名必须是唯一的。当你在本地开发时，跟目录名称可以随意，但是在发布时，元数据当中的包名称必须是唯一的，不能跟别人的包名称冲突。因此在发布之前可以去网站上先搜索一下你的名字有没有被使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件下的[package]模块中定义包名称：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[package]
name = &amp;amp;quot;ksleo_public_test&amp;amp;quot;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当你选好唯一的名称之后，使用&amp;lt;code&amp;gt;cargo publish&amp;lt;&amp;#x2F;code&amp;gt;发布，会出现一个错误&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;cargo&amp;#x2F;reference&amp;#x2F;manifest.html for how to upload metadata&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;因为你的项目还缺少一些关键信息：描述和证书。描述你的包是做什么用，并且你的包是基于什么证书给别人使用的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[package]
license = &amp;amp;quot;MIT&amp;amp;quot;
description = &amp;amp;quot;just for pub test&amp;amp;quot;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在[package]模块下加入这些内容后，就可以成功发布了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fa-bu-xin-ban-ben&amp;quot;&amp;gt;发布新版本&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;修改&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件下的版本号，重新发布即可。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-cargo-yankjin-yong-ban-ben&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;cargo yank&amp;lt;&amp;#x2F;code&amp;gt;禁用版本&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;cargo 不支持删除某个历史版本，但可以将历史版本禁用，防止其他人将该版本加入依赖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;yanking 只能防止新项目将该版本作为依赖，已存在的项目依旧可以下载该版本。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面的命令就将 1.0.1 版本禁用了，任何新项目都不能再依赖该版本&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;$ cargo yank –vers 1.0.1&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;如果要撤销某个版本的禁用，可以使用&amp;lt;code&amp;gt;--undo&amp;lt;&amp;#x2F;code&amp;gt;参数&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;$ cargo yank –vers 1.0.1 –undo&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-cargo-gong-zuo-kong-jian&amp;quot;&amp;gt;Section 3 - Cargo 工作空间&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;在开发过程中，你的包会变得越来越大，此时应该对它们进一步切分。在这种场景下，Cargo 提供了*工作空间（work space）*的功能让你来管理一些相关的包。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;chuang-jian-gong-zuo-kong-jian&amp;quot;&amp;gt;创建工作空间&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;工作空间是一组共享&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件和输出目录的包集合。创建工作空间有很多方式，下面展示最常用的一种。我们将创建包含 1 个可执行 crate 和 1 个库 crate 的工作空间。可执行 crate 提供入口函数&amp;lt;code&amp;gt;main&amp;lt;&amp;#x2F;code&amp;gt;，其余库 crate 提供方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;首先创建一个&amp;lt;em&amp;gt;add&amp;lt;&amp;#x2F;em&amp;gt;目录。然后进入目录创建&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。这个 toml 文件不会包含之前出现的[package]块，或者其他元数据。它以[workspace]块开始，下面会定义工作空间所包含的成员。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[workspace]

members = [
    &amp;amp;quot;adder&amp;amp;quot;,
]
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;然后在&amp;lt;em&amp;gt;add&amp;lt;&amp;#x2F;em&amp;gt;目录下新建一个可执行包&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;。最后使用&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;创建工作空间，此时项目结构应该如下：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;工作空间根目录有一个放置编译结果的&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录，adder 包内部没有&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录了。就算我们进入&amp;lt;em&amp;gt;adder&amp;lt;&amp;#x2F;em&amp;gt;项目运行&amp;lt;code&amp;gt;Cargo build&amp;lt;&amp;#x2F;code&amp;gt;，编译结果还是会被存放到根目录下的&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录中，而不是&amp;lt;em&amp;gt;add&amp;#x2F;adder&amp;#x2F;target&amp;lt;&amp;#x2F;em&amp;gt;目录。Cargo 这样组织&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录是因为，工作空间下的包是相互依赖的，如果每个包都有自己的&amp;lt;em&amp;gt;target&amp;lt;&amp;#x2F;em&amp;gt;目录来存放编译结果，则所有的包都需要互相为其他包构建一份。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;chuang-jian-di-er-ge-bao&amp;quot;&amp;gt;创建第二个包&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;接下来创建工作空间下的第二个包&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;。修改根目录下的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[workspace]

members = [
    &amp;amp;quot;adder&amp;amp;quot;,
    &amp;amp;quot;add-one&amp;amp;quot;,
]
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;然后创建一个库 crate。&amp;lt;code&amp;gt;cargo new add_one --lib&amp;lt;&amp;#x2F;code&amp;gt;。现在目录应该包含以下内容&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;em&amp;gt;add-one&amp;#x2F;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;文件中添加一个&amp;lt;code&amp;gt;add_one&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_one(x:i32) -&amp;amp;gt; i32 {
    x + 1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来可执行 crate 可以对库 crate 进行依赖，首先在需要引入依赖的 crate 的 toml 文件中，定义[dependencies]模块。指定库 crate 的路径。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[dependencies]

add-one = { path = &amp;amp;quot;..&amp;amp;#x2F;add-one&amp;amp;quot; }
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Cargo 不会对依赖进行解析，所以需要我们明确指定 crate 间的依赖关系。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来可以在&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;crate 中通过&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;引入&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;模块了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use add_one;

fn main() {
    let num = 10;
    println!(
        &amp;amp;quot;Hello, world! {} plus one is {}!&amp;amp;quot;,
        num,
        add_one::add_one(num)
    );
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;最后在根目录下运行&amp;lt;code&amp;gt;cargo build&amp;lt;&amp;#x2F;code&amp;gt;构建。使用&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;命令运行代码，使用&amp;lt;code&amp;gt;-p&amp;lt;&amp;#x2F;code&amp;gt;参数指定运行的包：&amp;lt;code&amp;gt;cargo run -p adder&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;yi-lai-wai-bu-bao&amp;quot;&amp;gt;依赖外部包&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;整个工作空间只有根目录下有&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;文件，这样保证所有包使用的外部依赖都是相同的版本。如果你在每个包目录下的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中都指定了外部依赖，Cargo 会将他们处理成统一的版本并记录在根目录下的&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;文件中。这样保证所有包使用的依赖都是兼容的。下面我们先在&amp;lt;em&amp;gt;add-one&amp;#x2F;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中添加一个&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;外部依赖。然后在文件中引用这个依赖并执行编译。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;toml&amp;quot; class=&amp;quot;language-toml &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-toml&amp;quot; data-lang=&amp;quot;toml&amp;quot;&amp;gt;[dependencies]
rand = &amp;amp;quot;0.5.5&amp;amp;quot;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;  Updating crates.io index
Downloaded libc v0.2.76
 Compiling rand v0.5.6
 Compiling add-one v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;add&amp;amp;#x2F;add-one)
 Compiling adder v0.1.0 (&amp;amp;#x2F;Users&amp;amp;#x2F;ksleo&amp;amp;#x2F;private&amp;amp;#x2F;add&amp;amp;#x2F;adder)
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;现在根目录下的&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;已经有了&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;依赖&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;包的信息。尽管&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;包以及在工作空间内部使用了，但是在&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;以外的包中，引入&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;包还是会报错，除非我们在他们的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件中也指定&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;依赖。此时&amp;lt;em&amp;gt;Cargo.lock&amp;lt;&amp;#x2F;em&amp;gt;文件中也会记录&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;引用&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;的信息，但是不会重新下载多余的代码。这种方式既保证所有包都使用同一个版本的外部依赖，又不会因为代码拷贝从而对空间造成浪费。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;wei-gong-zuo-kong-jian-tian-jia-ce-shi&amp;quot;&amp;gt;为工作空间添加测试&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;为&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;包的公有方法添加一个测试用例&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_one(x: i32) -&amp;amp;gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;运行&amp;lt;code&amp;gt;cargo test&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;add_one-f0253159197f7841
running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

    Running target&amp;amp;#x2F;debug&amp;amp;#x2F;deps&amp;amp;#x2F;adder-d6b6ef1ba6873bae

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

  Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一块内容表示&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;包有一个测试用例被运行；第二块表示&amp;lt;code&amp;gt;adder&amp;lt;&amp;#x2F;code&amp;gt;包中没有测试用例可以执行；第三块表示&amp;lt;code&amp;gt;add-one&amp;lt;&amp;#x2F;code&amp;gt;包中没有文档测试可以执行。在工作空间中执行测试，会将工作空间下所有包的测试用例都执行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;也可以使用&amp;lt;code&amp;gt;-p&amp;lt;&amp;#x2F;code&amp;gt;参数指定测试的包，与&amp;lt;code&amp;gt;cargo run&amp;lt;&amp;#x2F;code&amp;gt;使用方式一样。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果你要发布你的包，那么你需要对每个包分别执行发布操作，&amp;lt;code&amp;gt;cargo publish&amp;lt;&amp;#x2F;code&amp;gt;没有&amp;lt;code&amp;gt;--all&amp;lt;&amp;#x2F;code&amp;gt;或者&amp;lt;code&amp;gt;-p&amp;lt;&amp;#x2F;code&amp;gt;参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-shi-yong-cargo-installcong-crates-io-an-zhuang-ke-zhi-xing-wen-jian&amp;quot;&amp;gt;Section 4 - 使用&amp;lt;code&amp;gt;cargo install&amp;lt;&amp;#x2F;code&amp;gt;从 crates.io 安装可执行文件&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;cargo install&amp;lt;&amp;#x2F;code&amp;gt;命令可以让你在本地下载和使用可执行 crate。只能安装带有可执行编译目标的包。可执行编译目标是由具有&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，或者其他被指定为可执行文件的包，编译而来的可执行程序。相对应的库 crate 则不能独立运行，只能被其他 crate 引用。通常 crate 都会又 README 文件说明，crate 是可执行 crate 还是库 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;可执行文件被下载到安装目录的&amp;lt;em&amp;gt;bin&amp;lt;&amp;#x2F;em&amp;gt;目录下，如果你没有进行过任何自定义配置，这个目录是$HOME&amp;#x2F;.cargo&amp;#x2F;bin。确保该路径被添加进&amp;lt;code&amp;gt;$PATH&amp;lt;&amp;#x2F;code&amp;gt;环境变量了，否则可能无法运行可执行文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-5-zi-ming-ling-kuo-zhan-cargo&amp;quot;&amp;gt;Section 5 - 子命令扩展 Cargo&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Cargo 被设计为你不需要修改 Cargo 本身就可以扩展很多子命令，如果你的&amp;lt;code&amp;gt;$PATH&amp;lt;&amp;#x2F;code&amp;gt;中有个可执行程序叫&amp;lt;code&amp;gt;cargo-something&amp;lt;&amp;#x2F;code&amp;gt;，你可以用类似子命令的方式运行它&amp;lt;code&amp;gt;cargo something&amp;lt;&amp;#x2F;code&amp;gt;。可以通过&amp;lt;code&amp;gt;cargo --list&amp;lt;&amp;#x2F;code&amp;gt;命令列出所有 cargo 扩展命令。使用&amp;lt;code&amp;gt;cargo install&amp;lt;&amp;#x2F;code&amp;gt;来安装这些可执行扩展，就像使用内置工具一样方便。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Ownership</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;02-ownership&#x2F;"/>
                <updated>2021-05-08T09:42:34+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;02-ownership&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-2-ownership&amp;quot;&amp;gt;Chapter 2 - Ownership&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Ownership 是 Rust 最重要的功能之一，它在没有&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;en.wikipedia.org&amp;#x2F;wiki&amp;#x2F;Garbage_collection_(computer_science)&amp;quot;&amp;gt;gc&amp;lt;&amp;#x2F;a&amp;gt;的前提下保证了内存读写安全。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-shen-me-shi-ownership&amp;quot;&amp;gt;Section 1 - 什么是 Ownership&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;ownership&amp;lt;&amp;#x2F;em&amp;gt;是 Rust 的核心功能，虽然这个概念很容易解释，但是对于其他语言而言是一个很陌生的概念。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所有程序都有内存调度的方式，比如很常见的 gc，不断的收集没有在使用的内存碎片。很多语言都需要明确的分配和释放内存，Rust 则使用外的方式：通过 ownership 下的一组规则，在编译阶段对内存进行检查，对运行时的性能没有任何影响。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;:::details Stack 和 Heap
stack 和 heap 都是在程序运行时可以使用的一部分内存，但是他们的结构不一样。栈是先进先出（FILO）的调度策略，数据入栈操作称&amp;lt;em&amp;gt;push&amp;lt;&amp;#x2F;em&amp;gt;，出栈称为&amp;lt;em&amp;gt;pop&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所有在 stack 上存储的数据，其大小都必须是已知和固定的。数据大小在编译阶段无法确定，或者可能会在运行时扩容的数据，都必须存储 heap。堆的组织性比较差，首先需要在堆内存中请求一块空间。内存调度器会找一块大小合适的空内存并把它打上标记，表示已被使用，然返回一个&amp;lt;em&amp;gt;指针（pointer）&amp;lt;&amp;#x2F;em&amp;gt;。指针代表的是该内存区域的地址。这个过程称为&amp;lt;em&amp;gt;allocating&amp;lt;&amp;#x2F;em&amp;gt;。由于指针是大小确定且固定的数据，因此针可以存储在 stack 上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;stack 存储比 heap 要快，因为不需要内存调度器分配内存，stack 的指针始终在其顶部。相比之下，heap 内存分配需要内存调度寻找大小和据匹配的内存，并且还需要为下一次分配做一些前置工作比如内存标记等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;stack 访问也比 heap 快，因为 heap 需要先根据存储在 stack 上的指针寻址。在多个指针跳转时，这些指针如果相隔太远，也会让访问更慢。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在调用函数时，参数（可能是 heap 上数据的指针）和函数的内部变量会被存进 stack。函数执行结束时这些数据会从 stack 中清除。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;保持对 heap 数据使用的监控，最小化这些 heap 上的数据内存大小，减少重复数据内容，清空没有使用的内存已确保不会内存溢出。这些都 ownership 解决的问题
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;ownership-rules&amp;quot;&amp;gt;Ownership Rules&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Rust 中每个值都有一个变量作为它的 owner&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;每个值只能有一个 owner&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;当 owner 超出作用域块，值将被删除&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h3 id=&amp;quot;variable-scope&amp;quot;&amp;gt;Variable scope&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;变量在定义的那一刻有效，直到定义该变量的作用域执行完毕。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{ &amp;amp;#x2F;&amp;amp;#x2F; s is not valid here, it’s not yet declared
  let s = &amp;amp;quot;hello&amp;amp;quot;; &amp;amp;#x2F;&amp;amp;#x2F; s is valid from this point forward
  &amp;amp;#x2F;&amp;amp;#x2F; do stuff with s
} &amp;amp;#x2F;&amp;amp;#x2F; this scope is now over, and s is no longer valid
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;stringlei-xing&amp;quot;&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;为了说明 ownership 的作用机制，需要一个比 Chapter1 中的基础数据类型稍微复杂一些的数据，之前介绍的数据全都是存储在 stack 上的，但是目前我们需要存储在 heap 上的数据，用来解释 Rust 如何决策释放 heap 内存的时机。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;这里用&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型举例，专注于它和 ownership 相关的部分，这些特性在其他复杂数据类型也适用，不论是标准库导出的还是你自己定义的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前的代码块使用了字符串字面量，这种方式很便捷，但是在大部分场景下这种方式不太适用。一方面是因为字符串字面量是 immutable 的，其次是因为大部分情况下我们并不知道要存储的数据是什么，比如存储用户输入。因此 Rust 还有另外一种字符串类型，&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;。这种类型是分配在 heap 上的，因此能够任意修改和存储任意大小的数据。&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型可以通过标准库导出的&amp;lt;code&amp;gt;from&amp;lt;&amp;#x2F;code&amp;gt;方法来创建&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;  let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这种 string 数据可以修改&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;  s.push_str(&amp;amp;quot;, world!&amp;amp;quot;); &amp;amp;#x2F;&amp;amp;#x2F; push_str() appends a literal to a String

  println!(&amp;amp;quot;{}&amp;amp;quot;, s)
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;为什么字面量不可以修改而 String 却可以？主要区别在于这两种类型的内存处理方式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;memory-and-allocation&amp;quot;&amp;gt;Memory and Allocation&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;字符串字面量在编译截断是知道其内容的，因此它直接被 hardcode 到可执行文件中，因此它更快更有效率。这些特性也只有在数据不变时才有效。但是对于大小、数据在编译阶段都不确定，运行时会改变其内容的数据来说，无法在可执行文件中为这些数据插入 blob 内存。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型为了支持数据可变、内存可扩容，在编译阶段无法确定数据内容，在 heap 上分配了一定数量的内存出来。这意味着：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;内存必须在运行时由内存调度器分配。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;需要一种在内存使用完毕时，将内存交还给内存调度器的方法。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;第一点由编码人员控制：当执行&amp;lt;code&amp;gt;String::from&amp;lt;&amp;#x2F;code&amp;gt;方法时，它会去请求所需要的内存大小。这在大多数语言里都差不多。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第二点 Rust 与其他语言有些差异。在有 gc 机制的语言中，gc 会持续检查内存，回收没有使用的内存碎片。但是在没有 gc 机制的语言中，内存回收就是编码人员的职责，此时我们需要显式调用释放内存，就像申请内存时调用&amp;lt;code&amp;gt;String::from&amp;lt;&amp;#x2F;code&amp;gt;方法一样。内存管理一直都是一个难题，如果编码人员忘记回收内存，就会造成内存泄露；如果回收的太早，又会导致程序拿到一个悬空指针；如果对同一块内存释放了两次，同样也是个 bug。编码人员必须保证一次申请匹配一次释放。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 使用了一种不同的方式：当 owner 变量所在的作用域执行结束时，其内存会被自动回收。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;{
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;); &amp;amp;#x2F;&amp;amp;#x2F; s is valid from this point forward

    &amp;amp;#x2F;&amp;amp;#x2F; do stuff with s
}   &amp;amp;#x2F;&amp;amp;#x2F; this scope is now over, and s is no longer valid
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当作用域结束时，Rust 会调用一个特殊方法&amp;lt;code&amp;gt;drop&amp;lt;&amp;#x2F;code&amp;gt;。
:::tip Node:
在 C++中，这种在生命周期结束时重新分配资源的模式被称作&amp;lt;em&amp;gt;Resource Acquisition Is Initialization (RAII)&amp;lt;&amp;#x2F;em&amp;gt;。如果你对这种模式比较熟悉，Rust 的&amp;lt;code&amp;gt;drop&amp;lt;&amp;#x2F;code&amp;gt;方法同样也很容易理解。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;ways-variables-and-data-interact-move&amp;quot;&amp;gt;Ways Variables and Data Interact: Move&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;在 Rust 中多个变量对相同数据的交互方式有多种。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;
let y = x;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子很好理解，将 5 绑定到变量&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;上，创建一份变量&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;的值的拷贝并绑定在变量&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;上。整型数字是数据已知、大小确定的，在 stack 上会存储两份数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);
let s2 = s1;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子在写法上和上面的例子看起来一致，但是在行为上有很大的差别。下图说明了&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型底层所做的逻辑。&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型由左侧三部分组成：一个指向 heap 的内存地址，表示长度的值，表示容量的值，这组数据存储在 stack 上。右侧是 heap 上存储数据的内存。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;!-- ![img4-1](https:&amp;#x2F;&amp;#x2F;gitee.com&amp;#x2F;ksleo&amp;#x2F;source&amp;#x2F;raw&amp;#x2F;master&amp;#x2F;trpl04-01.svg) --&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-01.svg&amp;quot; alt=&amp;quot;img4-1&amp;quot; &amp;#x2F;&amp;gt;
length 是指数据具体使用的内存字节长度，capacity 是&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型从内存调度器申请到的内存字节长度。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当把&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;赋值给&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;时，&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;数据被复制了，也就是指针、长度和容量这个数据结构被复制了，而具体存储在 heap 上的数据并没有被复制。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-02.svg&amp;quot; alt=&amp;quot;img4-2&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果&amp;lt;code&amp;gt;s2 = s1&amp;lt;&amp;#x2F;code&amp;gt;这段代码执行 heap 复制，如果在 heap 上的数据量过大，这将会是一个很昂贵的操作，性能带来损耗并且双倍的内存占用。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-03.svg&amp;quot; alt=&amp;quot;img4-3&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前提到变量所在作用域执行结束时，Rust 会自动调用&amp;lt;code&amp;gt;drop&amp;lt;&amp;#x2F;code&amp;gt;方法释放该段内存。但是在上面的例子中会出现问题：作用域结束时，&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;都执行释放操作，但是这两个指针指向的是同一个地址，这就会引起&amp;lt;em&amp;gt;多次释放同一内存&amp;lt;&amp;#x2F;em&amp;gt;的问题。为了确保内存安全，Rust 在这种情况下有其他一些细节：Rust 不会去复制 heap 内存，而是认为&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;已经是一个无效引用，在作用域执行结束时，Rust 不会执行任何与&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;相关的释放操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);
let s2 = s1;

println!(&amp;amp;quot;{}&amp;amp;quot;, s1);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0382]: borrow of moved value: `s1`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;执行以上代码，编译器会抛出错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果你熟悉深复制和浅复制的概念，之前&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型下复制指针、长度和容量数据结构的操作，就可以认为是浅复制。但是由于 Rust 同时又让第一个值&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;失效了，因此在 Rust 中称为&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;而不是&amp;lt;em&amp;gt;shallow copy&amp;lt;&amp;#x2F;em&amp;gt;。在刚才的例子中，可以认为&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;到了&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-04.svg&amp;quot; alt=&amp;quot;img4-4&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;ways-variables-and-data-interact-clone&amp;quot;&amp;gt;Ways Variables and Data Interact: Clone&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;如果我们执行 heap 数据深复制，而不仅仅是 stack 浅复制，可以调用&amp;lt;code&amp;gt;clone&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);
let s2 = s1.clone();

println!(&amp;amp;quot;s1 = {}, s2 = {}&amp;amp;quot;, s1, s2);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;stack-only-data-copy&amp;quot;&amp;gt;Stack-Only Data: Copy&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let x = 5;
let y = x;

println!(&amp;amp;quot;x = {}, y = {}&amp;amp;quot;, x, y);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这段代码执行不会有任何问题。但这与刚刚得到到结论出现了分歧：在没有调用 clone 得情况下，&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;仍然是有效的，看似没有发生&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;原因在于整型变量是编译时大小固定的，存储在 stack 上，并且其值很容易复制。也就是说没有必要在&amp;lt;code&amp;gt;y&amp;lt;&amp;#x2F;code&amp;gt;创建后，将&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;标记为失效。也就是说在这种情况下，浅复制和深复制没有任何区别，所以就算调用&amp;lt;code&amp;gt;clone&amp;lt;&amp;#x2F;code&amp;gt;方法，也不会与浅复制在行为上有任何的不同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 有一个特殊的标记被称作&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait。一切在 stack 上存储的数据类型都可以理解为存在这个&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait。如果一个类型有&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait，旧的变量被分配给新的变量后仍然是有效的。Rust 不允许我们给任何实现，或者其任何一部分实现了&amp;lt;code&amp;gt;Drop&amp;lt;&amp;#x2F;code&amp;gt; trait 的类型做&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt; trait 标记。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;任何基础数据类型的组合是&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;的，凡是不需要分配或属于某种形式的资源的，都是&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;。下面是一些&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;类型举例：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;所有整型，例如&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;所有浮点，例如&amp;lt;code&amp;gt;f64&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;bool&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;char&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;只包含&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;类型的 tuples。比如&amp;lt;code&amp;gt;(u32, u64)&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;(u32, String)&amp;lt;&amp;#x2F;code&amp;gt;不是。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h3 id=&amp;quot;ownership-and-functions&amp;quot;&amp;gt;Ownership and Functions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;把值传递给函数参数和传递给变量，在语义上是相似的，比如都会执行&amp;lt;em&amp;gt;move&amp;lt;&amp;#x2F;em&amp;gt;或者复制。用一个例子说明&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);  &amp;amp;#x2F;&amp;amp;#x2F; s comes into scope

    takes_ownership(s); &amp;amp;#x2F;&amp;amp;#x2F; s&amp;amp;#x27;s value moves into the function
                                     &amp;amp;#x2F;&amp;amp;#x2F; and so is no longer valid here

    let x = 5;                  &amp;amp;#x2F;&amp;amp;#x2F; x comes into scope

    makes_copy(x);     &amp;amp;#x2F;&amp;amp;#x2F; x would move into the function,
                                     &amp;amp;#x2F;&amp;amp;#x2F; but i32 is Copy, so it’s okay to still
                                     &amp;amp;#x2F;&amp;amp;#x2F; use x afterward

} &amp;amp;#x2F;&amp;amp;#x2F; Here, x goes out of scope, then s. But because s&amp;amp;#x27;s value was moved, nothing
  &amp;amp;#x2F;&amp;amp;#x2F; special happens.

fn takes_ownership(some_string: String) { &amp;amp;#x2F;&amp;amp;#x2F; some_string comes into scope
    println!(&amp;amp;quot;{}&amp;amp;quot;, some_string);
} &amp;amp;#x2F;&amp;amp;#x2F; Here, some_string goes out of scope and `drop` is called. The backing
  &amp;amp;#x2F;&amp;amp;#x2F; memory is freed.

fn makes_copy(some_integer: i32) { &amp;amp;#x2F;&amp;amp;#x2F; some_integer comes into scope
    println!(&amp;amp;quot;{}&amp;amp;quot;, some_integer);
} &amp;amp;#x2F;&amp;amp;#x2F; Here, some_integer goes out of scope. Nothing special happens.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;return-values-and-scope&amp;quot;&amp;gt;Return Values and Scope&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;函数返回值也会使 ownership 发生转移。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s1 = gives_ownership();         &amp;amp;#x2F;&amp;amp;#x2F; gives_ownership moves its return
                                        &amp;amp;#x2F;&amp;amp;#x2F; value into s1

    let s2 = String::from(&amp;amp;quot;hello&amp;amp;quot;);     &amp;amp;#x2F;&amp;amp;#x2F; s2 comes into scope

    let s3 = takes_and_gives_back(s2);  &amp;amp;#x2F;&amp;amp;#x2F; s2 is moved into
                                        &amp;amp;#x2F;&amp;amp;#x2F; takes_and_gives_back, which also
                                        &amp;amp;#x2F;&amp;amp;#x2F; moves its return value into s3
} &amp;amp;#x2F;&amp;amp;#x2F; Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  &amp;amp;#x2F;&amp;amp;#x2F; moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&amp;amp;gt; String {             &amp;amp;#x2F;&amp;amp;#x2F; gives_ownership will move its
                                             &amp;amp;#x2F;&amp;amp;#x2F; return value into the function
                                             &amp;amp;#x2F;&amp;amp;#x2F; that calls it

    let some_string = String::from(&amp;amp;quot;hello&amp;amp;quot;); &amp;amp;#x2F;&amp;amp;#x2F; some_string comes into scope

    some_string                              &amp;amp;#x2F;&amp;amp;#x2F; some_string is returned and
                                             &amp;amp;#x2F;&amp;amp;#x2F; moves out to the calling
                                             &amp;amp;#x2F;&amp;amp;#x2F; function
}

&amp;amp;#x2F;&amp;amp;#x2F; takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -&amp;amp;gt; String { &amp;amp;#x2F;&amp;amp;#x2F; a_string comes into
                                                      &amp;amp;#x2F;&amp;amp;#x2F; scope

    a_string  &amp;amp;#x2F;&amp;amp;#x2F; a_string is returned and moves out to the calling function
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;变量的 ownership 遵循同一套模式：赋值给其他变量，ownership 就会转移。当一个变量的数据存储在 heap 上时，它所在的作用域在执行完毕后，该变量的 heap 空间就会被释放，除非它把 ownership 转移给其他变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果我们只想在函数中使用变量而不想转移其 ownership 呢？想一想除了要把函数主体逻辑的结果返回，还要要把传进函数的 ownership 再传出去，这也太操蛋了。我们可以通过&amp;lt;code&amp;gt;Tuple&amp;lt;&amp;#x2F;code&amp;gt;实现这个需求。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    let (s2, len) = calculate_length(s1);

    println!(&amp;amp;quot;The length of &amp;amp;#x27;{}&amp;amp;#x27; is {}.&amp;amp;quot;, s2, len);
}

fn calculate_length(s: String) -&amp;amp;gt; (String, usize) {
    let length = s.len(); &amp;amp;#x2F;&amp;amp;#x2F; len() returns the length of a String

    (s, length)
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;对于一个常见的概念来说，不应该做这么多大量的额外工作。好在 Rust 已经实现了这个功能，称之为&amp;lt;em&amp;gt;references&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-references-and-borrowing&amp;quot;&amp;gt;Section 2 - References and Borrowing&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;之前我们在&amp;lt;code&amp;gt;calculate_length&amp;lt;&amp;#x2F;code&amp;gt;中返回了一个元组用于返回函数结果和 ownership，以便我们在函数调用完成后可以继续使用&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;变量。因为之前提过，传参和赋值在行为上差不多是一致的，&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;变量传参进入&amp;lt;code&amp;gt;calculate_length&amp;lt;&amp;#x2F;code&amp;gt;函数后，其 ownership 也被转移到了函数内部，&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;此时是不可用的了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面是一个通过传入一个变量的 reference，来控制 ownership 不被传递到函数内部的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s1 = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    let len = calculate_length(&amp;amp;amp;s1);

    println!(&amp;amp;quot;The length of &amp;amp;#x27;{}&amp;amp;#x27; is {}.&amp;amp;quot;, s1, len);
}

fn calculate_length(s: &amp;amp;amp;String) -&amp;amp;gt; usize { &amp;amp;#x2F;&amp;amp;#x2F; s is a reference to a String
    s.len()
} &amp;amp;#x2F;&amp;amp;#x2F; Here, s goes out of scope. But because it does not have ownership of what
  &amp;amp;#x2F;&amp;amp;#x2F; it refers to, nothing happens.
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;首先 Tuple 被删除了，其次参数的定义和传递都加了一个&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;符号，这个符号代表的就是&amp;lt;em&amp;gt;references&amp;lt;&amp;#x2F;em&amp;gt;，引用可以只读变量的值而不转移其所有权。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-05.svg&amp;quot; alt=&amp;quot;img4-5&amp;quot; &amp;#x2F;&amp;gt;
:::tip Note
与&amp;lt;em&amp;gt;reference&amp;lt;&amp;#x2F;em&amp;gt;相对的操作称为&amp;lt;em&amp;gt;dereference&amp;lt;&amp;#x2F;em&amp;gt;，运算符是&amp;lt;code&amp;gt;*&amp;lt;&amp;#x2F;code&amp;gt;。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;s1&amp;lt;&amp;#x2F;code&amp;gt;这种语法创建了一个引用，指向被引用的值，但是不转移原变量的所有权。因为没有所有权，所以函数结束时，它指向的 heap 区域不会被释放。当函数参数以引用方式传递时，函数不再需要显式的返回所有权，因为所有权一开始就没有发生转移。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;引用作为函数参数称之为&amp;lt;em&amp;gt;borrowing&amp;lt;&amp;#x2F;em&amp;gt;。如果我们尝试改变引用，编译器会报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    change(&amp;amp;amp;s);
}

fn change(some_string: &amp;amp;amp;String) {
    some_string.push_str(&amp;amp;quot;, world&amp;amp;quot;);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;amp;amp;` reference
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;和变量的默认行为相同，引用也是 immutable 的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;mutable-reference&amp;quot;&amp;gt;Mutable Reference&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;只需要进行一个改动，就可以获取一个 mutable 的引用。即在函数定义和调用的时候，在&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;操作符后加上&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    change(&amp;amp;amp;mut s);
}

fn change(some_string: &amp;amp;amp;mut String) {
    some_string.push_str(&amp;amp;quot;, world&amp;amp;quot;);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可变引用有一个限制，同一个作用域下，对同一个数据只能有一个可变引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let r1 = &amp;amp;amp;mut s;
let r2 = &amp;amp;amp;mut s;

println!(&amp;amp;quot;{}, {}&amp;amp;quot;, r1, r2);
&amp;amp;#x2F;&amp;amp;#x2F; error[E0499]: cannot borrow `s` as mutable more than once at a time
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这样做的好处在于避免在编译阶段造成数据竞争。数据竞争和竞态条件相似，在以下三个行为发生时会引发竞态：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;两个以上指针同时访问同一资源。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;至少一个指针正在被用于写操作。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;没有用于同步访问数据的机制。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;数据竞争在运行时调试时很难找出问题并且解决它。Rust 中不会发生这种情况，因为代码有可能引发竞态时，编译阶段就不会通过。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let r1 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
let r2 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
let r3 = &amp;amp;amp;mut s; &amp;amp;#x2F;&amp;amp;#x2F; BIG PROBLEM

println!(&amp;amp;quot;{}, {}, and {}&amp;amp;quot;, r1, r2, r3);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当存在 immutable 的引用时，不可以创建 mutable 的引用。可以存在多个 immutable 引用，因为仅仅读数据并不会造成脏读。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;引用的生命周期从定义它开始，到最后一次使用它结束，下面的代码编译是可以通过的，因为在 mutable 引用创建之前，immutable 引用的生命周期就结束了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let r1 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
let r2 = &amp;amp;amp;s; &amp;amp;#x2F;&amp;amp;#x2F; no problem
println!(&amp;amp;quot;{}, {}&amp;amp;quot;, r1, r2);
let r3 = &amp;amp;amp;mut s; &amp;amp;#x2F;&amp;amp;#x2F; no problem

println!(&amp;amp;quot;{}&amp;amp;quot;, r3);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;尽管这类编译错误非常令人烦躁，但是在编译阶段明确指出问题所在总好过在运行时出错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;dangling-references&amp;quot;&amp;gt;Dangling References&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;悬空指针是指针指向的地址，被其他操作释放掉了。Rust 编译器保证不会出现悬空指针：如果有一个指针指向一块内存区域，编译器会保证在这块内存区域的数据被使用前，该指针所在的作用域不会结束。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面是一个创建悬空指针的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let s = dangle();
}

fn dangle() -&amp;amp;gt; &amp;amp;amp;String {
    let str = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    &amp;amp;amp;str
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这段代码编译器会报错，其中有这样一条帮助信息：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;this function’s return type contains a borrowed value, but there is no value for it to be borrowed from&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;因为&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;是在&amp;lt;code&amp;gt;dangle&amp;lt;&amp;#x2F;code&amp;gt;函数中创建的，当&amp;lt;code&amp;gt;dangle&amp;lt;&amp;#x2F;code&amp;gt;函数执行结束，&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;指向的内存区域也被释放了，意味着我们返回了一个不合法的&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;引用，Rust 编译器是不会允许此类情况发生的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;解决方法是直接返回原变量，也就是转移所有权，这样在函数结束后相关内存就不会被释放，因为所有权被转移到了外部变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn dangle() -&amp;amp;gt; String {
    let str = String::from(&amp;amp;quot;hello&amp;amp;quot;);

    str
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;the-rules-of-references&amp;quot;&amp;gt;The Rules of References&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;任何情况下都只能有一个 mutable 引用或多个 immutable 引用。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;引用必须是有效的。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-the-slice-type&amp;quot;&amp;gt;Section 3 - The Slice Type&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;另外一种没有所有权的数据类型是切片，切片引用一段集合上连续的元素。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;引入一个小例子：写一个函数，接受一个 String 作为参数，返回它里面的第一个词。如果 String 中没有匹配到空格，说明传入的是一个词，此时返回原参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;考虑一下这个函数的声明该怎么写&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;String) -&amp;amp;gt; ?
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个方法中我们不想要获取所有权，所以传入一个引用。但是它应该返回什么类型？第一种方案可以返回结果的最后一个字母的下标。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;String) -&amp;amp;gt; usize {
    let bytes = s.as_bytes();
    for (i, &amp;amp;amp;item) in bytes.iter().emumrate() {
        if item == b&amp;amp;#x27; &amp;amp;#x27; {
            return i;
        }
    }
    s.len()
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个方法的问题在于，它返回的下标仅在&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;上下文中有意义，如果该引用的值被修改了，则之前的运算值也不正确了。如果我们返回的是前后两个下标&amp;lt;code&amp;gt;fn second_word(s: &amp;amp;amp;String) -&amp;amp;gt; (usize, usize) {&amp;lt;&amp;#x2F;code&amp;gt;，那么这种方式就更加脆弱，此时已经有三个不相关的变量需要保持数据同步了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;string-slices&amp;quot;&amp;gt;String Slices&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;字符串切片是字符串其中一段内容的引用。字符串切片可以使用下面的方法创建&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = String::from(&amp;amp;quot;hello world&amp;amp;quot;);

let hello = &amp;amp;amp;s[0..5];
let world = &amp;amp;amp;s[6..11];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;切片和引用是类似的，不过是用&amp;lt;code&amp;gt;[start_index..end_index]&amp;lt;&amp;#x2F;code&amp;gt;这种方式截断了字符串的一部分，该区间是左闭右开的。切片内部实现存储的是首地址和切片长度。
&amp;lt;img src=&amp;quot;&amp;#x2F;images&amp;#x2F;ownership&amp;#x2F;trpl04-06.svg&amp;quot; alt=&amp;quot;img4-6&amp;quot; &amp;#x2F;&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 的&amp;lt;code&amp;gt;..&amp;lt;&amp;#x2F;code&amp;gt;范围语法，如果定义的范围从 0 开始，那么 0 可以不写。所以，下面两种写法是一样的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let slice = &amp;amp;amp;s[0..2];
let slice = &amp;amp;amp;s[..2];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果范围是从头部到尾部，那么两边的数字都可以省略掉。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = String::from(&amp;amp;quot;hello&amp;amp;quot;);

let len = s.len();

let slice = &amp;amp;amp;s[0..len];
let slice = &amp;amp;amp;s[..];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;:::warning 注意
字符串切片下标必须是在合法的 utf8 字符边界处，如果下标处于多字节字符之中，程序会抛出错误。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;有了这些相关概念，之前的&amp;lt;code&amp;gt;first_word&amp;lt;&amp;#x2F;code&amp;gt;函数可以做一些修改。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;String) -&amp;amp;gt; &amp;amp;amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;amp;amp;item) in bytes.iter().enumerate() {
        if (item == b&amp;amp;#x27; &amp;amp;#x27;) {
            return &amp;amp;amp;s[0..i];
        }
    }
    &amp;amp;amp;s[..]
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;之前的函数，在调用之后清空原来的 string，编译阶段不会出错，但是在运行时会引发 bug。现在经过改造之后的方法，在编译阶段就会指出问题所在。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let mut s = String::from(&amp;amp;quot;hello world&amp;amp;quot;);

    let word = first_word(&amp;amp;amp;s);

    s.clear(); &amp;amp;#x2F;&amp;amp;#x2F; error!

    println!(&amp;amp;quot;the first word is: {}&amp;amp;quot;, word);
}

&amp;amp;#x2F;&amp;amp;#x2F; error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;回顾之前的规则，当存在 immutable 的引用时，不能同时存在 mutable 的引用。&amp;lt;code&amp;gt;clear&amp;lt;&amp;#x2F;code&amp;gt;方法需要清空原字符串，所以它需要一个 mutable 的引用，Rust 是不允许的并在编译阶段直接抛错。Rust 编译器不光让自定义 API 更加易用，并且在编译阶段排除了许多潜在 bug。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;zi-fu-chuan-zi-mian-liang-shi-qie-pian-lei-xing&amp;quot;&amp;gt;字符串字面量是切片类型&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;之前提到，字符串字面量直接存储在可执行文件中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s = &amp;amp;quot;hello&amp;amp;quot;;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里变量&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的类型是&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;，它是一个切片，指一个向可执行文件中字面量存储位置的指针。这就是为什么字符串字面量不可以修改了，因为&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;是一个 immutable 引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;zi-fu-chuan-qie-pian-zuo-wei-han-shu-can-shu&amp;quot;&amp;gt;字符串切片作为函数参数&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;之前的&amp;lt;code&amp;gt;first_word&amp;lt;&amp;#x2F;code&amp;gt;函数，有一个更好的定义方式是&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn first_word(s: &amp;amp;amp;str) -&amp;amp;gt; &amp;amp;amp;str
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此时我们可以传&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;类型或者&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let my_string = String::from(&amp;amp;quot;hello world&amp;amp;quot;);

    &amp;amp;#x2F;&amp;amp;#x2F; first_word works on slices of `String`s
    let word = first_word(&amp;amp;amp;my_string[..]);

    let my_string_literal = &amp;amp;quot;hello world&amp;amp;quot;;

    &amp;amp;#x2F;&amp;amp;#x2F; first_word works on slices of string literals
    let word = first_word(&amp;amp;amp;my_string_literal[..]);

    &amp;amp;#x2F;&amp;amp;#x2F; Because string literals *are* string slices already,
    &amp;amp;#x2F;&amp;amp;#x2F; this works too, without the slice syntax!
    let word = first_word(&amp;amp;amp;my_string);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;qi-ta-qie-pian-lei-xing&amp;quot;&amp;gt;其他切片类型&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;数组切片&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let arr = [1,2,3,4,5];
let arr_slice = &amp;amp;amp;[0..2];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;arr_slice&amp;lt;&amp;#x2F;code&amp;gt;是&amp;lt;code&amp;gt;&amp;amp;amp;[i32]&amp;lt;&amp;#x2F;code&amp;gt;类型的，它跟&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;的表现没有任何区别：存储一个头指针和内容长度。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Smart Pointers</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;12-smart-pointer&#x2F;"/>
                <updated>2021-06-25T21:58:19+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;12-smart-pointer&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-12-smart-pointers&amp;quot;&amp;gt;Chapter 12 - Smart Pointers&amp;lt;&amp;#x2F;h1&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Iterators and Closures</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;10-iterators-and-closures&#x2F;"/>
                <updated>2020-12-28T08:26:58+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;10-iterators-and-closures&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-10-functional-language-features-iterators-and-closures&amp;quot;&amp;gt;Chapter 10 - Functional Language Features: Iterators and Closures&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Rust 的灵感来自于现有的许多语言和技术，其中一个最重要的概念就是&amp;lt;em&amp;gt;函数式编程（functional programming）&amp;lt;&amp;#x2F;em&amp;gt;。函数式编程包括，把函数当作参数传递给其他函数；从函数中返回一个函数；把函数赋值给变量延迟调用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面会介绍一些跟其他函数式语言类似的概念：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;闭包，结构类似于函数，可以存储在变量中。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;迭代器，处理一系列数据的一种方式。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;这两者的性能。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-closures-anonymous-functions-that-can-capture-their-environment&amp;quot;&amp;gt;Section 1 - Closures: Anonymous Functions that Can Capture Their Environment&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;Rust 的闭包是一个匿名函数，你可以把它存进变量或者当作参数传给其他函数。闭包的定义和调用可以在不同时间点，不同上下文中。跟函数不同的是，闭包可以捕获他们定义所在上下文中的变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;例如有这样一个场景：要开发一个 app 来为用户生成自定义的训练计划。后台使用 Rust，生成算法考虑了很多因素，例如用户年龄，体重，运动经历，当前训练计划和用户自定义的强度指数等。假设这个算法需要运行几秒钟，我们只想在初始化的时候调用算法一次，免得让用户不必要的等待结果。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;假设用函数&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;模拟算法调用：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&amp;amp;gt; u32 {
    println!(&amp;amp;quot;执行算法&amp;amp;quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来是&amp;lt;code&amp;gt;main&amp;lt;&amp;#x2F;code&amp;gt;函数，包含了用户在调用训练计划时要执行的代码。*闭包（closure）*的使用和前端交互没啥关系，因此这里硬编码参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;接下来模拟一下生成训练计划的算法函数&amp;lt;code&amp;gt;generate_workout&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &amp;amp;lt; 25 {
        println!(
            &amp;amp;quot;Today, do {} pushups!&amp;amp;quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &amp;amp;quot;Next, do {} situps!&amp;amp;quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(
                &amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个代码已经实现了业务方的需求。假设大数据团队想要我们在以后修改&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;的调用方式。为了简化升级流程，需要重构代码，让&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;只执行一次。并且多次调用的地方也需要删除掉。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;refactoring-using-functions&amp;quot;&amp;gt;Refactoring Using Functions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;首先，可以将&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;函数的执行结果存储在变量中，需要的时候直接使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity &amp;amp;lt; 25 {
        println!(&amp;amp;quot;Today, do {} pushups!&amp;amp;quot;, expensive_result);
        println!(&amp;amp;quot;Next, do {} situps!&amp;amp;quot;, expensive_result);
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(&amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;, expensive_result);
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个解决方式统一了&amp;lt;code&amp;gt;simulated_expensive_calculation&amp;lt;&amp;#x2F;code&amp;gt;函数的调用，并且解决了&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;代码块中函数不必要的多次调用。但是，这种解决方案需要所有条件下的情况等待算法执行结果，哪怕最终我们不需要这个结果。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;所以，我们想让代码只在需要结果的时候被调用一次。这个场景就很适用于&amp;lt;em&amp;gt;闭包（closure）&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;refactoring-with-closures-to-store-code&amp;quot;&amp;gt;Refactoring with Closures to Store Code&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;定义和储存闭包：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let expensive_closure = |num| {
    println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;闭包定义被赋值给变量&amp;lt;code&amp;gt;expensive_closure&amp;lt;&amp;#x2F;code&amp;gt;。闭包定义又两个竖线&amp;lt;code&amp;gt;|&amp;lt;&amp;#x2F;code&amp;gt;开头，竖线中间是传给闭包的参数。选择这种语法是因为它跟 Smalltalk 和 Ruby 相似。这个闭包有一个参数&amp;lt;code&amp;gt;num&amp;lt;&amp;#x2F;code&amp;gt;，如果需要传多个参数，可以&amp;lt;code&amp;gt;|p1, p2, ...|&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;然后用花括号包住闭包体，可以看到就是函数中的内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;现在&amp;lt;code&amp;gt;let&amp;lt;&amp;#x2F;code&amp;gt;语句意味着&amp;lt;code&amp;gt;expensive_closure&amp;lt;&amp;#x2F;code&amp;gt;变量包含一个匿名函数的定义，而不是函数的运行结果。也就是说需要在后面执行的代码存储在这个变量中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来修改&amp;lt;code&amp;gt;generate_workout&amp;lt;&amp;#x2F;code&amp;gt;函数中算法调用的部分。闭包调用和函数调用一样。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &amp;amp;lt; 25 {
        println!(&amp;amp;quot;Today, do {} pushups!&amp;amp;quot;, expensive_closure(intensity));
        println!(&amp;amp;quot;Next, do {} situps!&amp;amp;quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(
                &amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;,
                expensive_closure(intensity)
            );
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;现在，又引入了多次调用的问题。昂贵的计算操作会被调用多次，用户等待的时长更久。我们可以在内部的&amp;lt;code&amp;gt;if&amp;lt;&amp;#x2F;code&amp;gt;块中创建一个变量存储计算结果。但是闭包提供了更好的解决方案。稍后会介绍该方案。目前先套路一下为什么闭包定义没有类型声明，也没有相关的 trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;closure-type-inference-and-annotation&amp;quot;&amp;gt;Closure Type Inference and Annotation&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;闭包不会像函数一样要求你声明参数和返回值的类型。函数要求声明类型是因为它是显式接口的一部分。严格地定义接口能够保证所有的调用者都按照你的预期来传递参数和处理返回值。但是闭包不是用于对外接口的，它是给库内部用的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们也可以为闭包声明类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let expensive_closure = |num: u32| -&amp;amp;gt; u32 {
    println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;增加了类型声明之后，闭包定义更接近函数定义了。下面是函数声明语法和闭包的一个垂直对比。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn  add_one_v1   (x: u32) -&amp;amp;gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&amp;amp;gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第二行是完整声明定义，跟函数一样。第三行去掉了类型声明。第四行去掉了花括号，因为闭包内容只有一个表达式，此时可以将花括号也省略。这些声明都是有效的而且功能都是完全一致的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;闭包对参数和返回值都有具体的类型推断。当我们没有指定类型时，如果我们调用了两次闭包，第一次调用时候的类型，会被编译器锁定在闭包中，如果后续调用我们用其它类型的参数，编译器就报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;storing-closures-using-generic-parameters-and-the-fn-traits&amp;quot;&amp;gt;Storing Closures Using Generic Parameters and the Fn Traits&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，闭包被多次调用。我们可以创建一个结构体来存储闭包和闭包的运行结果。只有当结构体中还没有缓存结果值时，才会运行闭包。这种模式称为备忘录或者懒加载。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;结构体存储闭包时，闭包定义需要添加类型声明。因为结构体定义中，字段类型是必须的。每个闭包示例都有唯一的匿名类型，这意味着，就算两个闭包的类型定义都一致，编译器还是认为它们是不同的类型。在结构体，枚举和函数参数中定义闭包，需要用到泛型和 trait 绑定。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 由标准库提供。所有闭包至少需要实现&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;FnMut&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;FnOnce&amp;lt;&amp;#x2F;code&amp;gt;trait 之一。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 绑定上声明类型，代表闭包的参数类型和返回值类型必须和该绑定。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Cacher&amp;amp;lt;T&amp;amp;gt;
where
    T: Fn(u32) -&amp;amp;gt; u32,
{
    calculation: T,
    value: Option&amp;amp;lt;u32&amp;amp;gt;,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;结构体有一个&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型的&amp;lt;code&amp;gt;calculation&amp;lt;&amp;#x2F;code&amp;gt;字段。trait 绑定在&amp;lt;code&amp;gt;T&amp;lt;&amp;#x2F;code&amp;gt;类型上表示这个字段是实现了&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 的闭包。如果我们想要在这个字段上存储闭包，那么这个闭包必须符合一个&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;参数和一个&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;返回值的声明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Value&amp;lt;&amp;#x2F;code&amp;gt;字段的类型是&amp;lt;code&amp;gt;Option&amp;amp;lt;u32&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，初始值是&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;。当其他代码需要&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;中存储的闭包的运算结果时，&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;会运行它存储的闭包，并且将结果返回和缓存。当再次调用&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;获取闭包运算结果时，就将之前的计算结果返回。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl&amp;amp;lt;T&amp;amp;gt; Cacher&amp;amp;lt;T&amp;amp;gt;
where
    T: Fn(u32) -&amp;amp;gt; u32,
{
    fn new(calculation: T) -&amp;amp;gt; Cacher&amp;amp;lt;T&amp;amp;gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;amp;amp;mut self, arg: u32) -&amp;amp;gt; u32 {
        match self.value {
            Some(v) =&amp;amp;gt; v,
            None =&amp;amp;gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们希望&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;自身来管理字段值，而不是让外部代码去修改，因此这些字段都是私有的，通过方法返回。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;然后再修改&amp;lt;code&amp;gt;generate_workout&amp;lt;&amp;#x2F;code&amp;gt;函数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&amp;amp;quot;calculating slowly...&amp;amp;quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &amp;amp;lt; 25 {
        println!(&amp;amp;quot;Today, do {} pushups!&amp;amp;quot;, expensive_result.value(intensity));
        println!(&amp;amp;quot;Next, do {} situps!&amp;amp;quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&amp;amp;quot;Take a break today! Remember to stay hydrated!&amp;amp;quot;);
        } else {
            println!(
                &amp;amp;quot;Today, run for {} minutes!&amp;amp;quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;limitations-of-the-cacher-implementation&amp;quot;&amp;gt;Limitations of the &amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt; Implementation&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;目前这个&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;实现还有两个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第一个问题是，无论&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;实例接收什么参数，都返回的是第一个参数计算的结果。比如下面的测试用例会失败&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;将&amp;lt;code&amp;gt;value&amp;lt;&amp;#x2F;code&amp;gt;字段改为哈希表类型，通过参数来映射计算值就能解决这个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第二个问题是这个&amp;lt;code&amp;gt;Cacher&amp;lt;&amp;#x2F;code&amp;gt;只能存储&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;参数类型和&amp;lt;code&amp;gt;u32&amp;lt;&amp;#x2F;code&amp;gt;返回值类型的闭包。但是我们可能想存储其他类型。为了解决这个问题，可以使用多个泛型类型参数。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;capturing-the-environment-with-closures&amp;quot;&amp;gt;Capturing the Environment with Closures&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，我们把闭包当作匿名函数使用。闭包还有一个函数不具备的功能：闭包可以捕获它定义所在的上下文并且可以访问变量。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子中，&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;变量不是闭包的参数，但是仍然可以被闭包访问。因为&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;变量和闭包是定义在同一个上下文环境中的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当闭包捕获上下文的变量时，会将这些变量存储到内存中使用。大多数情况下代码执行不需要捕获上下文变量，这种内存开销是不必要的。因为函数不允许捕获它的上下文，因此执行函数不会引起这些额外的内存开销。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;闭包可以通过三种方式捕获上下文信息，跟函数获取参数的三种方式对应：获取所有权、可变引用和不可变引用。这三种方式分别封装在三种&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait 中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;FnOnce&amp;lt;&amp;#x2F;code&amp;gt;消费捕获的变量时，必须获取上下文变量的所有权并且传递到闭包中。Once 表示闭包不能对同一个变量获取两次及以上所有权。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;FnMut&amp;lt;&amp;#x2F;code&amp;gt;能够改变能够改变上下文中的变量值。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;不可以改变上下文中的变量值。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;创建闭包时，Rust 会根据你使用变量的方式来推断你使用的是哪个 trait。所有闭包都实现&amp;lt;code&amp;gt;FnOnce&amp;lt;&amp;#x2F;code&amp;gt;因为至少可以被调用一次。不获取所有权的闭包实现&amp;lt;code&amp;gt;FnMut&amp;lt;&amp;#x2F;code&amp;gt;trait。不改变外部变量的闭包实现&amp;lt;code&amp;gt;Fn&amp;lt;&amp;#x2F;code&amp;gt;trait。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果想要闭包强制获取所有权，可以在参数列表前使用&amp;lt;code&amp;gt;move&amp;lt;&amp;#x2F;code&amp;gt;关键字。当把闭包传递给新线程，让新线程获取所有权时，这种方法很有用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;下面是一个强制传递 vec 数据所有权的例子。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&amp;amp;quot;can&amp;amp;#x27;t use x here: {:?}&amp;amp;quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;x&amp;lt;&amp;#x2F;code&amp;gt;的所有权被传递给了闭包，在&amp;lt;code&amp;gt;println!&amp;lt;&amp;#x2F;code&amp;gt;中使用会报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-processing-a-series-of-items-with-iterators&amp;quot;&amp;gt;Section 2 - Processing a Series of Items with Iterators&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;迭代器模式可以让你在一个有序列表上依次执行一些任务。迭代器主要负责序列中每个项目要执行的操作和控制序列的退出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 中迭代器是惰性的。意味着只要你不调用消费迭代器的方法，它就不会执行任何操作。比如这个代码就没有任何实际作用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;当我们创建迭代器后，有许多方法可以去消费它。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环，在每个元素上执行一些操作。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&amp;amp;quot;Got: {}&amp;amp;quot;, val);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;迭代器可以让你更灵活的在不同序列上使用相同的逻辑，不光是在数组这样的数据结构上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;iteratortrait-he-next-fang-fa&amp;quot;&amp;gt;&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;Trait 和&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt; 方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;所有的迭代器都实现  了标准库提供的&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait。它的定义大致是：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;
pub trait Iterator {
    type Item;

    fn next(&amp;amp;amp;mut self) -&amp;amp;gt; Option&amp;amp;lt;Self::Item&amp;amp;gt;;

    &amp;amp;#x2F;&amp;amp;#x2F; methods with default implementations elided
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;有两个新语法&amp;lt;code&amp;gt;type Item&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;Self::Item&amp;lt;&amp;#x2F;code&amp;gt;，它定义了一个 trait 的关联类型。因此，实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 需要你定义一个&amp;lt;code&amp;gt;Item&amp;lt;&amp;#x2F;code&amp;gt;类型，这个类型会在&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法的返回值类型中使用。也就是说，&amp;lt;code&amp;gt;Item&amp;lt;&amp;#x2F;code&amp;gt;类型是迭代器的返回类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 只有&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法是必须实现的，这个方法一次返回一个迭代器中的元素，用&amp;lt;code&amp;gt;Some&amp;lt;&amp;#x2F;code&amp;gt;包裹；当迭代结束时，返回&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;可以直接通过迭代器调用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;amp;amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;amp;amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;amp;amp;3));
    assert_eq!(v1_iter.next(), None);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法时，迭代器需要&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字定义。next 方法会改变迭代器中用来追踪目前所迭代的位置状态，也可以说这是一种*消费（consumes）*行为。在&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环中，迭代器定义不需要&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字，因为&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环会获取迭代器的所有权，隐式地将其转为 mutable 的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法返回的数据是原序列中元素的不可变引用。&amp;lt;code&amp;gt;iter&amp;lt;&amp;#x2F;code&amp;gt;在不可变引用上生成迭代器。如果我们想创建一个拥有原序列所有权的迭代器，可以调用&amp;lt;code&amp;gt;into_iter&amp;lt;&amp;#x2F;code&amp;gt;。如果想创建一个迭代器的可变引用，可以调用&amp;lt;code&amp;gt;iter_mut&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;xiao-fei-die-dai-qi-de-fang-fa&amp;quot;&amp;gt;消费迭代器的方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;标准库默认为&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 提供了许多方法。有些方法内部会调用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法，因此在实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 时，必须实现&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;调用&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法的那些方法称为&amp;lt;em&amp;gt;消费型适配器（consuming adaptors）&amp;lt;&amp;#x2F;em&amp;gt;，因为它们在消耗迭代器。例如&amp;lt;code&amp;gt;sum&amp;lt;&amp;#x2F;code&amp;gt;方法：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;chan-sheng-xin-die-dai-qi-de-fang-fa&amp;quot;&amp;gt;产生新迭代器的方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;还有一些&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 上定义方法，称之为&amp;lt;em&amp;gt;迭代器适配器（iterator adaptors）&amp;lt;&amp;#x2F;em&amp;gt;，这些方法可以把迭代器转换成其他类型的迭代器。迭代器适配器可以链式调用，这样可以提高一组复杂操作的可读性。由于迭代器是惰性的，因此你最终需要调用消费适配器，这一组操作才会真正起作用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1: Vec&amp;amp;lt;i32&amp;amp;gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码编译器会给出一个警告：&amp;lt;code&amp;gt;iterators are lazy and do nothing unless consumed&amp;lt;&amp;#x2F;code&amp;gt;。也就是说这个代码不会起任何作用，定义的闭包也根本没有被执行。我们可以通过调用消费适配器，比如&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法来解决这个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v1: Vec&amp;amp;lt;i32&amp;amp;gt; = vec![1, 2, 3];

let v2: Vec&amp;amp;lt;_&amp;amp;gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-bi-bao-bu-huo-shang-xia-wen&amp;quot;&amp;gt;使用闭包捕获上下文&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;下面通过使用&amp;lt;code&amp;gt;filter&amp;lt;&amp;#x2F;code&amp;gt;迭代适配器来演示一个闭包捕获上下文的基本用法。&amp;lt;code&amp;gt;filter&amp;lt;&amp;#x2F;code&amp;gt;方法接收一个闭包，这个闭包的参数是迭代器中的元素，返回值是一个布尔值。如果闭包返回&amp;lt;code&amp;gt;true&amp;lt;&amp;#x2F;code&amp;gt;，则该元素会被包含在&amp;lt;code&amp;gt;filter&amp;lt;&amp;#x2F;code&amp;gt;方法返回的迭代器中，反之亦然。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&amp;amp;lt;Shoe&amp;amp;gt;, shoe_size: u32) -&amp;amp;gt; Vec&amp;amp;lt;Shoe&amp;amp;gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&amp;amp;quot;sneaker&amp;amp;quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&amp;amp;quot;sandal&amp;amp;quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&amp;amp;quot;boot&amp;amp;quot;),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&amp;amp;quot;sneaker&amp;amp;quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&amp;amp;quot;boot&amp;amp;quot;)
                },
            ]
        );
    }
}

fn main() {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-iteratortrait-shi-xian-zi-ding-yi-die-dai-qi&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 实现自定义迭代器&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，可以通过调用 Vec 类型上的&amp;lt;code&amp;gt;iter&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;iter_mut&amp;lt;&amp;#x2F;code&amp;gt;，&amp;lt;code&amp;gt;into_iter&amp;lt;&amp;#x2F;code&amp;gt;来生成一个迭代器。你也可以为标准库中的其他类型来创建迭代器，例如哈希表。也可以在你自己的类型上，实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait，从而实现任何你想要的功能。唯一必须要被实现的方法是&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法，当你实现&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法后，就可以调用其他&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 实现的默认方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;实现一个从 1 累加到 5 的迭代器来演示一下。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&amp;amp;gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;amp;amp;mut self) -&amp;amp;gt; Option&amp;amp;lt;Self::Item&amp;amp;gt; {
        if self.count &amp;amp;lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}

fn main() {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;shi-yong-iteratortrait-de-qi-ta-fang-fa&amp;quot;&amp;gt;使用&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 的其他方法&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;我们实现&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait，也定义了&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法，因此我们可以调用&amp;lt;code&amp;gt;Iterator&amp;lt;&amp;#x2F;code&amp;gt;trait 上，由标准库默认实现的任意方法，因为它们使用的都是&amp;lt;code&amp;gt;next&amp;lt;&amp;#x2F;code&amp;gt;方法的功能。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();
    assert_eq!(18, sum);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;上面的代码将两个 Counter 迭代器组合为元组数组，并且第二个 Counter 的第一个元素被跳过，因此最后一组元组是&amp;lt;code&amp;gt;(5, None)&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;code&amp;gt;zip&amp;lt;&amp;#x2F;code&amp;gt;方法不会返回元组中带有&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;的元素。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Packages, Crates and Modules</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;05-packages-and-modules&#x2F;"/>
                <updated>2021-01-15T13:42:49+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;05-packages-and-modules&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-5-managing-growing-projects-with-packages-crates-and-modules&amp;quot;&amp;gt;Chapter 5 - Managing Growing Projects with Packages, Crates, and Modules&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;当项目体积越来越大，良好的代码组织就变得很重要。因为只靠脑子记忆整个项目的代码逻辑是不可能的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;目前为止所写的一些示例程序都是一个模块一个文件下的。当项目体积增长，就可以将代码分割到不同模块不同文件中。一个*package（包）*可以包含多个可执行 crate，并且可以选择性的包含一个库 crate。当包体积变大，可以通过提取代码成一个独立的 crate，将它转变为一个外部依赖。本章会涵盖所有这些技术。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;除了分组功能，封装逻辑实现代码可以让代码复用：当你封装了一个操作，其他地方的代码可以通过接口直接使用这个功能，而不需要知道内部具体是如何实现的。封装代码哪部分是公用接口，哪部分是私有属性，这取决于封装实现的编码人员。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;还有一个相关概念称之为&amp;lt;em&amp;gt;scope（域）&amp;lt;&amp;#x2F;em&amp;gt;：这是一个嵌套结构的上下文环境。当读写编译代码时，编码人员和编译器都需要知道特定位置的一些特定名称代表的是一个变量、函数、结构体、模块还是一些其他的东西。你可以创建一个 scope 并指定哪些内容在这个 scope 中。在同一个 scope 中不允许出现两个名称一致的实体。有一些工具可以解决命名冲突。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 模块系统包括：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Packages&amp;lt;&amp;#x2F;strong&amp;gt;：是 Cargo 的一个功能，可以用来创建、测试和发布 crate。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Crates&amp;lt;&amp;#x2F;strong&amp;gt;：一个导出可执行文件或者可执行文件的模块树。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Modules&amp;lt;&amp;#x2F;strong&amp;gt;和&amp;lt;strong&amp;gt;use&amp;lt;&amp;#x2F;strong&amp;gt;：用来控制&amp;lt;em&amp;gt;Paths&amp;lt;&amp;#x2F;em&amp;gt;的组织、域和隐私。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Paths&amp;lt;&amp;#x2F;strong&amp;gt;：命名实体的方式，例如给函数、结构体和模块命名。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;接下来会依次覆盖这些内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-packages-and-crates&amp;quot;&amp;gt;Section 1 - Packages and Crates&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;crate&amp;lt;&amp;#x2F;em&amp;gt;是一个可执行文件或者库。&amp;lt;em&amp;gt;crate root&amp;lt;&amp;#x2F;em&amp;gt;是编译器开始编译并把你的 crate 打包成根模块的源文件。&amp;lt;em&amp;gt;package&amp;lt;&amp;#x2F;em&amp;gt;是由一个或者多个提供了某些功能的 crate 组成的。一个 package 有一个描述如何构建这些 crate 的&amp;lt;em&amp;gt;Cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;一个 package 最多包含一个库 crate，可以包含任意数量的可执行 crate。但是至少要包含一个 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;看一下使用&amp;lt;code&amp;gt;cargo new&amp;lt;&amp;#x2F;code&amp;gt;创建新的 package 时发生了什么。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;$ cargo new my-project
    Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project&amp;amp;#x2F;src
main.rs
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;cargo 生成一个 package，创建了一个&amp;lt;em&amp;gt;cargo.toml&amp;lt;&amp;#x2F;em&amp;gt;文件。看一下 cargo.toml 文件的内容，里面没有关于&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;的信息，因为 Rust 遵循一个规定，&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;文件是与 package 同名的可执行 crate 的入口文件。如果 package 下有一个&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，则它是与 package 同名的库 crate 的入口文件。cargo 将入口文件传给&amp;lt;code&amp;gt;rustc&amp;lt;&amp;#x2F;code&amp;gt;构建库或者可执行文件。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们刚生成的项目中，只有一个 src&amp;#x2F;main.rs 文件，意味着这个项目只有一个可执行 crate。如果 package 中同时具有&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;文件，则说明这个 package 有一个可执行 crate 和一个库 crate，且都与 package 同名。如果 package 具有多个可执行 crate，则对应的文件需要存放在&amp;lt;em&amp;gt;src&amp;#x2F;bin&amp;lt;&amp;#x2F;em&amp;gt;目录下，每个文件都是一个独立的可执行 crate。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;一个 crate 最好将一些相关功能组织到一个 scope 里面，方便在项目之间复用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;将 crate 的功能保持在它的 scope 内，可以明确该功能是我们自己定义的还是该 crate 定义的，避免潜在冲突。比如，&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;crate 定义了一个 trait 叫做&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;。我们也可以自己定义一个结构体叫&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;。由于 crate 的功能被限定在自己的 scope 中，因此当我们引入 rand 的时候，编译器很明确&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;是指向何处的。在我们自己的 crate 中，&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;指向我们定义的结构体；当我们要使用&amp;lt;code&amp;gt;rand&amp;lt;&amp;#x2F;code&amp;gt;中的&amp;lt;code&amp;gt;Rng&amp;lt;&amp;#x2F;code&amp;gt;时，可以通过&amp;lt;code&amp;gt;rand::Rng&amp;lt;&amp;#x2F;code&amp;gt;的方式访问。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-defining-modules-to-control-scope-and-privacy&amp;quot;&amp;gt;Section 2 - Defining Modules to Control Scope and Privacy&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;module 让我们把代码组织管理，方便维护和复用。同时 module 还控制一个实体的隐私性，是外部可访问（public）还是不可访问（private）。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;接下来写一个库 crate 作为例子。这些代码只定义函数声明而不实现函数体，因为现在需要将重点放在代码组织上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们模拟一个餐厅的状况。餐厅有&amp;lt;em&amp;gt;front of house&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;back of house&amp;lt;&amp;#x2F;em&amp;gt;。前厅主要是客人吃饭，服务员送餐，下单等。后厅主要给厨师使用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们可以将功能函数通过嵌套模块的方式组织。使用&amp;lt;code&amp;gt;cargo run --lib restaurant&amp;lt;&amp;#x2F;code&amp;gt;创建一个 restaurant 库 crate，然后写入以下代码。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们用&amp;lt;code&amp;gt;mod&amp;lt;&amp;#x2F;code&amp;gt;关键字创建了一个&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块，并且用花括号将其内容包裹。在这个模块中，可以定义其他的模块，比如&amp;lt;code&amp;gt;hosting&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;serving&amp;lt;&amp;#x2F;code&amp;gt;，当然内部也可以定义其他的内容，比如结构体、枚举、函数、traits 等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;通过模块可以将相关的定义组织在一起。编码人员想阅读或者扩展这个模块时，都能很方便的找到，且不破坏其组织性。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;之前有提到&amp;lt;em&amp;gt;src&amp;#x2F;main.rs&amp;lt;&amp;#x2F;em&amp;gt;和&amp;lt;em&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;em&amp;gt;被称作 crate 的入口文件。之所以叫他们入口文件是因为，这两个文件中的内容都会生成一个根结点为 crate 的模块树。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;crate
└── front_of_house
    ├── hosting
    │   ├── add_to_waitlist
    │   └── seat_at_table
    └── serving
        ├── take_order
        ├── serve_order
        └── take_payment
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这棵树展示了模块的嵌套关系。可以看出这棵树上的一些模块是兄弟节点，这说明他们定义在同一个模块里。这里的概念和数据结构树中的兄弟子父节点的概念是类似的。整个模块的父节点是 crate 隐式节点。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-paths-for-referring-to-an-item-in-the-module-tree&amp;quot;&amp;gt;Section 3 - Paths for Referring to an Item in the Module Tree&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;如何导入模块中的内容使用，Rust 使用和文件系统路径相似的概念。调用一个外部方法的时候需要知道它的路径。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;路径有两种形式：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;从 crate 根节点开始的绝对路径。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;从当前模块开始的相对路径，在当前模块中调用&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;super&amp;lt;&amp;#x2F;code&amp;gt;或者其他关键字和名称。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;绝对路径和相对路径都是一组通过&amp;lt;code&amp;gt;::&amp;lt;&amp;#x2F;code&amp;gt;符号分隔的标识符组成。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;回到之前的例子，应该如何调用&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;这个函数呢？或者说，这个函数的路径是什么？下面的代码用两种方式来调用该方法。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    &amp;amp;#x2F;&amp;amp;#x2F; abs path
    crate::front_of_house::hosting::add_to_waitlist();
    &amp;amp;#x2F;&amp;amp;#x2F; relative path
    front_of_house::hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一种方式使用绝对路径调用函数。&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;函数和&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;函数定义在同一个 crate 中，因此可以使用&amp;lt;code&amp;gt;crate&amp;lt;&amp;#x2F;code&amp;gt;关键字作为绝对路径的开头。紧接着引入连续的模块名直到该函数的位置，和文件系统路径很相似。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;第二种方式使用相对路径调用函数。路径是以&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;开头的，&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块和&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;函数定义在同一层级。这和文件系统中，使用相同层级文件的引入方式类似。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;具体使用哪种方式调用模块取决于你的项目结构。通常倾向于使用绝对路径，这种调用方式下，代码定义和模块引用更加独立。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;目前这个代码还是编译不通过的，编译器此时会报错说 hosting 模块是 private 的。此时我们的调用路径没有错，但是我们并没有该模块的访问权限。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;模块不光能很好的组织代码，它同时具有定义&amp;lt;em&amp;gt;privacy boundary&amp;lt;&amp;#x2F;em&amp;gt;权限界限的功能。具体的实现代码不允许外部代码访问，调用和依赖。如果你想让你的某些内容变为私有，将它封装到一个模块里就行。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 权限系统默认所有实体（方法、结构体、变量、枚举等）都是私有的。父模块中不能调用子模块的内容，但是子模块可以调用父模块的内容。原因在于子模块隐藏了自己的实现细节，但是它可以访问自己定义所在的上下文环境。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;exposing-paths-with-the-pub-keyword&amp;quot;&amp;gt;Exposing Paths with the pub Keyword&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以使用&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字将默认私有的内容对外暴露。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;此时编译代码，编译器依旧报错，此时错误是函数&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;是私有的。&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;模块对外暴露模块时，它里面的内容依旧默认是私有的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因此把&amp;lt;code&amp;gt;add_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;函数也用&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字修饰。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;我们再通过绝对路径和相对路径回顾一下引用过程。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在绝对路径中，路径用模块树的根节点&amp;lt;code&amp;gt;crate&amp;lt;&amp;#x2F;code&amp;gt;开头。然后是定义在根节点中的&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块。&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;是私有模块，但是由于&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;模块是跟它定义在同一个模块中的，因此在他们之间可以调用。接下来是&amp;lt;code&amp;gt;hosting&amp;lt;&amp;#x2F;code&amp;gt;公共模块，最后是&amp;lt;code&amp;gt;ad_to_waitlist&amp;lt;&amp;#x2F;code&amp;gt;公共方法，此时函数调用生效。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在相对路径中，除了第一步以外。其余逻辑和绝对路径中是一样的。相对路径中使用&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;作为路径的开头。&amp;lt;code&amp;gt;front_of_house&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;是定义在同一个模块中的，因此以它们的父模块作为相对路径的开始是正常的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;starting-relative-paths-with-super&amp;quot;&amp;gt;Starting Relative Paths with super&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以使用&amp;lt;code&amp;gt;super&amp;lt;&amp;#x2F;code&amp;gt;关键字来代表父模块。这个关键字和文件系统中的&amp;lt;code&amp;gt;..&amp;lt;&amp;#x2F;code&amp;gt;语法类似。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;fix_incorrect_order&amp;lt;&amp;#x2F;code&amp;gt;函数定义在&amp;lt;code&amp;gt;back_of_house&amp;lt;&amp;#x2F;code&amp;gt;模块中。可以使用&amp;lt;code&amp;gt;super&amp;lt;&amp;#x2F;code&amp;gt;进入到它的父模块&amp;lt;code&amp;gt;crate&amp;lt;&amp;#x2F;code&amp;gt;，也就是根模块中。在根模块中就可以引用到&amp;lt;code&amp;gt;serve_order&amp;lt;&amp;#x2F;code&amp;gt;方法了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;making-structs-and-enums-public&amp;quot;&amp;gt;Making Structs and Enums Public&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字也可以用来修饰结构体和枚举，但是另外有一些细节需要注意。&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;关键字修饰的结构体，它的字段依旧是私有的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod back_of_house {
    pub struct Breakfast {
        pub toast: String,

        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;amp;amp;str) -&amp;amp;gt; Beakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&amp;amp;quot;peaches&amp;amp;quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer(&amp;amp;quot;Rye&amp;amp;quot;);

    meal.toast = String::from(&amp;amp;quot;Wheat&amp;amp;quot;);

    println!(&amp;amp;quot;I&amp;amp;#x27;d like {} toast please&amp;amp;quot;, meal.toast);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;函数中可以访问&amp;lt;code&amp;gt;back_of_house::Breakfast&amp;lt;&amp;#x2F;code&amp;gt;的&amp;lt;code&amp;gt;toast&amp;lt;&amp;#x2F;code&amp;gt;字段，因为它是公开的，但是我们不能访问&amp;lt;code&amp;gt;seasonal_fruit&amp;lt;&amp;#x2F;code&amp;gt;字段，因为字段默认都是私有的。同时，由于&amp;lt;code&amp;gt;back_of_house::Breakfast&amp;lt;&amp;#x2F;code&amp;gt;具有一个私有字段，因此这个结构体需要提供一个作用类似于工厂函数的方法，用来创建实例，这里是&amp;lt;code&amp;gt;summer&amp;lt;&amp;#x2F;code&amp;gt;方法。如果结构体没有提供这样的方法，那么我们将无法实例化它，因为在外部无法对私有字段进行赋值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在枚举类型中，&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;字段修饰的枚举类型，它下面的字段同时也都是公开的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }

    pub fn eat_at_restaurant() {
        let order1 = back_of_house::Appetizer::Soup;
        let order2 = back_of_house::APpetizer::Salad;
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;如果&amp;lt;code&amp;gt;enum&amp;lt;&amp;#x2F;code&amp;gt;里的字段是私有的，那么这个 enum 就没有任何的意义，所有当&amp;lt;code&amp;gt;enum&amp;lt;&amp;#x2F;code&amp;gt;被修饰为&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;时，它内部的字段都自动转为公开。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-4-bringing-paths-into-scope-with-the-use-keyword&amp;quot;&amp;gt;Section 4 - Bringing Paths into Scope with the use Keyword&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;之前的例子中，我们写的模块引用代码中，模块路径很长而且很多内容都是重复的。使用&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字将模块路径导入到当前模块中，可以解决这个问题。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字和一个路径名称，类似于文件系统中创建一个符号链接。也可以通过&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字引入一个相对路径：&amp;lt;code&amp;gt;use self::front_of_house::hosting;&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-idiomatic-use-paths&amp;quot;&amp;gt;Creating Idiomatic use Paths&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;思考一个问题——为什么要通过&amp;lt;code&amp;gt;use crate::front_of_house::hosting&amp;lt;&amp;#x2F;code&amp;gt;引入模块然后再通过&amp;lt;code&amp;gt;hosting&amp;lt;&amp;#x2F;code&amp;gt;模块调用&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;方法。而不是直接引入&amp;lt;code&amp;gt;eat_at_restaurant&amp;lt;&amp;#x2F;code&amp;gt;方法进行调用呢？引入要调用函数的父模块是惯用的方式，因为这样能让我们在调用时清楚的知道这个函数的归属。而引入结构体、枚举以及一些其他内容时，惯用的方式是直接引入全部的路径。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里没有强制性的要求，只不过这种方式是 Rust 代码惯用的方式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;有一种例外情况是，我们引入了两个模块中名称相同的两个内容，此时需要明确其父模块，因为 Rust 是不允许同名的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt;
use std::io;

fn function1() -&amp;amp;gt; fmt::Result{}

fn function2() -&amp;amp;gt; io::Result{}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;providing-new-names-with-the-as-keyword&amp;quot;&amp;gt;Providing New Names with the as Keyword&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;引入不同模块的同名内容的另一个解决方案是通过&amp;lt;code&amp;gt;as&amp;lt;&amp;#x2F;code&amp;gt;关键字对其重新命名一个本地使用名称，或者说是别名。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&amp;amp;gt; Result{}

fn function2() -&amp;amp;gt; IoResult&amp;amp;lt;()&amp;amp;gt;{}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;re-exporting-names-with-pub-use&amp;quot;&amp;gt;Re-exporting Names with pub use&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;当我们使用&amp;lt;code&amp;gt;use&amp;lt;&amp;#x2F;code&amp;gt;关键字引入一个模块时，它仅在当前模块中是可用的。为了让调用我们自己模块的代码也能够使用这个模块名称，我们可以通过&amp;lt;code&amp;gt;pub use&amp;lt;&amp;#x2F;code&amp;gt;关键字对其进行二次导出。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;using-nested-paths-to-clean-up-large-use-lists&amp;quot;&amp;gt;Using Nested Paths to Clean Up Large use Lists&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果我们引入一个模块中的多个内容，每行引入一个模块会让我们的文件内容变得很长。例如：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::cmp::Ordering;
use std::io;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;可以通过嵌套的方式引入同一个模块中的多个内容。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::{cmp::Ordering, io};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在大型项目中，这种方式能有效减少 use 语句的数量。同时嵌套引用允许我们在任意的层级进行嵌套。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::io::{self, Write};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;the-glob-operator&amp;quot;&amp;gt;The Glob Operator&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果想要引入模块下的所有&amp;lt;code&amp;gt;pub&amp;lt;&amp;#x2F;code&amp;gt;的内容，可以使用通配符&amp;lt;code&amp;gt;*&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::*;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这种方式需要谨慎使用，因为有可能会跟你本地的一些名称冲突。这种引入方式一般用在测试模块中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-5-separating-modules-into-different-files&amp;quot;&amp;gt;Section 5 - Separating Modules into Different Files&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;当模块越来越大，你就需要分别将这些代码分割到不同的文件中去了。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;lib.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;front_of_house.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub mod hosting {
    pub fn add_to_waitlist() {}
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在&amp;lt;code&amp;gt;mod front_of_house&amp;lt;&amp;#x2F;code&amp;gt;后接一个分号，此时 Rust 会加载跟这个模块名称相同的文件内容。我们可以将 front_of_house 文件再分割。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;front_of_house.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub mod hosting;
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;src&amp;#x2F;front_of_house&amp;#x2F;hosting.rs&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;pub fn add_to_waitlist() {}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Common Collections</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;06-common-collections&#x2F;"/>
                <updated>2021-03-10T09:54:00+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;06-common-collections&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-6-common-collections&amp;quot;&amp;gt;Chapter 6 - Common Collections&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;Rust 标准库提供了很丰富的数据集合类。大多数数据结构通常只能存储一条数据，而集合可以存储多条数据。跟数组和元组不同，集合的数据存储在 heap 上，这意味着它存储的数据可以不用在编译阶段确定大小和内容，可以在运行时自由操作。这里介绍使用频率最高的三种集合类型：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Vector&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;String&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;HashMap&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-vector&amp;quot;&amp;gt;Section 1 - Vector&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;首先介绍集合&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;，vector 允许你在单个数据结构里存储多个值，这些值存储在内存中相邻的位置。Vector 只能存储相同类型的数据，当你有一个类型列表时 Vector 非常适用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-a-new-vector&amp;quot;&amp;gt;Creating a New Vector&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;Vec::new&amp;lt;&amp;#x2F;code&amp;gt;方法新建一个 vector。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v:Vec&amp;amp;lt;i32&amp;amp;gt; = Vec::new();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Vector 是基于泛型实现的，创建 vector 时如果没有初始化值，则需要指定类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在一些应用场景中，Rust 可以根据指定的初始化值推断 vector 的类型，所以一半很少通过类型变量指定类型。创建 vector 时进行初始化是比较常见的方式，Rust 提供了&amp;lt;code&amp;gt;vec!&amp;lt;&amp;#x2F;code&amp;gt;宏来初始化并创建 vector。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v = vec![1, 2, 3];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;由于我们使用&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的数据初始化 vector，因此 Rust 可以推断出这个 vector 是&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;updating-a-vector&amp;quot;&amp;gt;Updating a Vector&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;push&amp;lt;&amp;#x2F;code&amp;gt;方法在 vector 实例上追加数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;vector 类型的变量要更改时也需要使用&amp;lt;code&amp;gt;mut&amp;lt;&amp;#x2F;code&amp;gt;关键字声明。由于 push 的数据都是&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的，因此 Rust 将此类型推断为 vector 的类型，因此可以不用指定其类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;dropping-a-vector-drops-its-elements&amp;quot;&amp;gt;Dropping a Vector Drops Its Elements&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;跟其他结构体一样，vector 所在的上下文结束时，它将被释放（没有发生所有权转移）。当 vector 被释放时，它内部的数据也将被删除。这听起来似乎简单合理，但是当开始引用 vector 内的数据时，情况将变得复杂。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;reading-elements-of-vectors&amp;quot;&amp;gt;Reading Elements of Vectors&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;有两种方式引用 vector 中存储的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt; let v = vec![1, 2, 3, 4, 5];

let third: &amp;amp;amp;i32 = &amp;amp;amp;v[2];
println!(&amp;amp;quot;The third element is {}&amp;amp;quot;, third);

match v.get(2) {
    Some(third) =&amp;amp;gt; println!(&amp;amp;quot;The third element is {}&amp;amp;quot;, third),
    None =&amp;amp;gt; println!(&amp;amp;quot;There is no third element.&amp;amp;quot;),
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一种方式通过&amp;lt;code&amp;gt;&amp;amp;amp;[]&amp;lt;&amp;#x2F;code&amp;gt;返回一个引用，然后使用下标访问 vector 中的数据，下标从 0 开始，与数组类似。第二种方式通过 vector 实例上的&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法，它返回一个&amp;lt;code&amp;gt;Option&amp;amp;lt;&amp;amp;amp;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;由于有两种访问方式，所以当发生越界访问时，需要针对不同的访问方式做不同的处理。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v = vec![1, 2, 3];

let num = &amp;amp;amp;v[100];

let num = v.get(100);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;第一种访问方式会导致程序报错，当你希望发生越界时程序终止运行，可以使用这种方式。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当使用&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法时，如果发生越界访问，它会返回&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;，后续应当有处理&amp;lt;code&amp;gt;Some(&amp;amp;amp;i32)&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;None&amp;lt;&amp;#x2F;code&amp;gt;的逻辑。这种方式相比程序终止，有更好的用户体验。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当创建了一个有效引用，borrow checker 会强制执行所有权和&amp;lt;a href=&amp;quot;&amp;#x2F;Rust&amp;#x2F;2-ownership.html#the-rules-of-references&amp;quot;&amp;gt;引用规则&amp;lt;&amp;#x2F;a&amp;gt;检查来确保当前引用和其他指向 vector 内容的引用也是有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;amp;amp;v[0];

v.push(6);

println!(&amp;amp;quot;The first element is: {}&amp;amp;quot;, first);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个代码在编译阶段会报错，因为在同一个上下文环境中，对同一个数据存在 immutable 引用时，不能有 mubable 类型的引用。这段代码看上去应该是可以运行的，为什么对 vector 头部的引用和 vector 尾部的 push 操作会发生冲突呢？因为追加数据时有可能存在当前内存不足，在 heap 上重新分配内存，而此时旧的引用还指向之前被释放的内存，此时不符合引用规则中所有引用都必须有效的那一条，因此编译器会直接报错。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;iterating-over-the-values-in-a-vector&amp;quot;&amp;gt;Iterating over the Values in a Vector&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环遍历 vector，获取内部每一条数据的一个 immutable 引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let v = vec![1, 2, 3];

for &amp;amp;amp;i in &amp;amp;amp;v {
    println!(&amp;amp;quot;{}&amp;amp;quot;, i);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;也可以通过遍历 mutable 引用来修改 vector 中的数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut v = vec![1, 2 ,3];
for &amp;amp;amp;i in &amp;amp;amp;mut v {
    i *= 2;
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;using-an-enum-to-store-multiple-types&amp;quot;&amp;gt;Using an Enum to Store Multiple Types&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;之前说过 vector 只能存储相同类型的数据，这个限制很不方便，因为有很多的场景需要存储不同类型的数据列表。我们可以通过定义枚举来满足这种场景需求。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;比如我们需要读取一个电子表格的一行数据，其类型可能是数字、字符串等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&amp;amp;quot;blue&amp;amp;quot;)),
    SpreadsheetCell::Float(10.12),
];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;Rust 在编译阶段需要知道 vector 存储何种数据类型，方便在 heap 上分配每个元素所需要的内存大小。第二个好处是可以明确指定这个 vector 存储的是何种类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;在编写过程中，如果你不能确定枚举下的所有类型，这种方式则不适用。此时可以用 trait 对象作为替代，后面的章节中会介绍到 trait 对象。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-string&amp;quot;&amp;gt;Section 2 - String&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;许多 Rust 新手对 String 会在理解上有一些吃力，基于一下三个可能的原因：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Rust 倾向于抛出任何可能的错误。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;String 是一个比许多程序员所理解的更加复杂的数据类型。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;UTF8。&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;p&amp;gt;将 String 放在集合这一章讨论，是由于 String 类型是基于字节的集合实现的，并且添加了一些实用功能，这些字节在 String 类型中会被解析为文本。下面会讨论 String 类型和其他集合类型的相同之处，如 creating，updating，reading 等操作。还将讨论 String 和其他集合类型的不同之处——Stirng 类型上操作的复杂化，由于人和机器对文本的解释方式不同。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;what-is-a-string&amp;quot;&amp;gt;What Is a String?&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;首先定义一下&amp;lt;em&amp;gt;string&amp;lt;&amp;#x2F;em&amp;gt;的含义。Rust 语言核心中只有一种字符串类型，即字符串切片&amp;lt;code&amp;gt;str&amp;lt;&amp;#x2F;code&amp;gt;。之前介绍过字符串切片，是对一些 utf8 编码数据的引用。保存在可执行文件中的字符串字面量也是&amp;lt;code&amp;gt;str&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;而&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型，是由 Rust 标准库提供而非写在 Rust 语言核心中，是一种可扩展、可修改、utf8 编码的字符串类型。当在 Rust 中提到字符串类型时，一般指的是这两种类型而非其中一种。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-a-new-string&amp;quot;&amp;gt;Creating a New String&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型上的方法大多数都是和&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型相似的。比如新建方法&amp;lt;code&amp;gt;new&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::new();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里新建了一个空的字符串&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;，之后可以在它上面存储文本数据。但是通常在新建字符串时都会有初始化的值。可以使用&amp;lt;code&amp;gt;to_string&amp;lt;&amp;#x2F;code&amp;gt;方法将字面量或者&amp;lt;code&amp;gt;str&amp;lt;&amp;#x2F;code&amp;gt;数据转换成&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型。也可以使用&amp;lt;code&amp;gt;String::from&amp;lt;&amp;#x2F;code&amp;gt;方法来创建，跟&amp;lt;code&amp;gt;to_string&amp;lt;&amp;#x2F;code&amp;gt;方法效果是一样的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let data = &amp;amp;quot;initial data&amp;amp;quot;;

let s = data.to_string();
let s = &amp;amp;quot;initial data&amp;amp;quot;.to_string();

let s = String::from(&amp;amp;quot;initial data&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型是 utf8 编码的，因此它可以存储任何 utf8 编码范围内的文本数据，以下都是有效的字符串数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let hello = String::from(&amp;amp;quot;السلام عليكم&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Dobrý den&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Hello&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;שָׁלוֹם&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;नमस्ते&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;こんにちは&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;안녕하세요&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;你好&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Olá&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Здравствуйте&amp;amp;quot;);
let hello = String::from(&amp;amp;quot;Hola&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;updating-a-string&amp;quot;&amp;gt;Updating a String&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型大小、内容都可以改变，可以像&amp;lt;code&amp;gt;Vec&amp;amp;lt;T&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;一样用 push 的方式追加数据。此外，也可以通过&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符或者&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏来进行字符串拼接。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;appending-to-a-string-with-push-str-and-push&amp;quot;&amp;gt;Appending to a String with &amp;lt;code&amp;gt;push_str&amp;lt;&amp;#x2F;code&amp;gt; and &amp;lt;code&amp;gt;push&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;push_str&amp;lt;&amp;#x2F;code&amp;gt;方法追加一个字符串切片。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;foo&amp;amp;quot;);

s.push_str(&amp;amp;quot;bar&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;push&amp;lt;&amp;#x2F;code&amp;gt;方法追加单个字符。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;s.push(&amp;amp;#x27;a&amp;amp;#x27;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;concatenation-with-the-operator-or-the-format-macro&amp;quot;&amp;gt;Concatenation with the + Operator or the format! Macro&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符拼接字符串&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;Hello, &amp;amp;quot;);
let s2 = String::from(&amp;amp;quot;world!&amp;amp;quot;);
let s3 = s1 + &amp;amp;amp;s2; &amp;amp;#x2F;&amp;amp;#x2F; 这里s1的所有权发生了转移
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;加运算执行完毕后&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;不再有效的原因，和为什么要使用&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;的引用进行加运算的原因，在于执行&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算时所调用的方法。该方法的声明类似于：&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn add(self, s: &amp;amp;amp;str) -&amp;amp;gt; String
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;标准库中的&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法是通过泛型声明的。这里我们使用&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型作为说明。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;首先&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;变量之前有&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;修饰符，说明这里是一个&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;的引用。由于&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法的声明，只能将一个第二个字符串的引用作为参数和第一个字符串做合并。也不能合并两个&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型的数据。但是，&amp;lt;code&amp;gt;&amp;amp;amp;s2&amp;lt;&amp;#x2F;code&amp;gt;是一个&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;类型而非&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型，为什么编译器没有报错？&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;因为编译器可以将&amp;lt;code&amp;gt;&amp;amp;amp;String&amp;lt;&amp;#x2F;code&amp;gt;类型*coerce（强转换）*为&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;类型。调用&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法时，Rust 进行了 deref coercion（隐式强转换），在这个例子中，&amp;lt;code&amp;gt;&amp;amp;amp;s2&amp;lt;&amp;#x2F;code&amp;gt;将返回&amp;lt;code&amp;gt;&amp;amp;amp;s2[..]&amp;lt;&amp;#x2F;code&amp;gt;。由于&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法没有获取参数&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的所有权，因此&amp;lt;code&amp;gt;s2&amp;lt;&amp;#x2F;code&amp;gt;变量在计算之后依然是有效的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;其次，&amp;lt;code&amp;gt;add&amp;lt;&amp;#x2F;code&amp;gt;方法获取了&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;的所有权。这意味着&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;变量在进行计算之后不再有效。&amp;lt;code&amp;gt;s3 = s1 + &amp;amp;amp;s2;&amp;lt;&amp;#x2F;code&amp;gt;看起来是进行了值的复制和拼接，并且创建了新的变量。实际上是对&amp;lt;code&amp;gt;s1&amp;lt;&amp;#x2F;code&amp;gt;进行内容追加后转移了的所有权。看似进行了许多复制和变量的新建，实际上要比这更有效率。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;而在多个字符串进行拼接时，&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符看起来会比较啰嗦。此时使用&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏代替是比较好的方案。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let s1 = String::from(&amp;amp;quot;tic&amp;amp;quot;);
let s2 = String::from(&amp;amp;quot;tac&amp;amp;quot;);
let s3 = String::from(&amp;amp;quot;toe&amp;amp;quot;);

let s = format!(&amp;amp;quot;{}-{}-{}&amp;amp;quot;, s1, s2, s3);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;format!&amp;lt;&amp;#x2F;code&amp;gt;宏的方法比&amp;lt;code&amp;gt;+&amp;lt;&amp;#x2F;code&amp;gt;运算符可读性更好，并且它不会获取任何参数的所有权。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;indexing-into-strings&amp;quot;&amp;gt;Indexing into Strings&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;在其他语言中，使用索引访问字符串中的某个字符是常见的操作。但是在 Rust 中会报错，Rust 不支持数字索引，要解释这个问题，需要讨论 Rust 如何在内存中存储 String 数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;internal-representation&amp;quot;&amp;gt;Internal Representation&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型是对&amp;lt;code&amp;gt;Vec&amp;amp;lt;u8&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型的一层封装。来看一些 utf8 编码的字符串示例&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let mut s = String::from(&amp;amp;quot;hola&amp;amp;quot;);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在这个示例中，&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的长度是 4，意思是 vector 存储的“hola”有 4 字节长，每个字母占 1 字节。但是在其他字符数据的情况下呢？&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let hello = &amp;amp;quot;Здравствуйте&amp;amp;quot;;
&amp;amp;#x2F;&amp;amp;#x2F; 注意这是西里尔字母З，而不是阿拉伯数字3
let answer = &amp;amp;amp;hello[0];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这个例子中，&amp;lt;code&amp;gt;answer&amp;lt;&amp;#x2F;code&amp;gt;会是&amp;lt;code&amp;gt;З&amp;lt;&amp;#x2F;code&amp;gt;吗？在 utf8 编码中，3 的第一个字节是&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;，第二个字节是&amp;lt;code&amp;gt;151&amp;lt;&amp;#x2F;code&amp;gt;，所以&amp;lt;code&amp;gt;answer&amp;lt;&amp;#x2F;code&amp;gt;的值是&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;，而&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;不是一个有效字符。这跟用户期望返回第一个字符不一致，但 Rust 在 0 索引处存储的值就是&amp;lt;code&amp;gt;208&amp;lt;&amp;#x2F;code&amp;gt;的 16 进制。用户通常不希望获得字节类型的数据，哪怕字符串全部是由拉丁字母组成的。如果&amp;lt;code&amp;gt;&amp;amp;amp;&amp;quot;hello&amp;quot;[0]&amp;lt;&amp;#x2F;code&amp;gt;是一个合法的索引，那么它也只会返回&amp;lt;code&amp;gt;104&amp;lt;&amp;#x2F;code&amp;gt;而不是&amp;lt;code&amp;gt;h&amp;lt;&amp;#x2F;code&amp;gt;。因此，Rust 不允许使用索引访问字符串中的字符，在编译阶段就抛出错误，以免在开发阶段对代码的执行产生误解。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;bytes-and-scalar-values-and-grapheme-clusters&amp;quot;&amp;gt;Bytes and Scalar Values and Grapheme Clusters&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;从 Rust 的视角来看，有三种相关的方式查看 String 中的数据：&amp;lt;em&amp;gt;Bytes（可执行）&amp;lt;&amp;#x2F;em&amp;gt;，&amp;lt;em&amp;gt;scalar values（标量）&amp;lt;&amp;#x2F;em&amp;gt;，&amp;lt;em&amp;gt;grapheme clusters（词组）&amp;lt;&amp;#x2F;em&amp;gt;（最接近人类字符的概念）。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;用梵文写的印地语“नमस्ते“，在&amp;lt;code&amp;gt;Vec&amp;amp;lt;u8&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;中存储的数据是&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;这 18 个 16 进制数据就是计算机最终存储的数据。如果从 unicode 标量的角度看，也是 Rust 中的&amp;lt;code&amp;gt;char&amp;lt;&amp;#x2F;code&amp;gt;类型。这些字节串可以看作&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;[&amp;#x27;न&amp;#x27;, &amp;#x27;म&amp;#x27;, &amp;#x27;स&amp;#x27;, &amp;#x27;्&amp;#x27;, &amp;#x27;त&amp;#x27;, &amp;#x27;े&amp;#x27;]&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;其中有 6 个 char 字符，其中第四个和第六个是变音符号，不具备表意功能。最后，如果从词组的角度看，就可以得到一个人类阅读友好的组成单词的四个字母。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;[&amp;quot;न&amp;quot;, &amp;quot;म&amp;quot;, &amp;quot;स्&amp;quot;, &amp;quot;ते&amp;quot;]&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&amp;lt;p&amp;gt;Rust 提供了多种方式来解释计算机存储的原始字符数据，满足不同程序的数据需求，而不用关心具体使用的是哪种人类语言。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 不允许使用索引访问字符串数据的最后一个原因是，索引操作要求数据量不会影响读取的时间复杂度（O(1)）。但是这在 String 类型的性能上是不能够保证的，因为 Rust 需要从头遍历到索引位置处，找出其中有效的字符。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;slicing-strings&amp;quot;&amp;gt;Slicing Strings&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;索引访问 String 不是一个好的方案，原因还在于索引访问的返回值不清晰，是应该返回可执行数据，还是字符，还是词组，还是字符串切片呢？因此，Rust 需要编码者在使用索引创建字符串切片时更加准确的定义返回值。为了更具体的索引，请使用&amp;lt;code&amp;gt;[]&amp;lt;&amp;#x2F;code&amp;gt;和范围语法创建字符串切片，而不是在&amp;lt;code&amp;gt;[]&amp;lt;&amp;#x2F;code&amp;gt;中使用单个数字。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let hello = &amp;amp;quot;Здравствуйте&amp;amp;quot;;

let s = &amp;amp;amp;hello[0..4];
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;这里&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;是一个&amp;lt;code&amp;gt;&amp;amp;amp;str&amp;lt;&amp;#x2F;code&amp;gt;，由于每个西里尔字符使用 2 字节编码，因此&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;的值应该是 Зд。如果把&amp;lt;code&amp;gt;s&amp;lt;&amp;#x2F;code&amp;gt;变量改成&amp;lt;code&amp;gt;&amp;amp;amp;hello[0..3]&amp;lt;&amp;#x2F;code&amp;gt;，程序会在运行时崩溃——当前索引不在正确的字符边界处。在使用 range 创建字符串切片时需要小心，因为有可能会让程序崩溃。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;methods-for-iterating-over-strings&amp;quot;&amp;gt;Methods for Iterating Over Strings&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;如果需要在每个单独的 unicode 字符标量上执行某些操作，可以通过 String 的&amp;lt;code&amp;gt;chars&amp;lt;&amp;#x2F;code&amp;gt;方法来遍历每个字符标量，它返回的是&amp;lt;code&amp;gt;char&amp;lt;&amp;#x2F;code&amp;gt;类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;for c in &amp;amp;quot;नमस्ते&amp;amp;quot;.chars() {
    println!(&amp;amp;quot;{}&amp;amp;quot;, c);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;bytes&amp;lt;&amp;#x2F;code&amp;gt;方法返回原始的字节数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;for b in &amp;amp;quot;नमस्ते&amp;amp;quot;.bytes() {
    println!(&amp;amp;quot;{}&amp;amp;quot;, b);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;请记住有效的 unicode 字符标量是有 1 个或以上的字节所组成的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;由于返回词组的方法比较复杂，因此标准库并没有提供相关功能。有需要可以上&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;crates.io&amp;#x2F;&amp;quot;&amp;gt;crates.io&amp;lt;&amp;#x2F;a&amp;gt;查看。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;strings-are-not-so-simple&amp;quot;&amp;gt;Strings Are Not So Simple&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 将正确的处理字符串数据作为所有程序的默认行为，因此编码者需要在前期投入精力去思考如何正确的处理 utf8 数据。代价则是相比其他编程语言，Rust 暴露了更多的复杂性给编码者，但同时能够让你避免类似于非 ASCII 字符的错误。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-hashmap&amp;quot;&amp;gt;Section 3 - HashMap&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;最后一个要介绍的常见集合是&amp;lt;em&amp;gt;hash map&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;code&amp;gt;HashMap&amp;amp;lt;K, V&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;类型存储的是&amp;lt;code&amp;gt;K&amp;lt;&amp;#x2F;code&amp;gt;类型与&amp;lt;code&amp;gt;V&amp;lt;&amp;#x2F;code&amp;gt;类型之间的键值对映射关系。通过&amp;lt;em&amp;gt;hashing function&amp;lt;&amp;#x2F;em&amp;gt;来实现，这个函数确定了键和值如何在内存中存储。这个功能很多编程语言都提供了，只不过叫法有差异，比如哈希表、对象、map、字典等等。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;当你想通过非数字索引的方式查看数据时，哈希表是很实用的，它使用的是任意数据类型的键来检索数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;我们仅列举一些常用的 API，在标准库&amp;lt;code&amp;gt;HashMap&amp;amp;lt;K, V&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;中定义了许多实用的方法，具体查阅标准库文档。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;creating-a-new-hash-map&amp;quot;&amp;gt;Creating a New Hash Map&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过&amp;lt;code&amp;gt;new&amp;lt;&amp;#x2F;code&amp;gt;方法新建，&amp;lt;code&amp;gt;insert&amp;lt;&amp;#x2F;code&amp;gt;方法插入数据。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::colloctions::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Yellow&amp;amp;quot;), 50);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;首先需要引入&amp;lt;code&amp;gt;HashMap&amp;lt;&amp;#x2F;code&amp;gt;模块。在介绍的三种集合中，HashMap 是使用频率最低的，因此它没有被默认包含到上下文中。标准库对 HashMap 的支持也很少，比如没有宏来构建 HashMap。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;跟 vectors 一样，哈希表的数据存储在 heap 上。上面的代码定义了一个键为&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;类型，值为&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;类型的哈希表。哈市表跟 vector 一样是同质的，即键是同一种数据类型，值也是同一种数据类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;另外一种创建哈希表的方式是通过迭代器和元组组成的 vector 上的&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法，其中每个元组包含哈希表的键和值。&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法将数据收集到多种集合类型中，包括哈希表。&amp;lt;code&amp;gt;zip&amp;lt;&amp;#x2F;code&amp;gt;方法可以用来创建元组组成的 vector。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let teams = vec![String::from(&amp;amp;quot;Blue&amp;amp;quot;), String::from(&amp;amp;quot;Yellow&amp;amp;quot;)];
let initial_scores = vec![10, 50];

let mut scores: HashMap&amp;amp;lt;_, _&amp;amp;gt; =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;类型声明&amp;lt;code&amp;gt;HashMap&amp;amp;lt;_, _&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;是必须的，因为&amp;lt;code&amp;gt;collect&amp;lt;&amp;#x2F;code&amp;gt;方法会把数据收集到许多种集合中，除非你指定，否则 Rust 不知道你需要的是哪一种。键和值的类型参数使用下划线占位，此时 Rust 可以通过返回值来推断键和值的类型。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;hash-maps-and-ownership&amp;quot;&amp;gt;Hash Maps and Ownership&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;对于实现了&amp;lt;code&amp;gt;Copy&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型来说，比如&amp;lt;code&amp;gt;i32&amp;lt;&amp;#x2F;code&amp;gt;，值是拷贝进哈希表的。对于 owned 的数据类型来说，比如&amp;lt;code&amp;gt;String&amp;lt;&amp;#x2F;code&amp;gt;，所有权会被转移到哈希表上。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let field_name = String::from(&amp;amp;quot;Favorite color&amp;amp;quot;);
let field_value = String::from(&amp;amp;quot;Blue&amp;amp;quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);

&amp;amp;#x2F;&amp;amp;#x2F; error[E0382]: borrow of moved value: `field_name`
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;在这个例子中，当&amp;lt;code&amp;gt;field_name&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;field_value&amp;lt;&amp;#x2F;code&amp;gt;被添加到 map 之后，我们是不能使用这个值的，因为所有权被传递到了 map 中。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;如果我们使用引用插入到哈希表中，那么所有权将不会被移动到哈希表中。但是，此时需要保证引用的有效时间至少要和哈希表一致。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;accessing-values-in-a-hash-map&amp;quot;&amp;gt;Accessing Values in a Hash Map&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法获取哈希表的值。&amp;lt;code&amp;gt;get&amp;lt;&amp;#x2F;code&amp;gt;方法返回&amp;lt;code&amp;gt;Option&amp;amp;lt;&amp;amp;amp;V&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collection::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Yellow&amp;amp;quot;), 50);

let team_name = String::from(&amp;amp;quot;Blue&amp;amp;quot;);
let score = scores.get(&amp;amp;amp;team_name);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;for&amp;lt;&amp;#x2F;code&amp;gt;循环遍历键值对&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Yellow&amp;amp;quot;), 50);

for (key, value) in &amp;amp;amp;scores {
    println!(&amp;amp;quot;{}: {}&amp;amp;quot;, key, value);
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;updating-a-hash-map&amp;quot;&amp;gt;Updating a Hash Map&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;键值对的数量是可以增加的，但是每个键只能关联到一个值。当你需要修改哈希表的值时，需要考虑到值已经关联了值的情况，覆盖、舍弃还是合并。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;overwriting-a-value&amp;quot;&amp;gt;Overwriting a Value&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;如果在插入值之后，重新对同一个键进行了插值，那么新值会将旧值覆盖。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);
scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 25);

println!(&amp;amp;quot;{:?}&amp;amp;quot;, scores);
&amp;amp;#x2F;&amp;amp;#x2F; 25
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h4 id=&amp;quot;only-inserting-a-value-if-the-key-has-no-value&amp;quot;&amp;gt;Only Inserting a Value If the Key Has No Value&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;检查键是否关联了值，如果没有就给他它关联一个新值，这是很常见的逻辑。哈希表对这种情况提供了一个特殊的 API&amp;lt;code&amp;gt;entry&amp;lt;&amp;#x2F;code&amp;gt;，它的参数是你需要检查的键，返回一个&amp;lt;code&amp;gt;Entry&amp;lt;&amp;#x2F;code&amp;gt;枚举，代表一个值是否存在。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&amp;amp;quot;Blue&amp;amp;quot;), 10);

scores.entry(String::from(&amp;amp;quot;Yellow&amp;amp;quot;)).or_insert(50);
scores.entry(String::from(&amp;amp;quot;Blue&amp;amp;quot;)).or_insert(50);

println!(&amp;amp;quot;{:?}&amp;amp;quot;, scores);
&amp;amp;#x2F;&amp;amp;#x2F; {&amp;amp;quot;Yellow&amp;amp;quot;: 50, &amp;amp;quot;Blue&amp;amp;quot;: 10}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;or_insert&amp;lt;&amp;#x2F;code&amp;gt;方法当键存在时，返回一个该键值的可变引用。如果不存在，则把参数当作值插入到哈希表中然后返回一个可变引用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h4 id=&amp;quot;updating-a-value-based-on-the-old-value&amp;quot;&amp;gt;Updating a Value Based on the Old Value&amp;lt;&amp;#x2F;h4&amp;gt;
&amp;lt;p&amp;gt;另一种常见场景是使用旧值更新哈希表的新值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;use std::collections::HashMap;

let text = &amp;amp;quot;hello world wonderful world&amp;amp;quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&amp;amp;quot;{:?}&amp;amp;quot;, map);
&amp;amp;#x2F;&amp;amp;#x2F; {&amp;amp;quot;world&amp;amp;quot;: 2, &amp;amp;quot;hello&amp;amp;quot;: 1, &amp;amp;quot;wonderful&amp;amp;quot;: 1}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;hashing-functions&amp;quot;&amp;gt;Hashing Functions&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;HashMap&amp;lt;&amp;#x2F;code&amp;gt;默认使用*&amp;lt;a rel=&amp;quot;noopener&amp;quot; target=&amp;quot;_blank&amp;quot; href=&amp;quot;https:&amp;#x2F;&amp;#x2F;www.131002.net&amp;#x2F;siphash&amp;#x2F;siphash.pdf&amp;quot;&amp;gt;cryptographically strong&amp;lt;&amp;#x2F;a&amp;gt;&amp;lt;em&amp;gt;散列函数。它对 DoS 攻击有很好对抵抗性。这个算法不是最快的，但是从安全性的角度考虑，舍弃这点性能是值得的。如果你想自己指定散列函数，你可以指定一个&amp;lt;&amp;#x2F;em&amp;gt;hasher*来自己切换散列函数。hasher 是一个实现了&amp;lt;code&amp;gt;BuildHasher&amp;lt;&amp;#x2F;code&amp;gt;trait 的类型。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
            
            <entry>
                <title>Using Structs</title>
                <link href="https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;03-struct&#x2F;"/>
                <updated>2022-05-15T03:43:32+0800</updated>
                <id>https:&#x2F;&#x2F;leokang28.github.io&#x2F;blog&#x2F;03-struct&#x2F;</id>
                <content type="html">&amp;lt;h1 id=&amp;quot;chapter-3-using-structs-to-structure-related-data&amp;quot;&amp;gt;Chapter 3 - Using Structs to Structure Related Data&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;p&amp;gt;结构体是一个编码者自定义的数据类型，可以让编码者自己命名，组织一些数据形成一个有特殊意义的集合。跟面向对象概念中的对象概念类似。结构体和枚举是创建新类型的基础，以致能够充分利用 Rust 编译器做类型检查。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-1-jie-gou-ti-de-ding-yi-he-shi-li-hua&amp;quot;&amp;gt;Section 1 - 结构体的定义和实例化&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;结构体跟元组有些类似，它内部的数据也可以是不同的类型。与元组不同的地方是，你可以对每个数据命名，便于理解这些数据具体代表的是什么含义。由于有了这些名称，你不再需要像元组一样按顺序访问内部元素。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;struct&amp;lt;&amp;#x2F;code&amp;gt;关键字后加一个名称就定义了一个结构体。结构体的自定义名称应该是充分语义化的，能够传达内部数据为何要组织在一起。在花括号中，定义了每个元素的名称和类型，这些内部元素称之为&amp;lt;em&amp;gt;fields（字段）&amp;lt;&amp;#x2F;em&amp;gt;。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;通过结构体生成的变量称之为&amp;lt;em&amp;gt;instance（实例）&amp;lt;&amp;#x2F;em&amp;gt;。创建一个实例需要指明使用的结构体名称，并且以&amp;lt;em&amp;gt;key-value&amp;lt;&amp;#x2F;em&amp;gt;的形式填充每一个字段。key 是在结构体中定义好的字段名称，value 是我们想要在对应的字段中存储的数据。实例化的时候，字段顺序不需要和结构体定义的顺序一致。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let user1 = User {
    email: String::from(&amp;amp;quot;someone@example.com&amp;amp;quot;),
    username: String::from(&amp;amp;quot;someusername123&amp;amp;quot;),
    active: true,
    sign_in_count: 1,
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;获取实例中的数据可以通过点操作符，例如&amp;lt;code&amp;gt;user1.email&amp;lt;&amp;#x2F;code&amp;gt;。只要该实例是 mutable 的，我们就可以对它上面的字段数据做修改，例如&amp;lt;code&amp;gt;user1.mail = String::from(&amp;quot;anotheremail@example.com&amp;quot;);&amp;lt;&amp;#x2F;code&amp;gt;。需要注意，在改变数据时，实例本身需要是 mutable 的，Rust 不允许仅其中某些字段为 mutable。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;与其他表达式一样，可以在函数最后实例化一个结构体并将其作为函数返回值。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn build_user(email: String, username: String) -&amp;amp;gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-li-hua-jian-xie&amp;quot;&amp;gt;实例化简写&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;因为参数名和字段名是完全相等的，可以通过字段初始化简写语法来创建实例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn build_user(email: String, username: String) -&amp;amp;gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;tong-guo-qi-ta-shi-li-chuang-jian-xin-shi-li&amp;quot;&amp;gt;通过其他实例创建新实例&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;通过已经存在的实例创建新实例是一个非常便捷的方法，并且可以使用结构体更新语法。先看一下使用普通方法的例子&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let user2 = User {
    email: String::from(&amp;amp;quot;another@example.com&amp;amp;quot;),
    username: String::from(&amp;amp;quot;anotherusername567&amp;amp;quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;创建一个新实例&amp;lt;code&amp;gt;user2&amp;lt;&amp;#x2F;code&amp;gt;，并且&amp;lt;code&amp;gt;active&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;sign_in_count&amp;lt;&amp;#x2F;code&amp;gt;这两个字段是从&amp;lt;code&amp;gt;user1&amp;lt;&amp;#x2F;code&amp;gt;取值的。使用结构体更新语法可以使代码量更少。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;let user2 = User {
    email: String::from(&amp;amp;quot;another@example.com&amp;amp;quot;),
    username: String::from(&amp;amp;quot;anotherusername567&amp;amp;quot;),
    ..user1
};
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-yuan-zu-he-jie-gou-ti-gou-zao-xin-lei-xing&amp;quot;&amp;gt;使用元组和结构体构造新类型&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;我们可以定义一些像元组一样的结构体，称之为元组结构体。元组结构体具有语义化的名称，但是没有字段名，也就是说只有字段类型。元组结构体在给元组命名和与其他元组做区分时特别有用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;元组结构体的定义：&amp;lt;code&amp;gt;struct&amp;lt;&amp;#x2F;code&amp;gt;关键字加一个名称，后面再跟一个括号，里面是字段类型列表。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;black&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;origin&amp;lt;&amp;#x2F;code&amp;gt;是不同的变量，因为他们结构体的名称不同，哪怕他们内部的字段类型列表是完全一致的。元组结构体的实例和普通的元组在操作上没有任何区别。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;unit-like-structs-without-any-fields&amp;quot;&amp;gt;Unit-Like Structs Without Any Fields&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;结构体定义时也可以没有任何的字段，这种结构体称为&amp;lt;em&amp;gt;unit-like struct（类单元结构）&amp;lt;&amp;#x2F;em&amp;gt;，因为他们的表现跟单元类型&amp;lt;code&amp;gt;()&amp;lt;&amp;#x2F;code&amp;gt;相似。当你需要在某个类型上实现某些 trait，但又不想存储任何数据时，类单元结构很有用。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-2-yi-ge-jie-gou-ti-shi-li-cheng-xu&amp;quot;&amp;gt;Section 2 - 一个结构体示例程序&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;写一个计算矩形面积的程序，从普通的变量开始。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let width1 = 50;
    let height1 = 30;

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, area(width1, height1));
}

fn area(width:u32, height:u32) -&amp;amp;gt; u32 {
    width * height
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;矩形的高度和宽度是两个关联的变量，因为他们构成了一个矩形，但是目前在程序中看不到任何关联性，可读性太差。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-yuan-zu-zhong-gou&amp;quot;&amp;gt;使用元组重构&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let rect1 = (50, 30);

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, area(rect1));
}

fn area(rect: (u32, u32)) -&amp;amp;gt; u32 {
    rect.0 * rect.1
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;使用元组稍微有了一些结构性，但是在可读性还是不够好，因为元组不能够对字段进行命名。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;shi-yong-jie-gou-ti-zhong-gou&amp;quot;&amp;gt;使用结构体重构&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Rect {
    width: u32,
    height: u32,
}
fn main() {
    let rect1= Rect {
        width: 50,
        height: 30,
    };

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, area(rect1));
}

fn area(rect: Rect) -&amp;amp;gt; u32 {
    rect.width * rect.height
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;定义一个矩形类型之后，代码目前可读性和抽象都比较好。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h2 id=&amp;quot;section-3-fang-fa-yu-fa&amp;quot;&amp;gt;Section 3 - 方法语法&amp;lt;&amp;#x2F;h2&amp;gt;
&amp;lt;p&amp;gt;方法和函数的唯一区别在于，方法是定义在类型中的，有它特定的执行上下文。方法的第一个参数永远是&amp;lt;code&amp;gt;self&amp;lt;&amp;#x2F;code&amp;gt;，是一个当前调用它的实例。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;fang-fa-ding-yi&amp;quot;&amp;gt;方法定义&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;关键字。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;struct Rect {
    width: u32,
    height: u32,
}

&amp;amp;#x2F;&amp;amp;#x2F; 方法定义
impl Rect {
    fn area(&amp;amp;amp;self) -&amp;amp;gt; u32 {
        self.width * self.height
    }
}
fn main() {
    let rect1= Rect {
        width: 50,
        height: 30,
    };

    println!(&amp;amp;quot;area is {}&amp;amp;quot;, rect1.area());
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;:::details -&amp;amp;gt;和.
在 C&amp;#x2F;C++中，方法的调用有两种操作符，分别是&amp;lt;code&amp;gt;-&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;.&amp;lt;&amp;#x2F;code&amp;gt;。当直接在实例上调用方法时使用&amp;lt;code&amp;gt;.&amp;lt;&amp;#x2F;code&amp;gt;操作符，当使用指针调用方法时使用&amp;lt;code&amp;gt;-&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;操作符。也就是说当&amp;lt;code&amp;gt;obj&amp;lt;&amp;#x2F;code&amp;gt;是一个指针时，&amp;lt;code&amp;gt;obj-&amp;amp;gt;func()&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;(*obj).func()&amp;lt;&amp;#x2F;code&amp;gt;是一样的。&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;p&amp;gt;Rust 中没有和&amp;lt;code&amp;gt;-&amp;amp;gt;&amp;lt;&amp;#x2F;code&amp;gt;等同的操作符，Rust 的方案是自动引用和解析引用。当你通过&amp;lt;code&amp;gt;obj.func()&amp;lt;&amp;#x2F;code&amp;gt;调用方法时，Rust 会自动加上&amp;lt;code&amp;gt;&amp;amp;amp;&amp;lt;&amp;#x2F;code&amp;gt;、&amp;lt;code&amp;gt;&amp;amp;amp;mut&amp;lt;&amp;#x2F;code&amp;gt;和&amp;lt;code&amp;gt;*&amp;lt;&amp;#x2F;code&amp;gt;，让&amp;lt;code&amp;gt;obj&amp;lt;&amp;#x2F;code&amp;gt;能够跟函数声明匹配。
:::&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;h3 id=&amp;quot;duo-ge-can-shu-de-fang-fa&amp;quot;&amp;gt;多个参数的方法&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;fn main() {
    let rect1 = Rect {
        width: 30,
        height: 50,
    };
    let rect2 = Rect {
        width: 10,
        height: 40,
    };
    let rect3 = Rect {
        width: 60,
        height: 45,
    };

    println!(&amp;amp;quot;Can rect1 hold rect2? {}&amp;amp;quot;, rect1.can_hold(&amp;amp;amp;rect2));
    println!(&amp;amp;quot;Can rect1 hold rect3? {}&amp;amp;quot;, rect1.can_hold(&amp;amp;amp;rect3));
}

impl Rect {
    fn area(&amp;amp;amp;self) -&amp;amp;gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;amp;amp;self, other: &amp;amp;amp;Rect) -&amp;amp;gt; bool {
        self.width &amp;amp;gt; other.width &amp;amp;amp;&amp;amp;amp; self.height &amp;amp;gt; other.height
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;h3 id=&amp;quot;duo-ge-impldai-ma-kuai&amp;quot;&amp;gt;多个&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块&amp;lt;&amp;#x2F;h3&amp;gt;
&amp;lt;p&amp;gt;Rust 是允许多个&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块的，例如&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;pre data-lang=&amp;quot;rust&amp;quot; class=&amp;quot;language-rust &amp;quot;&amp;gt;&amp;lt;code class=&amp;quot;language-rust&amp;quot; data-lang=&amp;quot;rust&amp;quot;&amp;gt;impl Rect {
    fn area(&amp;amp;amp;self) -&amp;amp;gt; u32 {
        self.width * self.height
    }
}

impl Rect {
    fn can_hold(&amp;amp;amp;self, other: &amp;amp;amp;Rect) -&amp;amp;gt; bool {
        self.width &amp;amp;gt; other.width &amp;amp;amp;&amp;amp;amp; self.height &amp;amp;gt; other.height
    }
}
&amp;lt;&amp;#x2F;code&amp;gt;&amp;lt;&amp;#x2F;pre&amp;gt;
&amp;lt;p&amp;gt;目前没有必要写成多个&amp;lt;code&amp;gt;impl&amp;lt;&amp;#x2F;code&amp;gt;代码块，后面会介绍到这种方法的适用情况。&amp;lt;&amp;#x2F;p&amp;gt;
</content>
            </entry>
            
        
    
        
        
    
</feed>
