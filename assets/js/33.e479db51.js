(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{382:function(v,_,t){"use strict";t.r(_);var a=t(42),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"传输层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[v._v("#")]),v._v(" 传输层")]),v._v(" "),t("p",[v._v("TCP/IP协议簇中的传输层位于应用层和网络层之间。为应用层提供服务，接收来自网络层的服务。传输层是客户端程序和服务器程序的联络人，是进程到进程的连接。传输层是TCP/IP的核心；是互联网点到点交换数据的逻辑媒介。")]),v._v(" "),t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),t("p",[v._v("传输层在两个应用层之间提供进程到进程的服务，一个进程在本地，另一个在远程主机。两个应用层存在一条假想的直接逻辑链路。传输层为应用层提供了两种可用协议。一种是UDP，一种是TCP。UDP提供不可靠、无连接的服务，TCP提供可靠、面向连接的服务。应用层程序必须指明使用哪一种运输层协议。")]),v._v(" "),t("p",[v._v("UDP和TCP的基本职责是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的"),t("strong",[v._v("多路复用")]),v._v("（multiplexing）和"),t("strong",[v._v("多路分解")]),v._v("（demultiplexing）。UDP和TCP还可以提供报文的完整性检查。进程间的数据交付和差错校验是运输层提供的最低限度的服务，也是UDP仅能提供的两种服务。TCP则提供了多种附加服务，比如可靠数据传输、拥塞控制等。")]),v._v(" "),t("h2",{attrs:{id:"多路复用和多路分解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多路复用和多路分解"}},[v._v("#")]),v._v(" 多路复用和多路分解")]),v._v(" "),t("p",[v._v("将运输层报文段中的数据交付到正确的套接字的工作称为"),t("strong",[v._v("多路分解")]),v._v("。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文，然后将报文传递到网络层，这些工作称为"),t("strong",[v._v("多路复用")]),v._v("。")]),v._v(" "),t("p",[v._v("我们使用IP来定义主机。为了定义和标识进程，我们需要第二个标识符，称为端口号。在TCP/IP协议簇中，端口号是16位整数（0～65535）。")]),v._v(" "),t("p",[v._v("客户端程序使用端口号定义自己，这属于临时端口号，因为它只在客户端程序运行期间短暂存在。临时端口号推荐大于1023。")]),v._v(" "),t("p",[v._v("服务器进程必须使用一个端口号定义自己。但这个端口号不能随意选择。TCP/IP使用全局端口号，又称"),t("strong",[v._v("熟知端口号（well-known port number）")]),v._v("。")]),v._v(" "),t("p",[v._v("在与终端通信时，IP和端口号起着不同的作用。IP地址用来确定唯一主机，端口号确定该主机上的唯一进程。")]),v._v(" "),t("p",[v._v("ICANN把端口号编码划分为三种范围：")]),v._v(" "),t("ol",[t("li",[v._v("熟知端口。0～1023，由ICANN分配和控制。")]),v._v(" "),t("li",[v._v("注册端口。1024～49151。ICANN不分配不控制，可在ICANN注册以防止重复。")]),v._v(" "),t("li",[v._v("动态端口。49152～65535。不受控制也不需要注册，任何进程都可以使用。")])]),v._v(" "),t("h3",{attrs:{id:"无连接的多路复用和多路分解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无连接的多路复用和多路分解"}},[v._v("#")]),v._v(" 无连接的多路复用和多路分解")]),v._v(" "),t("p",[v._v("UDP套接字由二元组构成（目的IP地址、目的端口号）。发送方为UDP报文写入目的端口号、源端口号后，交给网络层转发。接收方收到多个UDP报文时，通过提取首部的目的端口号，将数据交给对应的套接字进程。")]),v._v(" "),t("h3",{attrs:{id:"面向连接的多路复用和分解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向连接的多路复用和分解"}},[v._v("#")]),v._v(" 面向连接的多路复用和分解")]),v._v(" "),t("p",[v._v("TCP套接字由四元组构成（源IP地址、源端口号、目的IP地址、目的端口号）。当一个TCP报文到达，接收方通过全部4个字段来确认唯一套接字并交付数据。与UDP不同的点在于，如果两个TCP报文源IP或者源端口不同，TCP可能会将数据交给不同的套接字处理，因为TCP是面向连接的。")]),v._v(" "),t("h2",{attrs:{id:"无连接运输udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无连接运输udp"}},[v._v("#")]),v._v(" 无连接运输UDP")]),v._v(" "),t("p",[v._v("UDP仅仅对IP协议做了很小的扩展——差错校验和复用/分解。使用UDP发送报文前，发送方和接收方的运输层实体之间没有握手。因此UDP被称为是无连接的。")]),v._v(" "),t("h3",{attrs:{id:"udp报文结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp报文结构"}},[v._v("#")]),v._v(" UDP报文结构")]),v._v(" "),t("p",[v._v("UDP报文由首部和数据部分组成。UDP首部只有四个字段：源端口号、目的端口号、长度、校验和。")]),v._v(" "),t("h3",{attrs:{id:"udp校验和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp校验和"}},[v._v("#")]),v._v(" UDP校验和")]),v._v(" "),t("p",[v._v("发送方的UDP对报文段中的所有16比特序列的和进行反码计算，求和时高位溢出会被回卷到低位，计算的结果存入校验和字段。在接收方，将16比特序列再进行加法运算，如果没有差错，则结果应该是全1。UDP实现差错校验是基于端到端原则，该原则表述为因为某种功能必须基于端到端实现，与较高级别协议提供这些功能相比，在较低级别上设置的功能可能是荣誉或者几乎没有价值的。UDP能校验差错，但不能纠错。UDP只能丢弃出错的报文，或者交给应用程序自行处理。")]),v._v(" "),t("h2",{attrs:{id:"可靠数据传输机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可靠数据传输机制"}},[v._v("#")]),v._v(" 可靠数据传输机制")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("校验和")]),v._v(" "),t("p",[v._v("用于检测一个传输分组中的比特流错误")])]),v._v(" "),t("li",[t("p",[v._v("定时器")]),v._v(" "),t("p",[v._v("用于超时/重传一个分组。可能因为该分组（或其ACK）在信道中丢失了。接收方可能接收到同一个分组的冗余副本。")])]),v._v(" "),t("li",[t("p",[v._v("序号")]),v._v(" "),t("p",[v._v("用于数据流按顺序编号，接收分组的序号间隙可使接收方检测分组丢失。相同序号的分组可以让接收方检测到冗余副本。")])]),v._v(" "),t("li",[t("p",[v._v("确认")]),v._v(" "),t("p",[v._v("接收方告知发送方一个分组被正确接收。确认报文通常携带被确认分组的序号。确认可以是逐个，也可以是累积。")])]),v._v(" "),t("li",[t("p",[v._v("否定确认")]),v._v(" "),t("p",[v._v("接收方告知发送方某个分组未被正确接收。否定报文通常携带未被正确接收的分组序号。")])]),v._v(" "),t("li",[t("p",[v._v("滑动窗口、流水线")]),v._v(" "),t("p",[v._v("发送方被限制仅发送落在窗口内的分组。允许一次发送多个分组但未被确认，发送方的利用率在停等协议的基础上被增加。窗口长度可以根据吞吐量、网络拥塞情况来动态设置。")])])]),v._v(" "),t("h2",{attrs:{id:"面向连接的运输tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向连接的运输tcp"}},[v._v("#")]),v._v(" 面向连接的运输TCP")]),v._v(" "),t("h3",{attrs:{id:"tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接"}},[v._v("#")]),v._v(" TCP连接")]),v._v(" "),t("p",[v._v("TCP连接没有物理实体，属于逻辑线路。TCP协议只在端系统中允许，所以中间的网络设备（路由器、交换机）不会维持TCP连接状态。路由器对TCP对连接完全视而不见，它看到的只是数据报。TCP连接是点对点的，因此不具备多播功能。")]),v._v(" "),t("p",[v._v("客户端发送一个特殊的TCP报文段，服务器用另一个特殊的报文段相应，最后客户端用第三个特殊报文段相应。前两个报文段不包含应用层数据；第三个报文段可以承载应用层数据。由于连接过程发送了三个报文段，所以这种连接过程被称为"),t("strong",[v._v("三次握手（three-way handshake）")]),v._v("。")]),v._v(" "),t("p",[v._v("TCP连接建立后，两个远程进程就可以通信了。TCP将应用层的数据引导至"),t("strong",[v._v("发送缓冲区")]),v._v("（send buffer），发送缓冲区是三次握手期间创建的缓冲区之一。TCP会从缓冲区取数据发送到网络层。TCP从缓冲区读取的数据长度受限于"),t("strong",[v._v("最大报文段长度（Maximum Segment Size，MSS）")]),v._v("。MSS通常根据本地主机的最大链路层帧长度（即"),t("strong",[v._v("最大传输单元（Maximum Transmission Unit，MTU）")]),v._v("）来设置。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的值一般设置为1460（为TCP/IP首部预留40字节位置）。")]),v._v(" "),t("p",[v._v("TCP为每块数据追加一个TCP首部，从而形成多个"),t("strong",[v._v("TCP报文段")]),v._v("（TCP segment），这些报文段下发给网络层后，封装成IP数据报发送到网络中。TCP接收到一个报文段后，将其放入接收缓冲区，应用程序可以通过缓冲区读取数据。")]),v._v(" "),t("h3",{attrs:{id:"tcp报文结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp报文结构"}},[v._v("#")]),v._v(" TCP报文结构")]),v._v(" "),t("p",[v._v("TCP报文由首部和数据字段构成。首部包括：")]),v._v(" "),t("ul",[t("li",[v._v("源端口号。")]),v._v(" "),t("li",[v._v("目的端口号。")]),v._v(" "),t("li")])])}),[],!1,null,null,null);_.default=s.exports}}]);