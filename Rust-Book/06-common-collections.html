<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter 6 - Common Collections | KSLEO</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.35aebc44.css" as="style"><link rel="preload" href="/assets/js/app.6f46cf57.js" as="script"><link rel="preload" href="/assets/js/2.49ce1412.js" as="script"><link rel="preload" href="/assets/js/11.e7ef91a0.js" as="script"><link rel="prefetch" href="/assets/js/10.86ad4e85.js"><link rel="prefetch" href="/assets/js/12.14d347b9.js"><link rel="prefetch" href="/assets/js/13.beaf8085.js"><link rel="prefetch" href="/assets/js/14.e42e08a4.js"><link rel="prefetch" href="/assets/js/15.41e8c95f.js"><link rel="prefetch" href="/assets/js/16.e8b84c5d.js"><link rel="prefetch" href="/assets/js/17.4d574f20.js"><link rel="prefetch" href="/assets/js/18.a8a8e164.js"><link rel="prefetch" href="/assets/js/19.118b3a66.js"><link rel="prefetch" href="/assets/js/20.ccdc0717.js"><link rel="prefetch" href="/assets/js/21.88ceead5.js"><link rel="prefetch" href="/assets/js/22.500d3be7.js"><link rel="prefetch" href="/assets/js/23.b7ca339b.js"><link rel="prefetch" href="/assets/js/24.0360313a.js"><link rel="prefetch" href="/assets/js/25.6083b636.js"><link rel="prefetch" href="/assets/js/26.1bd9d3eb.js"><link rel="prefetch" href="/assets/js/27.beb716dd.js"><link rel="prefetch" href="/assets/js/28.bb093ca6.js"><link rel="prefetch" href="/assets/js/29.5b527549.js"><link rel="prefetch" href="/assets/js/3.8a6c11df.js"><link rel="prefetch" href="/assets/js/30.796276de.js"><link rel="prefetch" href="/assets/js/31.666b101e.js"><link rel="prefetch" href="/assets/js/32.654129d9.js"><link rel="prefetch" href="/assets/js/33.e479db51.js"><link rel="prefetch" href="/assets/js/4.e2a8d64a.js"><link rel="prefetch" href="/assets/js/5.dd4c966a.js"><link rel="prefetch" href="/assets/js/6.00a6c78e.js"><link rel="prefetch" href="/assets/js/7.9330d48e.js"><link rel="prefetch" href="/assets/js/8.560dd961.js"><link rel="prefetch" href="/assets/js/9.da6c1180.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35aebc44.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">KSLEO</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chapter-6-common-collections"><a href="#chapter-6-common-collections" class="header-anchor">#</a> Chapter 6 - Common Collections</h1> <p>Rust标准库提供了很丰富的数据集合类。大多数数据结构通常只能存储一条数据，而集合可以存储多条数据。跟数组和元组不同，集合的数据存储在heap上，这意味着它存储的数据可以不用在编译阶段确定大小和内容，可以在运行时自由操作。这里介绍使用频率最高的三种集合类型：</p> <ul><li>Vector</li> <li>String</li> <li>HashMap</li></ul> <h2 id="section-1-vector"><a href="#section-1-vector" class="header-anchor">#</a> Section 1 - Vector</h2> <p>首先介绍集合<code>Vec&lt;T&gt;</code>，vector允许你在单个数据结构里存储多个值，这些值存储在内存中相邻的位置。Vector只能存储相同类型的数据，当你有一个类型列表时Vector非常适用。</p> <h3 id="creating-a-new-vector"><a href="#creating-a-new-vector" class="header-anchor">#</a> Creating a New Vector</h3> <p>通过<code>Vec::new</code>方法新建一个vector。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v<span class="token punctuation">:</span>Vec<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token operator">=</span> Vec<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Vector是基于泛型实现的，创建vector时如果没有初始化值，则需要指定类型。</p> <p>在一些应用场景中，Rust可以根据指定的初始化值推断vector的类型，所以一半很少通过类型变量指定类型。创建vector时进行初始化是比较常见的方式，Rust提供了<code>vec!</code>宏来初始化并创建vector。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由于我们使用<code>i32</code>类型的数据初始化vector，因此Rust可以推断出这个vector是<code>i32</code>类型的。</p> <h3 id="updating-a-vector"><a href="#updating-a-vector" class="header-anchor">#</a> Updating a Vector</h3> <p>使用<code>push</code>方法在vector实例上追加数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> Vec<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>vector类型的变量要更改时也需要使用<code>mut</code>关键字声明。由于push的数据都是<code>i32</code>类型的，因此Rust将此类型推断为vector的类型，因此可以不用指定其类型。</p> <h3 id="dropping-a-vector-drops-its-elements"><a href="#dropping-a-vector-drops-its-elements" class="header-anchor">#</a> Dropping a Vector Drops Its Elements</h3> <p>跟其他结构体一样，vector所在的上下文结束时，它将被释放（没有发生所有权转移）。当vector被释放时，它内部的数据也将被删除。这听起来似乎简单合理，但是当开始引用vector内的数据时，情况将变得复杂。</p> <h3 id="reading-elements-of-vectors"><a href="#reading-elements-of-vectors" class="header-anchor">#</a> Reading Elements of Vectors</h3> <p>有两种方式引用vector中存储的数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code> <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token operator">&amp;</span>i32 <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The third element is {}&quot;</span><span class="token punctuation">,</span> third<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">match</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Some</span><span class="token punctuation">(</span>third<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The third element is {}&quot;</span><span class="token punctuation">,</span> third<span class="token punctuation">)</span><span class="token punctuation">,</span>
    None <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;There is no third element.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>第一种方式通过<code>&amp;[]</code>返回一个引用，然后使用下标访问vector中的数据，下标从0开始，与数组类似。第二种方式通过vector实例上的<code>get</code>方法，它返回一个<code>Option&lt;&amp;T&gt;</code>。</p> <p>由于有两种访问方式，所以当发生越界访问时，需要针对不同的访问方式做不同的处理。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> num <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第一种访问方式会导致程序报错，当你希望发生越界时程序终止运行，可以使用这种方式。</p> <p>当使用<code>get</code>方法时，如果发生越界访问，它会返回<code>None</code>，后续应当有处理<code>Some(&amp;i32)</code>和<code>None</code>的逻辑。这种方式相比程序终止，有更好的用户体验。</p> <p>当创建了一个有效引用，borrow checker会强制执行所有权和<a href="/Rust/2-ownership.html#the-rules-of-references">引用规则</a>检查来确保当前引用和其他指向vector内容的引用也是有效的。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The first element is: {}&quot;</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个代码在编译阶段会报错，因为在同一个上下文环境中，对同一个数据存在immutable引用时，不能有mubable类型的引用。这段代码看上去应该是可以运行的，为什么对vector头部的引用和vector尾部的push操作会发生冲突呢？因为追加数据时有可能存在当前内存不足，在heap上重新分配内存，而此时旧的引用还指向之前被释放的内存，此时不符合引用规则中所有引用都必须有效的那一条，因此编译器会直接报错。</p> <h3 id="iterating-over-the-values-in-a-vector"><a href="#iterating-over-the-values-in-a-vector" class="header-anchor">#</a> Iterating over the Values in a Vector</h3> <p>使用<code>for</code>循环遍历vector，获取内部每一条数据的一个immutable引用。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token operator">&amp;</span>i <span class="token keyword">in</span> <span class="token operator">&amp;</span>v <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>也可以通过遍历mutable引用来修改vector中的数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token operator">&amp;</span>i <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v <span class="token punctuation">{</span>
    i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="using-an-enum-to-store-multiple-types"><a href="#using-an-enum-to-store-multiple-types" class="header-anchor">#</a> Using an Enum to Store Multiple Types</h3> <p>之前说过vector只能存储相同类型的数据，这个限制很不方便，因为有很多的场景需要存储不同类型的数据列表。我们可以通过定义枚举来满足这种场景需求。</p> <p>比如我们需要读取一个电子表格的一行数据，其类型可能是数字、字符串等。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> SpreadsheetCell <span class="token punctuation">{</span>
    <span class="token function">Int</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Float</span><span class="token punctuation">(</span>f64<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Text</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> row <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span>
    SpreadsheetCell<span class="token punctuation">::</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    SpreadsheetCell<span class="token punctuation">::</span><span class="token function">Text</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    SpreadsheetCell<span class="token punctuation">::</span><span class="token function">Float</span><span class="token punctuation">(</span><span class="token number">10.12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Rust在编译阶段需要知道vector存储何种数据类型，方便在heap上分配每个元素所需要的内存大小。第二个好处是可以明确指定这个vector存储的是何种类型。</p> <p>在编写过程中，如果你不能确定枚举下的所有类型，这种方式则不适用。此时可以用trait对象作为替代，后面的章节中会介绍到trait对象。</p> <h2 id="section-2-string"><a href="#section-2-string" class="header-anchor">#</a> Section 2 - String</h2> <p>许多Rust新手对String会在理解上有一些吃力，基于一下三个可能的原因：</p> <ul><li>Rust倾向于抛出任何可能的错误。</li> <li>String是一个比许多程序员所理解的更加复杂的数据类型。</li> <li>UTF8。</li></ul> <p>将String放在集合这一章讨论，是由于String类型是基于字节的集合实现的，并且添加了一些实用功能，这些字节在String类型中会被解析为文本。下面会讨论String类型和其他集合类型的相同之处，如creating，updating，reading等操作。还将讨论String和其他集合类型的不同之处——Stirng类型上操作的复杂化，由于人和机器对文本的解释方式不同。</p> <h3 id="what-is-a-string"><a href="#what-is-a-string" class="header-anchor">#</a> What Is a String?</h3> <p>首先定义一下<em>string</em>的含义。Rust语言核心中只有一种字符串类型，即字符串切片<code>str</code>。之前介绍过字符串切片，是对一些utf8编码数据的引用。保存在可执行文件中的字符串字面量也是<code>str</code>。</p> <p>而<code>String</code>类型，是由Rust标准库提供而非写在Rust语言核心中，是一种可扩展、可修改、utf8编码的字符串类型。当在Rust中提到字符串类型时，一般指的是这两种类型而非其中一种。</p> <h3 id="creating-a-new-string"><a href="#creating-a-new-string" class="header-anchor">#</a> Creating a New String</h3> <p><code>String</code>类型上的方法大多数都是和<code>Vec&lt;T&gt;</code>类型相似的。比如新建方法<code>new</code>。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里新建了一个空的字符串<code>s</code>，之后可以在它上面存储文本数据。但是通常在新建字符串时都会有初始化的值。可以使用<code>to_string</code>方法将字面量或者<code>str</code>数据转换成<code>String</code>类型。也可以使用<code>String::from</code>方法来创建，跟<code>to_string</code>方法效果是一样的。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token string">&quot;initial data&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> s <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;initial data&quot;</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;initial data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>String</code>类型是utf8编码的，因此它可以存储任何utf8编码范围内的文本数据，以下都是有效的字符串数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;السلام عليكم&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Dobrý den&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;שָׁלוֹם&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;नमस्ते&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;こんにちは&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;안녕하세요&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Olá&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Здравствуйте&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hola&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="updating-a-string"><a href="#updating-a-string" class="header-anchor">#</a> Updating a String</h3> <p><code>String</code>类型大小、内容都可以改变，可以像<code>Vec&lt;T&gt;</code>一样用push的方式追加数据。此外，也可以通过<code>+</code>运算符或者<code>format!</code>宏来进行字符串拼接。</p> <h4 id="appending-to-a-string-with-push-str-and-push"><a href="#appending-to-a-string-with-push-str-and-push" class="header-anchor">#</a> Appending to a String with <code>push_str</code> and <code>push</code></h4> <p><code>push_str</code>方法追加一个字符串切片。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>push</code>方法追加单个字符。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="concatenation-with-the-operator-or-the-format-macro"><a href="#concatenation-with-the-operator-or-the-format-macro" class="header-anchor">#</a> Concatenation with the + Operator or the format! Macro</h4> <p><code>+</code>运算符拼接字符串</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s3 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">;</span> <span class="token comment">// 这里s1的所有权发生了转移</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>加运算执行完毕后<code>s1</code>不再有效的原因，和为什么要使用<code>s2</code>的引用进行加运算的原因，在于执行<code>+</code>运算时所调用的方法。该方法的声明类似于：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>标准库中的<code>add</code>方法是通过泛型声明的。这里我们使用<code>String</code>类型作为说明。</p> <p>首先<code>s2</code>变量之前有<code>&amp;</code>修饰符，说明这里是一个<code>s2</code>的引用。由于<code>add</code>方法的声明，只能将一个第二个字符串的引用作为参数和第一个字符串做合并。也不能合并两个<code>String</code>类型的数据。但是，<code>&amp;s2</code>是一个<code>&amp;String</code>类型而非<code>&amp;str</code>类型，为什么编译器没有报错？</p> <p>因为编译器可以将<code>&amp;String</code>类型*coerce（强转换）*为<code>&amp;str</code>类型。调用<code>add</code>方法时，Rust进行了deref coercion（隐式强转换），在这个例子中，<code>&amp;s2</code>将返回<code>&amp;s2[..]</code>。由于<code>add</code>方法没有获取参数<code>s</code>的所有权，因此<code>s2</code>变量在计算之后依然是有效的。</p> <p>其次，<code>add</code>方法获取了<code>self</code>的所有权。这意味着<code>s1</code>变量在进行计算之后不再有效。<code>s3 = s1 + &amp;s2;</code>看起来是进行了值的复制和拼接，并且创建了新的变量。实际上是对<code>s1</code>进行内容追加后转移了的所有权。看似进行了许多复制和变量的新建，实际上要比这更有效率。</p> <p>而在多个字符串进行拼接时，<code>+</code>运算符看起来会比较啰嗦。此时使用<code>format!</code>宏代替是比较好的方案。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;tic&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;tac&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s3 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;toe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">format!</span><span class="token punctuation">(</span><span class="token string">&quot;{}-{}-{}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>format!</code>宏的方法比<code>+</code>运算符可读性更好，并且它不会获取任何参数的所有权。</p> <h3 id="indexing-into-strings"><a href="#indexing-into-strings" class="header-anchor">#</a> Indexing into Strings</h3> <p>在其他语言中，使用索引访问字符串中的某个字符是常见的操作。但是在Rust中会报错，Rust不支持数字索引，要解释这个问题，需要讨论Rust如何在内存中存储String数据。</p> <h4 id="internal-representation"><a href="#internal-representation" class="header-anchor">#</a> Internal Representation</h4> <p><code>String</code>类型是对<code>Vec&lt;u8&gt;</code>类型的一层封装。来看一些utf8编码的字符串示例</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hola&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个示例中，<code>s</code>的长度是4，意思是vector存储的“hola”有4字节长，每个字母占1字节。但是在其他字符数据的情况下呢？</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&quot;Здравствуйте&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 注意这是西里尔字母З，而不是阿拉伯数字3</span>
<span class="token keyword">let</span> answer <span class="token operator">=</span> <span class="token operator">&amp;</span>hello<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个例子中，<code>answer</code>会是<code>З</code>吗？在utf8编码中，3的第一个字节是<code>208</code>，第二个字节是<code>151</code>，所以<code>answer</code>的值是<code>208</code>，而<code>208</code>不是一个有效字符。这跟用户期望返回第一个字符不一致，但Rust在0索引处存储的值就是<code>208</code>的16进制。用户通常不希望获得字节类型的数据，哪怕字符串全部是由拉丁字母组成的。如果<code>&amp;&quot;hello&quot;[0]</code>是一个合法的索引，那么它也只会返回<code>104</code>而不是<code>h</code>。因此，Rust不允许使用索引访问字符串中的字符，在编译阶段就抛出错误，以免在开发阶段对代码的执行产生误解。</p> <h4 id="bytes-and-scalar-values-and-grapheme-clusters"><a href="#bytes-and-scalar-values-and-grapheme-clusters" class="header-anchor">#</a> Bytes and Scalar Values and Grapheme Clusters</h4> <p>从Rust的视角来看，有三种相关的方式查看String中的数据：<em>Bytes（可执行）</em>，<em>scalar values（标量）</em>，<em>grapheme clusters（词组）</em>（最接近人类字符的概念）。</p> <p>用梵文写的印地语&quot;नमस्ते&quot;，在<code>Vec&lt;u8&gt;</code>中存储的数据是</p> <blockquote><p><code>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</code>。</p></blockquote> <p>这18个16进制数据就是计算机最终存储的数据。如果从unicode标量的角度看，也是Rust中的<code>char</code>类型。这些字节串可以看作</p> <blockquote><p><code>['न', 'म', 'स', '्', 'त', 'े']</code></p></blockquote> <p>其中有6个char字符，其中第四个和第六个是变音符号，不具备表意功能。最后，如果从词组的角度看，就可以得到一个人类阅读友好的组成单词的四个字母。</p> <blockquote><p><code>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</code></p></blockquote> <p>Rust提供了多种方式来解释计算机存储的原始字符数据，满足不同程序的数据需求，而不用关心具体使用的是哪种人类语言。</p> <p>Rust不允许使用索引访问字符串数据的最后一个原因是，索引操作要求数据量不会影响读取的时间复杂度（O(1)）。但是这在String类型的性能上是不能够保证的，因为Rust需要从头遍历到索引位置处，找出其中有效的字符。</p> <h3 id="slicing-strings"><a href="#slicing-strings" class="header-anchor">#</a> Slicing Strings</h3> <p>索引访问String不是一个好的方案，原因还在于索引访问的返回值不清晰，是应该返回可执行数据，还是字符，还是词组，还是字符串切片呢？因此，Rust需要编码者在使用索引创建字符串切片时更加准确的定义返回值。为了更具体的索引，请使用<code>[]</code>和范围语法创建字符串切片，而不是在<code>[]</code>中使用单个数字。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&quot;Здравствуйте&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token operator">&amp;</span>hello<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里<code>s</code>是一个<code>&amp;str</code>，由于每个西里尔字符使用2字节编码，因此<code>s</code>的值应该是Зд。如果把<code>s</code>变量改成<code>&amp;hello[0..3]</code>，程序会在运行时崩溃——当前索引不在正确的字符边界处。在使用range创建字符串切片时需要小心，因为有可能会让程序崩溃。</p> <h3 id="methods-for-iterating-over-strings"><a href="#methods-for-iterating-over-strings" class="header-anchor">#</a> Methods for Iterating Over Strings</h3> <p>如果需要在每个单独的unicode字符标量上执行某些操作，可以通过String的<code>chars</code>方法来遍历每个字符标量，它返回的是<code>char</code>类型。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token string">&quot;नमस्ते&quot;</span><span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>bytes</code>方法返回原始的字节数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token string">&quot;नमस्ते&quot;</span><span class="token punctuation">.</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>请记住有效的unicode字符标量是有1个或以上的字节所组成的。</p> <p>由于返回词组的方法比较复杂，因此标准库并没有提供相关功能。有需要可以上<a href="https://crates.io/" target="_blank" rel="noopener noreferrer">crates.io<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p> <h3 id="strings-are-not-so-simple"><a href="#strings-are-not-so-simple" class="header-anchor">#</a> Strings Are Not So Simple</h3> <p>Rust将正确的处理字符串数据作为所有程序的默认行为，因此编码者需要在前期投入精力去思考如何正确的处理utf8数据。代价则是相比其他编程语言，Rust暴露了更多的复杂性给编码者，但同时能够让你避免类似于非ASCII字符的错误。</p> <h2 id="section-3-hashmap"><a href="#section-3-hashmap" class="header-anchor">#</a> Section 3 - HashMap</h2> <p>最后一个要介绍的常见集合是<em>hash map</em>。<code>HashMap&lt;K, V&gt;</code>类型存储的是<code>K</code>类型与<code>V</code>类型之间的键值对映射关系。通过<em>hashing function</em>来实现，这个函数确定了键和值如何在内存中存储。这个功能很多编程语言都提供了，只不过叫法有差异，比如哈希表、对象、map、字典等等。</p> <p>当你想通过非数字索引的方式查看数据时，哈希表是很实用的，它使用的是任意数据类型的键来检索数据。</p> <p>我们仅列举一些常用的API，在标准库<code>HashMap&lt;K, V&gt;</code>中定义了许多实用的方法，具体查阅标准库文档。</p> <h3 id="creating-a-new-hash-map"><a href="#creating-a-new-hash-map" class="header-anchor">#</a> Creating a New Hash Map</h3> <p>通过<code>new</code>方法新建，<code>insert</code>方法插入数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>colloctions<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Yellow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>首先需要引入<code>HashMap</code>模块。在介绍的三种集合中，HashMap是使用频率最低的，因此它没有被默认包含到上下文中。标准库对HashMap的支持也很少，比如没有宏来构建HashMap。</p> <p>跟vectors一样，哈希表的数据存储在heap上。上面的代码定义了一个键为<code>String</code>类型，值为<code>i32</code>类型的哈希表。哈市表跟vector一样是同质的，即键是同一种数据类型，值也是同一种数据类型。</p> <p>另外一种创建哈希表的方式是通过迭代器和元组组成的vector上的<code>collect</code>方法，其中每个元组包含哈希表的键和值。<code>collect</code>方法将数据收集到多种集合类型中，包括哈希表。<code>zip</code>方法可以用来创建元组组成的vector。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> teams <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Yellow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> initial_scores <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> scores<span class="token punctuation">:</span> HashMap<span class="token operator">&lt;</span>_<span class="token punctuation">,</span> _<span class="token operator">&gt;</span> <span class="token operator">=</span>
    teams<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>initial_scores<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>类型声明<code>HashMap&lt;_, _&gt;</code>是必须的，因为<code>collect</code>方法会把数据收集到许多种集合中，除非你指定，否则Rust不知道你需要的是哪一种。键和值的类型参数使用下划线占位，此时Rust可以通过返回值来推断键和值的类型。</p> <h3 id="hash-maps-and-ownership"><a href="#hash-maps-and-ownership" class="header-anchor">#</a> Hash Maps and Ownership</h3> <p>对于实现了<code>Copy</code>trait的类型来说，比如<code>i32</code>，值是拷贝进哈希表的。对于owned的数据类型来说，比如<code>String</code>，所有权会被转移到哈希表上。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> field_name <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Favorite color&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> field_value <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> map <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>field_name<span class="token punctuation">,</span> field_value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// error[E0382]: borrow of moved value: `field_name`</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在这个例子中，当<code>field_name</code>和<code>field_value</code>被添加到map之后，我们是不能使用这个值的，因为所有权被传递到了map中。</p> <p>如果我们使用引用插入到哈希表中，那么所有权将不会被移动到哈希表中。但是，此时需要保证引用的有效时间至少要和哈希表一致。</p> <h3 id="accessing-values-in-a-hash-map"><a href="#accessing-values-in-a-hash-map" class="header-anchor">#</a> Accessing Values in a Hash Map</h3> <p><code>get</code>方法获取哈希表的值。<code>get</code>方法返回<code>Option&lt;&amp;V&gt;</code>。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collection<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Yellow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> team_name <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> score <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>team_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>使用<code>for</code>循环遍历键值对</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Yellow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>scores <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}: {}&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="updating-a-hash-map"><a href="#updating-a-hash-map" class="header-anchor">#</a> Updating a Hash Map</h3> <p>键值对的数量是可以增加的，但是每个键只能关联到一个值。当你需要修改哈希表的值时，需要考虑到值已经关联了值的情况，覆盖、舍弃还是合并。</p> <h4 id="overwriting-a-value"><a href="#overwriting-a-value" class="header-anchor">#</a> Overwriting a Value</h4> <p>如果在插入值之后，重新对同一个键进行了插值，那么新值会将旧值覆盖。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> scores<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 25</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="only-inserting-a-value-if-the-key-has-no-value"><a href="#only-inserting-a-value-if-the-key-has-no-value" class="header-anchor">#</a> Only Inserting a Value If the Key Has No Value</h4> <p>检查键是否关联了值，如果没有就给他它关联一个新值，这是很常见的逻辑。哈希表对这种情况提供了一个特殊的API<code>entry</code>，它的参数是你需要检查的键，返回一个<code>Entry</code>枚举，代表一个值是否存在。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

scores<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Yellow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scores<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> scores<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// {&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>or_insert</code>方法当键存在时，返回一个该键值的可变引用。如果不存在，则把参数当作值插入到哈希表中然后返回一个可变引用。</p> <h4 id="updating-a-value-based-on-the-old-value"><a href="#updating-a-value-based-on-the-old-value" class="header-anchor">#</a> Updating a Value Based on the Old Value</h4> <p>另一种常见场景是使用旧值更新哈希表的新值。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span>HashMap<span class="token punctuation">;</span>

<span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">&quot;hello world wonderful world&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> map <span class="token operator">=</span> HashMap<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> word <span class="token keyword">in</span> text<span class="token punctuation">.</span><span class="token function">split_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// {&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="hashing-functions"><a href="#hashing-functions" class="header-anchor">#</a> Hashing Functions</h3> <p><code>HashMap</code>默认使用*<a href="https://www.131002.net/siphash/siphash.pdf" target="_blank" rel="noopener noreferrer">cryptographically strong<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><em>散列函数。它对DoS攻击有很好对抵抗性。这个算法不是最快的，但是从安全性的角度考虑，舍弃这点性能是值得的。如果你想自己指定散列函数，你可以指定一个</em>hasher*来自己切换散列函数。hasher是一个实现了<code>BuildHasher</code>trait的类型。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f46cf57.js" defer></script><script src="/assets/js/2.49ce1412.js" defer></script><script src="/assets/js/11.e7ef91a0.js" defer></script>
  </body>
</html>
