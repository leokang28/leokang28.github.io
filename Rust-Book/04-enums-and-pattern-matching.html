<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter 4 - Enums and Pattern Matching | KSLEO</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.35aebc44.css" as="style"><link rel="preload" href="/assets/js/app.6f46cf57.js" as="script"><link rel="preload" href="/assets/js/2.49ce1412.js" as="script"><link rel="preload" href="/assets/js/9.da6c1180.js" as="script"><link rel="prefetch" href="/assets/js/10.86ad4e85.js"><link rel="prefetch" href="/assets/js/11.e7ef91a0.js"><link rel="prefetch" href="/assets/js/12.14d347b9.js"><link rel="prefetch" href="/assets/js/13.beaf8085.js"><link rel="prefetch" href="/assets/js/14.e42e08a4.js"><link rel="prefetch" href="/assets/js/15.41e8c95f.js"><link rel="prefetch" href="/assets/js/16.e8b84c5d.js"><link rel="prefetch" href="/assets/js/17.4d574f20.js"><link rel="prefetch" href="/assets/js/18.a8a8e164.js"><link rel="prefetch" href="/assets/js/19.118b3a66.js"><link rel="prefetch" href="/assets/js/20.ccdc0717.js"><link rel="prefetch" href="/assets/js/21.88ceead5.js"><link rel="prefetch" href="/assets/js/22.500d3be7.js"><link rel="prefetch" href="/assets/js/23.b7ca339b.js"><link rel="prefetch" href="/assets/js/24.0360313a.js"><link rel="prefetch" href="/assets/js/25.6083b636.js"><link rel="prefetch" href="/assets/js/26.1bd9d3eb.js"><link rel="prefetch" href="/assets/js/27.beb716dd.js"><link rel="prefetch" href="/assets/js/28.bb093ca6.js"><link rel="prefetch" href="/assets/js/29.5b527549.js"><link rel="prefetch" href="/assets/js/3.8a6c11df.js"><link rel="prefetch" href="/assets/js/30.796276de.js"><link rel="prefetch" href="/assets/js/31.666b101e.js"><link rel="prefetch" href="/assets/js/32.654129d9.js"><link rel="prefetch" href="/assets/js/33.e479db51.js"><link rel="prefetch" href="/assets/js/4.e2a8d64a.js"><link rel="prefetch" href="/assets/js/5.dd4c966a.js"><link rel="prefetch" href="/assets/js/6.00a6c78e.js"><link rel="prefetch" href="/assets/js/7.9330d48e.js"><link rel="prefetch" href="/assets/js/8.560dd961.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35aebc44.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">KSLEO</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chapter-4-enums-and-pattern-matching"><a href="#chapter-4-enums-and-pattern-matching" class="header-anchor">#</a> Chapter 4 - Enums and Pattern Matching</h1> <p><em>enumerations枚举</em>定义一个类型，用来穷举所有可能的数据。很多语言都有枚举类型，但它们的含义和用法有些差别。Rust更接近于函数式编程语言中的枚举类型，<em>algebraic data types</em>。</p> <h2 id="section-1-定义一个枚举"><a href="#section-1-定义一个枚举" class="header-anchor">#</a> Section 1 - 定义一个枚举</h2> <p>先考虑一个场景，在这个场景下枚举比结构体更适合，比如需要做一个IP地址相关的功能。目前IP地址有个两个版本在使用中，V4和V6。所有IP地址只可能是这两个版本其中之一，所以我们可以用枚举穷举所有可能性。</p> <p>IP地址这种确定性（只能在这两个版本中，总的集合确定）和互斥性（只能是其中之一）是枚举类型最好的使用场景。而且不管是哪个版本，归根结底它都是IP地址，它们属于同一类型，所以在编码过程中需要把它们当作同一个类型去操作。</p> <p>下面用代码说明，首先创建一个IP地址枚举类型。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> IpAddrKind <span class="token punctuation">{</span>
    V4<span class="token punctuation">,</span>
    V6<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="枚举值"><a href="#枚举值" class="header-anchor">#</a> 枚举值</h3> <p>实例化枚举值</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v4 <span class="token operator">=</span> IpAddrKind<span class="token punctuation">::</span>V4<span class="token punctuation">;</span>
<span class="token keyword">let</span> v6 <span class="token operator">=</span> IpAddrKind<span class="token punctuation">::</span>V6<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意这两个值都是在<code>IpAddrKind</code>命名空间下的。这表示V4和V6都是同一类型的值，这种方式是很有用的，在后续处理中可以把它们都当作<code>IpAddrKind</code>类型来处理。比如定义一个函数接受<code>IpAddrKind</code>类型的数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">route</span><span class="token punctuation">(</span>address<span class="token punctuation">:</span> IpAddrKind<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个函数可以这样调用：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token function">route</span><span class="token punctuation">(</span>IpAddrKind<span class="token punctuation">::</span>V4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">route</span><span class="token punctuation">(</span>IpAddrKind<span class="token punctuation">::</span>V6<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用枚举还有很多其他好处。比如，我们在存储IP地址时，不知道它是V4还是V6版本的，只知道是一个IP地址，也就是说我们只知道它的类型。我们使用之前的结构体来写一下代码。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> IpAddrKind <span class="token punctuation">{</span>
    V4<span class="token punctuation">,</span>
    V6<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> IpAddr <span class="token punctuation">{</span>
    <span class="token keyword">type</span><span class="token punctuation">:</span> IpAddrKind<span class="token punctuation">,</span>
    address<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> home <span class="token operator">=</span> IpAddr <span class="token punctuation">{</span>
    <span class="token keyword">type</span><span class="token punctuation">:</span> IpAddrKind<span class="token punctuation">::</span>V4<span class="token punctuation">,</span>
    address<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> loopback <span class="token operator">=</span> IpAddr <span class="token punctuation">{</span>
    <span class="token keyword">type</span><span class="token punctuation">:</span> IpAddrKind<span class="token punctuation">::</span>V6<span class="token punctuation">,</span>
    address<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;::1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这里定义了一个<code>IpAddr</code>类型来存储IP地址数据，它有两个字段：<code>type</code>是<code>IpAddrKind</code>类型的IP地址版本，<code>address</code>是<code>String</code>类型的IP地址数据。</p> <p>有一种更简洁的方式，仅用枚举类型来表示，而不需要结构体嵌套枚举类型。这种方式是将数据直接存入枚举变体的实例中。<code>IpAddrKind</code>枚举的定义也需要更改一下。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> IpAddrKind <span class="token punctuation">{</span>
    <span class="token function">V4</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">V6</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> home <span class="token operator">=</span> IpAddrKind<span class="token punctuation">::</span><span class="token function">V4</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> loopback <span class="token operator">=</span> IpAddrKind<span class="token punctuation">::</span><span class="token function">V6</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;::1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>此外还有一种方式。枚举类型变体可以拥有不同的类型和数据量，因此我们可以将<code>V4</code>类型定义成由4个整型数据组成的。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> IpAddrKind <span class="token punctuation">{</span>
    <span class="token function">V4</span><span class="token punctuation">(</span>u8<span class="token punctuation">,</span> u8<span class="token punctuation">,</span> u8<span class="token punctuation">,</span> u8<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> home <span class="token operator">=</span> IpAddrKind<span class="token punctuation">::</span><span class="token function">V4</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>IP地址的存取是一个非常常用的功能，因此标准库已经实现了相关定义，编码人员可以直接使用。可以看看标准库是如何实现IP地址数据的定义的。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Ipv4Addr <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> Ipv6Addr <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">enum</span> IpAddr <span class="token punctuation">{</span>
    <span class="token function">V4</span><span class="token punctuation">(</span>Ipv4Addr<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">V6</span><span class="token punctuation">(</span>Ipv6Addr<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>再来看另外一个例子，这个枚举类型下面有更多的字段和数据类型。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> Message <span class="token punctuation">{</span>
    Quit<span class="token punctuation">,</span>
    Move <span class="token punctuation">{</span>x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> y<span class="token punctuation">:</span> i32<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">Write</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">ChangeColor</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span>i32<span class="token punctuation">,</span>i32<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这些字段都有不同的数据类型：</p> <ul><li><code>Quit</code>没有数据与它关联。</li> <li><code>Move</code>包含了一个匿名结构。</li> <li><code>Write</code>包含了一个字符串。</li> <li><code>ChangeColor</code>包含了3个<code>i32</code>整数。</li></ul> <p>这种方式与定义4个不同的结构体相似，不同点在于，枚举将他们都涵盖在了同一个类型<code>Message</code>下。下面都结构体定义可以与枚举变体存储一样都数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> QuitMessage<span class="token punctuation">;</span> <span class="token comment">// unit struct</span>
<span class="token keyword">struct</span> MoveMessage <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token function">WriteMessage</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tuple struct</span>
<span class="token keyword">struct</span> <span class="token function">ChangeColorMessage</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tuple struct</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>枚举和结构体还有一个相似之处，都可以通过<code>impl</code>关键字对其进行方法扩展。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">impl</span> Message <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// method body would be defined here</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> m <span class="token operator">=</span> Message<span class="token punctuation">::</span><span class="token function">Write</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接下来再看另外一个标准库中很常用的枚举类：<code>Option</code>。</p> <h3 id="option枚举类及它对null的优势"><a href="#option枚举类及它对null的优势" class="header-anchor">#</a> <code>Option</code>枚举类及它对<code>Null</code>的优势</h3> <p>Option枚举类在很多地方都会用到，因为它编码了一个很常见的情景：对变量的空值判断。用类型系统涵盖这个概念，代表编译器帮我们做了空值检查，可以在编译阶段就抛出错误，避免运行时bug。并且Rust没有其他语言中<code>null</code>的功能。</p> <p>null值的问题在于，当你把null作为一个非null变量使用时，会抛出一个类型错误。因为变量的空和非空是很常见的场景，很容易导致bug。但是null却描述了一个很有用的概念：一个变量因为某些原因此时不可用或不存在。</p> <p>所以真正的问题不在于概念本身，而在于它的实现。因此Rust没有null值，取而代之是标准库实现的枚举类型用来描述值是否存在。这个枚举类型是<code>Option&lt;T&gt;</code>，它的定义如下</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> Option<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    Some<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    None<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>Option</code>是默认引入的，不需要手动引入命名空间，它的枚举变体也是默认引入的，调用时不需要加<code>Option::</code>前缀。<code>&lt;T&gt;</code>是一个泛型参数，它可以代表任何类型，表示<code>Some</code>可以存储任何类型的数据。下面是一些使用的例子</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> some_number <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> some_str <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token string">&quot;a string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> absent_num<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token operator">=</span> None<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当使用<code>None</code>时，需要指定泛型是哪种数据类型，因为编译器无法通过<code>None</code>去推断<code>Some</code>的正确类型。</p> <p>为何使用<code>Option&lt;T&gt;</code>要优于使用null值？简单来说，<code>Option&lt;T&gt;</code>和<code>T</code>不是同一类型，编译器不会让我们使用<code>Option&lt;T&gt;</code>类型的值，就算它是一个有效值。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> x<span class="token punctuation">:</span>i8 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token punctuation">:</span>Option<span class="token operator">&lt;</span>i8<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>

<span class="token comment">// error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果运行这段代码，编译器会直接抛错。编译器不知道如何将<code>i8</code>类型和<code>Option&lt;i8&gt;</code>类型的数据作加法计算。当变量是<code>i8</code>类型时，编译器可以保证此时一定是一个有效值，所以不需要担心值不存在。当使用<code>Option&lt;T&gt;</code>类型的变量时，我们需要考虑值不存在的情况，编译器需要确保我们对这种情况做了处理。</p> <p>也就是说，在使用之前，需要先将<code>Option&lt;T&gt;</code>转换成<code>T</code>类型。在这个过程中可以捕获最常见的值为空但被错误使用的错误情况。</p> <p>如果一个值可能为空，首先必须手动指定该值为<code>Option&lt;T&gt;</code>类型。然后在使用该值时，处理值为空的逻辑是必须的。所以任何非<code>Option&lt;T&gt;</code>类型的数据，都可以被认为是非null的。这是Rust刻意的设计，为了限制代码中null值泛滥，增强代码的安全性。<code>Option&lt;T&gt;</code>有很多的方法扩展，可以读一下它的<a href="https://doc.rust-lang.org/std/option/enum.Option.html" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。熟悉<code>Option&lt;T&gt;</code>的内部方法对学习Rust很有好处。</p> <p>通常为了使用<code>Option&lt;T&gt;</code>内部的<code>T</code>值，你的代码需要覆盖所有的枚举变体。某些代码仅在<code>Some&lt;T&gt;</code>运行，此时代码能够访问到内部的<code>T</code>数据。某些代码仅在<code>None</code>运行，作空值逻辑处理。<code>match</code>表达式是可以实现上述需求的一个控制流程。</p> <h2 id="section-2-match流程控制表达式"><a href="#section-2-match流程控制表达式" class="header-anchor">#</a> Section 2 - <code>match</code>流程控制表达式</h2> <p><code>match</code>可以通过许多的*patterns（匹配模型）*去对比，并在相应的匹配模型命中的情况下执行某些代码。匹配模型可以是字面量值、变量、通配符等等。<code>match</code>流程控制强大之处在于丰富的匹配模型，以及编译器可以确认所有的可能情况都被涵盖。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> Coin <span class="token punctuation">{</span>
    Penny<span class="token punctuation">,</span>
    Nickel<span class="token punctuation">,</span>
    Dime<span class="token punctuation">,</span>
    Quarter<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> Coin<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> i8 <span class="token punctuation">{</span>
    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>
        Coin<span class="token punctuation">::</span>Penny <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
        Coin<span class="token punctuation">::</span>Nickel <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>
        Coin<span class="token punctuation">::</span>Dime <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span>
        Coin<span class="token punctuation">::</span>Quarter <span class="token operator">=&gt;</span> <span class="token number">25</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>分析一下这段代码。<code>match</code>后紧跟一个表达式，在这里是变量<code>coin</code>。这里跟<code>if</code>有点类似，但是<code>if</code>后的表达式需要返回<code>bool</code>值，而<code>match</code>后可以返回任何类型的数据。</p> <p>接下来是<em>match arms</em>。每个arm由两个部分组成：一个匹配模型、一部分代码，两部分用<code>=&gt;</code>操作符分割。arm之间使用逗号分割。</p> <p>当<code>match</code>表达式执行时，首先将结果值和匹配模型对比，如果某个匹配模型被命中，则它后面的代码会被执行，否则进入下一个arm进行对比。</p> <p>每个arm要执行的代码是一个表达式，其返回值作为<code>match</code>表达式的返回值。如果需要执行多行代码，可以用花括号组成代码块。</p> <h3 id="匹配模型绑定的数据"><a href="#匹配模型绑定的数据" class="header-anchor">#</a> 匹配模型绑定的数据</h3> <p><code>match</code>表达式的匹配模型可以绑定一些数据，这也是提取枚举变体中数据的方式。修改一下代码</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">enum</span> UsState <span class="token punctuation">{</span>
    Alabama<span class="token punctuation">,</span>
    Alaska<span class="token punctuation">,</span>
    <span class="token comment">// --snip--</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> Coin <span class="token punctuation">{</span>
    Penny<span class="token punctuation">,</span>
    Nickel<span class="token punctuation">,</span>
    Dime<span class="token punctuation">,</span>
    <span class="token function">Quarter</span><span class="token punctuation">(</span>UsState<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> Coin<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u8 <span class="token punctuation">{</span>
    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>
        Coin<span class="token punctuation">::</span>Penny <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
        Coin<span class="token punctuation">::</span>Nickel <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>
        Coin<span class="token punctuation">::</span>Dime <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span>
        Coin<span class="token punctuation">::</span><span class="token function">Quarter</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;State quarter from {:?}!&quot;</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token number">25</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>上面的代码在<code>Coin::Quarter</code>匹配模型中绑定了一个变量<code>state</code>，当该匹配模型命中时，<code>state</code>变量会绑定<code>Quarter</code>枚举变体中存储的数据，并且在该匹配模型后面的代码中，我们可以通过<code>state</code>变量使用这个数据。</p> <p>假如调用<code>value_in_cents(Coin::Quarter(UsState::Alabama));</code>，变量<code>coin</code>的值为<code>Coin::Quarter(UsState::Alabama)</code>。在match表达式中，最后一个匹配模型会命中，此时<code>state</code>变量绑定的值将会是<code>UsState::Alabama</code>，然后可以在<code>println!</code>表达式中使用该匹配模型内部绑定的状态值。</p> <h3 id="matching-with-option"><a href="#matching-with-option" class="header-anchor">#</a> Matching with Option<T></T></h3> <p>实现一个函数接受一个<code>Option&lt;i32&gt;</code>作为参数，如果内部有值则+1，如果没有值则不做任何逻辑且返回<code>None</code>。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> x <span class="token punctuation">{</span>
        None <span class="token operator">=&gt;</span> None<span class="token punctuation">,</span>
        <span class="token function">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="matches要全面"><a href="#matches要全面" class="header-anchor">#</a> Matches要全面</h3> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> x <span class="token punctuation">{</span>
        <span class="token function">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// error[E0004]: non-exhaustive patterns: `None` not covered</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面的代码中，<code>None</code>的情况没有被覆盖到，因此有可能会出现bug。好在Rust在编译阶段就能指出这个地方有问题。在<code>match</code>表达式中必须涵盖任何一种可能的情况，以保证代码的安全和健壮。</p> <h3 id="占位符"><a href="#占位符" class="header-anchor">#</a> <code>_</code>占位符</h3> <p>当不想列举一些可能情况时，可以用占位符<code>_</code>来替代。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> some_u8_value <span class="token operator">=</span> <span class="token number">0u8</span><span class="token punctuation">;</span>
<span class="token keyword">match</span> some_u8_value <span class="token punctuation">{</span>
    <span class="token number">1</span> <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">3</span> <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">5</span> <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;five&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">7</span> <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;seven&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>_</code>占位符会匹配所有的情况，因此需要将它放在最后面，以免覆盖我们想要处理的情况。</p> <p>当只需要处理所有情况之中的一种时，<code>match</code>表达式就显得有些啰嗦了。所以在这种场景下，Rust为我们提供了<code>if let</code>。</p> <h2 id="section-3-if-let流程控制表达式"><a href="#section-3-if-let流程控制表达式" class="header-anchor">#</a> Section 3 - <code>if let</code>流程控制表达式</h2> <p><code>if let</code>表达式可以让我们只关注一种需要处理的情况而忽略其他所有的情况。比如之前的例子</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> some_u8_value <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">0u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">match</span> some_u8_value <span class="token punctuation">{</span>
    <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里只处理了值为3的情况，其余情况都被省略了，此时<code>if let</code>要比<code>match</code>在书写上更加简洁。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> some_u8_value <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以将<code>if let</code>理解为<code>match</code>的一种语法糖。还可以在后面加<code>else</code>分支，它的作用和<code>_</code>占位符是一样的效果。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f46cf57.js" defer></script><script src="/assets/js/2.49ce1412.js" defer></script><script src="/assets/js/9.da6c1180.js" defer></script>
  </body>
</html>
