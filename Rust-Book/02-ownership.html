<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter 2 - Ownership | KSLEO</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.35aebc44.css" as="style"><link rel="preload" href="/assets/js/app.6f46cf57.js" as="script"><link rel="preload" href="/assets/js/2.49ce1412.js" as="script"><link rel="preload" href="/assets/js/7.9330d48e.js" as="script"><link rel="prefetch" href="/assets/js/10.86ad4e85.js"><link rel="prefetch" href="/assets/js/11.e7ef91a0.js"><link rel="prefetch" href="/assets/js/12.14d347b9.js"><link rel="prefetch" href="/assets/js/13.beaf8085.js"><link rel="prefetch" href="/assets/js/14.e42e08a4.js"><link rel="prefetch" href="/assets/js/15.41e8c95f.js"><link rel="prefetch" href="/assets/js/16.e8b84c5d.js"><link rel="prefetch" href="/assets/js/17.4d574f20.js"><link rel="prefetch" href="/assets/js/18.a8a8e164.js"><link rel="prefetch" href="/assets/js/19.118b3a66.js"><link rel="prefetch" href="/assets/js/20.ccdc0717.js"><link rel="prefetch" href="/assets/js/21.88ceead5.js"><link rel="prefetch" href="/assets/js/22.500d3be7.js"><link rel="prefetch" href="/assets/js/23.b7ca339b.js"><link rel="prefetch" href="/assets/js/24.0360313a.js"><link rel="prefetch" href="/assets/js/25.6083b636.js"><link rel="prefetch" href="/assets/js/26.1bd9d3eb.js"><link rel="prefetch" href="/assets/js/27.beb716dd.js"><link rel="prefetch" href="/assets/js/28.bb093ca6.js"><link rel="prefetch" href="/assets/js/29.5b527549.js"><link rel="prefetch" href="/assets/js/3.8a6c11df.js"><link rel="prefetch" href="/assets/js/30.796276de.js"><link rel="prefetch" href="/assets/js/31.666b101e.js"><link rel="prefetch" href="/assets/js/32.654129d9.js"><link rel="prefetch" href="/assets/js/33.e479db51.js"><link rel="prefetch" href="/assets/js/4.e2a8d64a.js"><link rel="prefetch" href="/assets/js/5.dd4c966a.js"><link rel="prefetch" href="/assets/js/6.00a6c78e.js"><link rel="prefetch" href="/assets/js/8.560dd961.js"><link rel="prefetch" href="/assets/js/9.da6c1180.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35aebc44.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">KSLEO</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chapter-2-ownership"><a href="#chapter-2-ownership" class="header-anchor">#</a> Chapter 2 - Ownership</h1> <p>Ownership是Rust最重要的功能之一，它在没有<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener noreferrer">gc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的前提下保证了内存读写安全。</p> <h2 id="section-1-什么是ownership"><a href="#section-1-什么是ownership" class="header-anchor">#</a> Section 1 - 什么是Ownership</h2> <p><em>ownership</em>是Rust的核心功能，虽然这个概念很容易解释，但是对于其他语言而言是一个很陌生的概念。</p> <p>所有程序都有内存调度的方式，比如很常见的gc，不断的收集没有在使用的内存碎片。很多语言都需要明确的分配和释放内存，Rust则使用外的方式：通过ownership下的一组规则，在编译阶段对内存进行检查，对运行时的性能没有任何影响。</p> <details class="custom-block details"><summary>Stack和Heap</summary> <p>stack和heap都是在程序运行时可以使用的一部分内存，但是他们的结构不一样。栈是先进先出（FILO）的调度策略，数据入栈操作称<em>push</em>，出栈称为<em>pop</em>。</p> <p>所有在stack上存储的数据，其大小都必须是已知和固定的。数据大小在编译阶段无法确定，或者可能会在运行时扩容的数据，都必须存储heap。堆的组织性比较差，首先需要在堆内存中请求一块空间。内存调度器会找一块大小合适的空内存并把它打上标记，表示已被使用，然返回一个<em>指针（pointer）</em>。指针代表的是该内存区域的地址。这个过程称为<em>allocating</em>。由于指针是大小确定且固定的数据，因此针可以存储在stack上。</p> <p>stack存储比heap要快，因为不需要内存调度器分配内存，stack的指针始终在其顶部。相比之下，heap内存分配需要内存调度寻找大小和据匹配的内存，并且还需要为下一次分配做一些前置工作比如内存标记等。</p> <p>stack访问也比heap快，因为heap需要先根据存储在stack上的指针寻址。在多个指针跳转时，这些指针如果相隔太远，也会让访问更慢。</p> <p>在调用函数时，参数（可能是heap上数据的指针）和函数的内部变量会被存进stack。函数执行结束时这些数据会从stack中清除。</p> <p>保持对heap数据使用的监控，最小化这些heap上的数据内存大小，减少重复数据内容，清空没有使用的内存已确保不会内存溢出。这些都ownership解决的问题</p></details> <h3 id="ownership-rules"><a href="#ownership-rules" class="header-anchor">#</a> Ownership Rules</h3> <ul><li>Rust中每个值都有一个变量作为它的owner</li> <li>每个值只能有一个owner</li> <li>当owner超出作用域块，值将被删除</li></ul> <h3 id="variable-scope"><a href="#variable-scope" class="header-anchor">#</a> Variable scope</h3> <p>变量在定义的那一刻有效，直到定义该变量的作用域执行完毕。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token punctuation">{</span> <span class="token comment">// s is not valid here, it’s not yet declared</span>
  <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span> <span class="token comment">// s is valid from this point forward</span>
  <span class="token comment">// do stuff with s</span>
<span class="token punctuation">}</span> <span class="token comment">// this scope is now over, and s is no longer valid</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="string类型"><a href="#string类型" class="header-anchor">#</a> <code>String</code>类型</h3> <p>为了说明ownership的作用机制，需要一个比Chapter1中的基础数据类型稍微复杂一些的数据，之前介绍的数据全都是存储在stack上的，但是目前我们需要存储在heap上的数据，用来解释Rust如何决策释放heap内存的时机。</p> <p>这里用<code>String</code>类型举例，专注于它和ownership相关的部分，这些特性在其他复杂数据类型也适用，不论是标准库导出的还是你自己定义的。</p> <p>之前的代码块使用了字符串字面量，这种方式很便捷，但是在大部分场景下这种方式不太适用。一方面是因为字符串字面量是immutable的，其次是因为大部分情况下我们并不知道要存储的数据是什么，比如存储用户输入。因此Rust还有另外一种字符串类型，<code>String</code>。这种类型是分配在heap上的，因此能够任意修改和存储任意大小的数据。<code>String</code>类型可以通过标准库导出的<code>from</code>方法来创建</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>  <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这种string数据可以修改</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>  s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// push_str() appends a literal to a String</span>

  <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>为什么字面量不可以修改而String却可以？主要区别在于这两种类型的内存处理方式。</p> <h3 id="memory-and-allocation"><a href="#memory-and-allocation" class="header-anchor">#</a> Memory and Allocation</h3> <p>字符串字面量在编译截断是知道其内容的，因此它直接被hardcode到可执行文件中，因此它更快更有效率。这些特性也只有在数据不变时才有效。但是对于大小、数据在编译阶段都不确定，运行时会改变其内容的数据来说，无法在可执行文件中为这些数据插入blob内存。</p> <p><code>String</code>类型为了支持数据可变、内存可扩容，在编译阶段无法确定数据内容，在heap上分配了一定数量的内存出来。这意味着：</p> <ul><li>内存必须在运行时由内存调度器分配。</li> <li>需要一种在内存使用完毕时，将内存交还给内存调度器的方法。</li></ul> <p>第一点由编码人员控制：当执行<code>String::from</code>方法时，它会去请求所需要的内存大小。这在大多数语言里都差不多。</p> <p>第二点Rust与其他语言有些差异。在有gc机制的语言中，gc会持续检查内存，回收没有使用的内存碎片。但是在没有gc机制的语言中，内存回收就是编码人员的职责，此时我们需要显式调用释放内存，就像申请内存时调用<code>String::from</code>方法一样。内存管理一直都是一个难题，如果编码人员忘记回收内存，就会造成内存泄露；如果回收的太早，又会导致程序拿到一个悬空指针；如果对同一块内存释放了两次，同样也是个bug。编码人员必须保证一次申请匹配一次释放。</p> <p>Rust使用了一种不同的方式：当owner变量所在的作用域执行结束时，其内存会被自动回收。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s is valid from this point forward</span>

    <span class="token comment">// do stuff with s</span>
<span class="token punctuation">}</span>   <span class="token comment">// this scope is now over, and s is no longer valid</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当作用域结束时，Rust会调用一个特殊方法<code>drop</code>。</p> <div class="custom-block tip"><p class="custom-block-title">Node:</p> <p>在C++中，这种在生命周期结束时重新分配资源的模式被称作<em>Resource Acquisition Is Initialization (RAII)</em>。如果你对这种模式比较熟悉，Rust的<code>drop</code>方法同样也很容易理解。</p></div> <h4 id="ways-variables-and-data-interact-move"><a href="#ways-variables-and-data-interact-move" class="header-anchor">#</a> Ways Variables and Data Interact: Move</h4> <p>在Rust中多个变量对相同数据的交互方式有多种。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个例子很好理解，将5绑定到变量<code>x</code>上，创建一份变量<code>x</code>的值的拷贝并绑定在变量<code>y</code>上。整型数字是数据已知、大小确定的，在stack上会存储两份数据。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个例子在写法上和上面的例子看起来一致，但是在行为上有很大的差别。下图说明了<code>String</code>类型底层所做的逻辑。<code>String</code>类型由左侧三部分组成：一个指向heap的内存地址，表示长度的值，表示容量的值，这组数据存储在stack上。右侧是heap上存储数据的内存。
 <img src="https://gitee.com/ksleo/source/raw/master/trpl04-01.svg" width="350" height="auto" style="display:block;">
length是指数据具体使用的内存字节长度，capacity是<code>String</code>类型从内存调度器申请到的内存字节长度。</p> <p>当把<code>s1</code>赋值给<code>s2</code>时，<code>String</code>数据被复制了，也就是指针、长度和容量这个数据结构被复制了，而具体存储在heap上的数据并没有被复制。
<img src="https://gitee.com/ksleo/source/raw/master/trpl04-02.svg" width="350" height="auto" style="display:block;"></p> <p>如果<code>s2 = s1</code>这段代码执行heap复制，如果在heap上的数据量过大，这将会是一个很昂贵的操作，性能带来损耗并且双倍的内存占用。
<img src="https://gitee.com/ksleo/source/raw/master/trpl04-03.svg" width="350" height="auto" style="display:block;"></p> <p>之前提到变量所在作用域执行结束时，Rust会自动调用<code>drop</code>方法释放该段内存。但是在上面的例子中会出现问题：作用域结束时，<code>s1</code>和<code>s2</code>都执行释放操作，但是这两个指针指向的是同一个地址，这就会引起<em>多次释放同一内存</em>的问题。为了确保内存安全，Rust在这种情况下有其他一些细节：Rust不会去复制heap内存，而是认为<code>s1</code>已经是一个无效引用，在作用域执行结束时，Rust不会执行任何与<code>s1</code>相关的释放操作。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// error[E0382]: borrow of moved value: `s1`</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>执行以上代码，编译器会抛出错误。</p> <p>如果你熟悉深复制和浅复制的概念，之前<code>String</code>类型下复制指针、长度和容量数据结构的操作，就可以认为是浅复制。但是由于Rust同时又让第一个值<code>s1</code>失效了，因此在Rust中称为<em>move</em>而不是<em>shallow copy</em>。在刚才的例子中，可以认为<code>s1</code><em>move</em>到了<code>s2</code>。
<img src="https://gitee.com/ksleo/source/raw/master/trpl04-04.svg" width="350" height="auto" style="display:block;"></p> <h4 id="ways-variables-and-data-interact-clone"><a href="#ways-variables-and-data-interact-clone" class="header-anchor">#</a> Ways Variables and Data Interact: Clone</h4> <p>如果我们执行heap数据深复制，而不仅仅是stack浅复制，可以调用<code>clone</code>方法。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;s1 = {}, s2 = {}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="stack-only-data-copy"><a href="#stack-only-data-copy" class="header-anchor">#</a> Stack-Only Data: Copy</h4> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;x = {}, y = {}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这段代码执行不会有任何问题。但这与刚刚得到到结论出现了分歧：在没有调用clone得情况下，<code>x</code>仍然是有效的，看似没有发生<em>move</em>。</p> <p>原因在于整型变量是编译时大小固定的，存储在stack上，并且其值很容易复制。也就是说没有必要在<code>y</code>创建后，将<code>x</code>标记为失效。也就是说在这种情况下，浅复制和深复制没有任何区别，所以就算调用<code>clone</code>方法，也不会与浅复制在行为上有任何的不同。</p> <p>Rust有一个特殊的标记被称作<code>Copy</code> trait。一切在stack上存储的数据类型都可以理解为存在这个<code>Copy</code> trait。如果一个类型有<code>Copy</code> trait，旧的变量被分配给新的变量后仍然是有效的。Rust不允许我们给任何实现，或者其任何一部分实现了<code>Drop</code> trait的类型做<code>Copy</code> trait标记。</p> <p>任何基础数据类型的组合是<code>Copy</code>的，凡是不需要分配或属于某种形式的资源的，都是<code>Copy</code>。下面是一些<code>Copy</code>类型举例：</p> <ul><li>所有整型，例如<code>u32</code>。</li> <li>所有浮点，例如<code>f64</code>。</li> <li><code>bool</code>。</li> <li><code>char</code>。</li> <li>只包含<code>Copy</code>类型的tuples。比如<code>(u32, u64)</code>是<code>Copy</code>，<code>(u32, String)</code>不是。</li></ul> <h3 id="ownership-and-functions"><a href="#ownership-and-functions" class="header-anchor">#</a> Ownership and Functions</h3> <p>把值传递给函数参数和传递给变量，在语义上是相似的，比如都会执行<em>move</em>或者复制。用一个例子说明</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s comes into scope</span>
    
    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s's value moves into the function </span>
                                     <span class="token comment">// and so is no longer valid here</span>

    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                  <span class="token comment">// x comes into scope</span>

    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// x would move into the function,</span>
                                     <span class="token comment">// but i32 is Copy, so it’s okay to still</span>
                                     <span class="token comment">// use x afterward</span>

<span class="token punctuation">}</span> <span class="token comment">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span>
  <span class="token comment">// special happens.</span>

<span class="token keyword">fn</span> <span class="token function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_string comes into scope</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, some_string goes out of scope and `drop` is called. The backing</span>
  <span class="token comment">// memory is freed.</span>

<span class="token keyword">fn</span> <span class="token function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_integer comes into scope</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, some_integer goes out of scope. Nothing special happens.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="return-values-and-scope"><a href="#return-values-and-scope" class="header-anchor">#</a> Return Values and Scope</h3> <p>函数返回值也会使ownership发生转移。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership moves its return</span>
                                        <span class="token comment">// value into s1</span>

    <span class="token keyword">let</span> s2 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 comes into scope</span>

    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 is moved into</span>
                                        <span class="token comment">// takes_and_gives_back, which also</span>
                                        <span class="token comment">// moves its return value into s3</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was</span>
  <span class="token comment">// moved, so nothing happens. s1 goes out of scope and is dropped.</span>

<span class="token keyword">fn</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String <span class="token punctuation">{</span>             <span class="token comment">// gives_ownership will move its</span>
                                             <span class="token comment">// return value into the function</span>
                                             <span class="token comment">// that calls it</span>

    <span class="token keyword">let</span> some_string <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string comes into scope</span>

    some_string                              <span class="token comment">// some_string is returned and</span>
                                             <span class="token comment">// moves out to the calling</span>
                                             <span class="token comment">// function</span>
<span class="token punctuation">}</span>

<span class="token comment">// takes_and_gives_back will take a String and return one</span>
<span class="token keyword">fn</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String <span class="token punctuation">{</span> <span class="token comment">// a_string comes into</span>
                                                      <span class="token comment">// scope</span>

    a_string  <span class="token comment">// a_string is returned and moves out to the calling function</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>变量的ownership遵循同一套模式：赋值给其他变量，ownership就会转移。当一个变量的数据存储在heap上时，它所在的作用域在执行完毕后，该变量的heap空间就会被释放，除非它把ownership转移给其他变量。</p> <p>如果我们只想在函数中使用变量而不想转移其ownership呢？想一想除了要把函数主体逻辑的结果返回，还要要把传进函数的ownership再传出去，这也太操蛋了。我们可以通过<code>Tuple</code>实现这个需求。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> <span class="token punctuation">(</span>s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The length of '{}' is {}.&quot;</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> usize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// len() returns the length of a String</span>

    <span class="token punctuation">(</span>s<span class="token punctuation">,</span> length<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>对于一个常见的概念来说，不应该做这么多大量的额外工作。好在Rust已经实现了这个功能，称之为<em>references</em>。</p> <h2 id="section-2-references-and-borrowing"><a href="#section-2-references-and-borrowing" class="header-anchor">#</a> Section 2 - References and Borrowing</h2> <p>之前我们在<code>calculate_length</code>中返回了一个元组用于返回函数结果和ownership，以便我们在函数调用完成后可以继续使用<code>s1</code>变量。因为之前提过，传参和赋值在行为上差不多是一致的，<code>s1</code>变量传参进入<code>calculate_length</code>函数后，其ownership也被转移到了函数内部，<code>s1</code>此时是不可用的了。</p> <p>下面是一个通过传入一个变量的reference，来控制ownership不被传递到函数内部的例子。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The length of '{}' is {}.&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> usize <span class="token punctuation">{</span> <span class="token comment">// s is a reference to a String</span>
    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, s goes out of scope. But because it does not have ownership of what</span>
  <span class="token comment">// it refers to, nothing happens.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>首先Tuple被删除了，其次参数的定义和传递都加了一个<code>&amp;</code>符号，这个符号代表的就是<em>references</em>，引用可以只读变量的值而不转移其所有权。
<img src="https://gitee.com/ksleo/source/raw/master/trpl04-05.svg" width="500" height="auto" style="display:block;"></p> <div class="custom-block tip"><p class="custom-block-title">Note</p> <p>与<em>reference</em>相对的操作称为<em>dereference</em>，运算符是<code>*</code>。</p></div> <p><code>&amp;s1</code>这种语法创建了一个引用，指向被引用的值，但是不转移原变量的所有权。因为没有所有权，所以函数结束时，它指向的heap区域不会被释放。当函数参数以引用方式传递时，函数不再需要显式的返回所有权，因为所有权一开始就没有发生转移。</p> <p>引用作为函数参数称之为<em>borrowing</em>。如果我们尝试改变引用，编译器会报错。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>和变量的默认行为相同，引用也是immutable的。</p> <h3 id="mutable-reference"><a href="#mutable-reference" class="header-anchor">#</a> Mutable Reference</h3> <p>只需要进行一个改动，就可以获取一个mutable的引用。即在函数定义和调用的时候，在<code>&amp;</code>操作符后加上<code>mut</code>关键字。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可变引用有一个限制，同一个作用域下，对同一个数据只能有一个可变引用。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>
<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, {}&quot;</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// error[E0499]: cannot borrow `s` as mutable more than once at a time</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这样做的好处在于避免在编译阶段造成数据竞争。数据竞争和竞态条件相似，在以下三个行为发生时会引发竞态：</p> <ul><li>两个以上指针同时访问同一资源。</li> <li>至少一个指针正在被用于写操作。</li> <li>没有用于同步访问数据的机制。</li></ul> <p>数据竞争在运行时调试时很难找出问题并且解决它。Rust中不会发生这种情况，因为代码有可能引发竞态时，编译阶段就不会通过。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>
<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>
<span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// BIG PROBLEM</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, {}, and {}&quot;</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当存在immutable的引用时，不可以创建mutable的引用。可以存在多个immutable引用，因为仅仅读数据并不会造成脏读。</p> <p>引用的生命周期从定义它开始，到最后一次使用它结束，下面的代码编译是可以通过的，因为在mutable引用创建之前，immutable引用的生命周期就结束了。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>
<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>
<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, {}&quot;</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>

<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>尽管这类编译错误非常令人烦躁，但是在编译阶段明确指出问题所在总好过在运行时出错。</p> <h3 id="dangling-references"><a href="#dangling-references" class="header-anchor">#</a> Dangling References</h3> <p>悬空指针是指针指向的地址，被其他操作释放掉了。Rust编译器保证不会出现悬空指针：如果有一个指针指向一块内存区域，编译器会保证在这块内存区域的数据被使用前，该指针所在的作用域不会结束。</p> <p>下面是一个创建悬空指针的例子。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>String <span class="token punctuation">{</span>
    <span class="token keyword">let</span> str <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&amp;</span>str
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这段代码编译器会报错，其中有这样一条帮助信息：</p> <blockquote><p>this function's return type contains a borrowed value, but there is no value for it to be borrowed from</p></blockquote> <p>因为<code>s</code>是在<code>dangle</code>函数中创建的，当<code>dangle</code>函数执行结束，<code>s</code>指向的内存区域也被释放了，意味着我们返回了一个不合法的<code>String</code>引用，Rust编译器是不会允许此类情况发生的。</p> <p>解决方法是直接返回原变量，也就是转移所有权，这样在函数结束后相关内存就不会被释放，因为所有权被转移到了外部变量。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String <span class="token punctuation">{</span>
    <span class="token keyword">let</span> str <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    str
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="the-rules-of-references"><a href="#the-rules-of-references" class="header-anchor">#</a> The Rules of References</h3> <ul><li>任何情况下都只能有一个mutable引用或多个immutable引用。</li> <li>引用必须是有效的。</li></ul> <h2 id="section-3-the-slice-type"><a href="#section-3-the-slice-type" class="header-anchor">#</a> Section 3 - The Slice Type</h2> <p>另外一种没有所有权的数据类型是切片，切片引用一段集合上连续的元素。</p> <p>引入一个小例子：写一个函数，接受一个String作为参数，返回它里面的第一个词。如果String中没有匹配到空格，说明传入的是一个词，此时返回原参数。</p> <p>考虑一下这个函数的声明该怎么写</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">?</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个方法中我们不想要获取所有权，所以传入一个引用。但是它应该返回什么类型？第一种方案可以返回结果的最后一个字母的下标。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> usize <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">emumrate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这个方法的问题在于，它返回的下标仅在<code>&amp;String</code>上下文中有意义，如果该引用的值被修改了，则之前的运算值也不正确了。如果我们返回的是前后两个下标<code>fn second_word(s: &amp;String) -&gt; (usize, usize) {</code>，那么这种方式就更加脆弱，此时已经有三个不相关的变量需要保持数据同步了。</p> <h3 id="string-slices"><a href="#string-slices" class="header-anchor">#</a> String Slices</h3> <p>字符串切片是字符串其中一段内容的引用。字符串切片可以使用下面的方法创建</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">..</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>切片和引用是类似的，不过是用<code>[start_index..end_index]</code>这种方式截断了字符串的一部分，该区间是左闭右开的。切片内部实现存储的是首地址和切片长度。
<img src="https://gitee.com/ksleo/source/raw/master/trpl04-06.svg" width="500" height="auto" style="display:block;"></p> <p>Rust的<code>..</code>范围语法，如果定义的范围从0开始，那么0可以不写。所以，下面两种写法是一样的。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果范围是从头部到尾部，那么两边的数字都可以省略掉。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">注意</p> <p>字符串切片下标必须是在合法的utf8字符边界处，如果下标处于多字节字符之中，程序会抛出错误。</p></div> <p>有了这些相关概念，之前的<code>first_word</code>函数可以做一些修改。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>str <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">==</span> <span class="token char string">b' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>之前的函数，在调用之后清空原来的string，编译阶段不会出错，但是在运行时会引发bug。现在经过改造之后的方法，在编译阶段就会指出问题所在。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>

    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;the first word is: {}&quot;</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>回顾之前的规则，当存在immutable的引用时，不能同时存在mutable的引用。<code>clear</code>方法需要清空原字符串，所以它需要一个mutable的引用，Rust是不允许的并在编译阶段直接抛错。Rust编译器不光让自定义API更加易用，并且在编译阶段排除了许多潜在bug。</p> <h4 id="字符串字面量是切片类型"><a href="#字符串字面量是切片类型" class="header-anchor">#</a> 字符串字面量是切片类型</h4> <p>之前提到，字符串字面量直接存储在可执行文件中。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里变量<code>s</code>的类型是<code>&amp;str</code>，它是一个切片，指一个向可执行文件中字面量存储位置的指针。这就是为什么字符串字面量不可以修改了，因为<code>&amp;str</code>是一个immutable引用。</p> <h4 id="字符串切片作为函数参数"><a href="#字符串切片作为函数参数" class="header-anchor">#</a> 字符串切片作为函数参数</h4> <p>之前的<code>first_word</code>函数，有一个更好的定义方式是</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>str
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>此时我们可以传<code>&amp;String</code>类型或者<code>&amp;str</code>类型。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> my_string <span class="token operator">=</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// first_word works on slices of `String`s</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> my_string_literal <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// first_word works on slices of string literals</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Because string literals *are* string slices already,</span>
    <span class="token comment">// this works too, without the slice syntax!</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="其他切片类型"><a href="#其他切片类型" class="header-anchor">#</a> 其他切片类型</h3> <p>数组切片</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr_slice <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>arr_slice</code>是<code>&amp;[i32]</code>类型的，它跟<code>&amp;str</code>的表现没有任何区别：存储一个头指针和内容长度。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f46cf57.js" defer></script><script src="/assets/js/2.49ce1412.js" defer></script><script src="/assets/js/7.9330d48e.js" defer></script>
  </body>
</html>
