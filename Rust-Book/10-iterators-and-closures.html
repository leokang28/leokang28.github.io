<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter 10 - Functional Language Features: Iterators and Closures | KSLEO</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.35aebc44.css" as="style"><link rel="preload" href="/assets/js/app.6f46cf57.js" as="script"><link rel="preload" href="/assets/js/2.49ce1412.js" as="script"><link rel="preload" href="/assets/js/15.41e8c95f.js" as="script"><link rel="prefetch" href="/assets/js/10.86ad4e85.js"><link rel="prefetch" href="/assets/js/11.e7ef91a0.js"><link rel="prefetch" href="/assets/js/12.14d347b9.js"><link rel="prefetch" href="/assets/js/13.beaf8085.js"><link rel="prefetch" href="/assets/js/14.e42e08a4.js"><link rel="prefetch" href="/assets/js/16.e8b84c5d.js"><link rel="prefetch" href="/assets/js/17.4d574f20.js"><link rel="prefetch" href="/assets/js/18.a8a8e164.js"><link rel="prefetch" href="/assets/js/19.118b3a66.js"><link rel="prefetch" href="/assets/js/20.ccdc0717.js"><link rel="prefetch" href="/assets/js/21.88ceead5.js"><link rel="prefetch" href="/assets/js/22.500d3be7.js"><link rel="prefetch" href="/assets/js/23.b7ca339b.js"><link rel="prefetch" href="/assets/js/24.0360313a.js"><link rel="prefetch" href="/assets/js/25.6083b636.js"><link rel="prefetch" href="/assets/js/26.1bd9d3eb.js"><link rel="prefetch" href="/assets/js/27.beb716dd.js"><link rel="prefetch" href="/assets/js/28.bb093ca6.js"><link rel="prefetch" href="/assets/js/29.5b527549.js"><link rel="prefetch" href="/assets/js/3.8a6c11df.js"><link rel="prefetch" href="/assets/js/30.796276de.js"><link rel="prefetch" href="/assets/js/31.666b101e.js"><link rel="prefetch" href="/assets/js/32.654129d9.js"><link rel="prefetch" href="/assets/js/33.e479db51.js"><link rel="prefetch" href="/assets/js/4.e2a8d64a.js"><link rel="prefetch" href="/assets/js/5.dd4c966a.js"><link rel="prefetch" href="/assets/js/6.00a6c78e.js"><link rel="prefetch" href="/assets/js/7.9330d48e.js"><link rel="prefetch" href="/assets/js/8.560dd961.js"><link rel="prefetch" href="/assets/js/9.da6c1180.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35aebc44.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">KSLEO</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chapter-10-functional-language-features-iterators-and-closures"><a href="#chapter-10-functional-language-features-iterators-and-closures" class="header-anchor">#</a> Chapter 10 - Functional Language Features: Iterators and Closures</h1> <p>Rust的灵感来自于现有的许多语言和技术，其中一个最重要的概念就是<em>函数式编程（functional programming）</em>。函数式编程包括，把函数当作参数传递给其他函数；从函数中返回一个函数；把函数赋值给变量延迟调用。</p> <p>下面会介绍一些跟其他函数式语言类似的概念：</p> <ul><li>闭包，结构类似于函数，可以存储在变量中。</li> <li>迭代器，处理一系列数据的一种方式。</li> <li>这两者的性能。</li></ul> <h2 id="section-1-closures-anonymous-functions-that-can-capture-their-environment"><a href="#section-1-closures-anonymous-functions-that-can-capture-their-environment" class="header-anchor">#</a> Section 1 - Closures: Anonymous Functions that Can Capture Their Environment</h2> <p>Rust的闭包是一个匿名函数，你可以把它存进变量或者当作参数传给其他函数。闭包的定义和调用可以在不同时间点，不同上下文中。跟函数不同的是，闭包可以捕获他们定义所在上下文中的变量。</p> <p>例如有这样一个场景：要开发一个app来为用户生成自定义的训练计划。后台使用Rust，生成算法考虑了很多因素，例如用户年龄，体重，运动经历，当前训练计划和用户自定义的强度指数等。假设这个算法需要运行几秒钟，我们只想在初始化的时候调用算法一次，免得让用户不必要的等待结果。</p> <p>假设用函数<code>simulated_expensive_calculation</code>模拟算法调用：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>thread<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">::</span>time<span class="token punctuation">::</span>Duration<span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">simulated_expensive_calculation</span><span class="token punctuation">(</span>intensity<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;执行算法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intensity
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接下来是<code>main</code>函数，包含了用户在调用训练计划时要执行的代码。*闭包（closure）*的使用和前端交互没啥关系，因此这里硬编码参数。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> simulated_user_specified_value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> simulated_random_number <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>

    <span class="token function">generate_workout</span><span class="token punctuation">(</span>simulated_user_specified_value<span class="token punctuation">,</span> simulated_random_number<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接下来模拟一下生成训练计划的算法函数<code>generate_workout</code>。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">generate_workout</span><span class="token punctuation">(</span>intensity<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> random_number<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> intensity <span class="token operator">&lt;</span> <span class="token number">25</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span>
            <span class="token string">&quot;Today, do {} pushups!&quot;</span><span class="token punctuation">,</span>
            <span class="token function">simulated_expensive_calculation</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span>
            <span class="token string">&quot;Next, do {} situps!&quot;</span><span class="token punctuation">,</span>
            <span class="token function">simulated_expensive_calculation</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> random_number <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Take a break today! Remember to stay hydrated!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span>
                <span class="token string">&quot;Today, run for {} minutes!&quot;</span><span class="token punctuation">,</span>
                <span class="token function">simulated_expensive_calculation</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这个代码已经实现了业务方的需求。假设大数据团队想要我们在以后修改<code>simulated_expensive_calculation</code>的调用方式。为了简化升级流程，需要重构代码，让<code>simulated_expensive_calculation</code>只执行一次。并且多次调用的地方也需要删除掉。</p> <h3 id="refactoring-using-functions"><a href="#refactoring-using-functions" class="header-anchor">#</a> Refactoring Using Functions</h3> <p>首先，可以将<code>simulated_expensive_calculation</code>函数的执行结果存储在变量中，需要的时候直接使用。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">generate_workout</span><span class="token punctuation">(</span>intensity<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> random_number<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> expensive_result <span class="token operator">=</span> <span class="token function">simulated_expensive_calculation</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> intensity <span class="token operator">&lt;</span> <span class="token number">25</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Today, do {} pushups!&quot;</span><span class="token punctuation">,</span> expensive_result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Next, do {} situps!&quot;</span><span class="token punctuation">,</span> expensive_result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> random_number <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Take a break today! Remember to stay hydrated!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Today, run for {} minutes!&quot;</span><span class="token punctuation">,</span> expensive_result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这个解决方式统一了<code>simulated_expensive_calculation</code>函数的调用，并且解决了<code>if</code>代码块中函数不必要的多次调用。但是，这种解决方案需要所有条件下的情况等待算法执行结果，哪怕最终我们不需要这个结果。</p> <p>所以，我们想让代码只在需要结果的时候被调用一次。这个场景就很适用于<em>闭包（closure）</em>。</p> <h3 id="refactoring-with-closures-to-store-code"><a href="#refactoring-with-closures-to-store-code" class="header-anchor">#</a> Refactoring with Closures to Store Code</h3> <p>定义和储存闭包：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> expensive_closure <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>num<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;calculating slowly...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    num
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>闭包定义被赋值给变量<code>expensive_closure</code>。闭包定义又两个竖线<code>|</code>开头，竖线中间是传给闭包的参数。选择这种语法是因为它跟Smalltalk和Ruby相似。这个闭包有一个参数<code>num</code>，如果需要传多个参数，可以<code>|p1, p2, ...|</code>。</p> <p>然后用花括号包住闭包体，可以看到就是函数中的内容。</p> <p>现在<code>let</code>语句意味着<code>expensive_closure</code>变量包含一个匿名函数的定义，而不是函数的运行结果。也就是说需要在后面执行的代码存储在这个变量中。</p> <p>接下来修改<code>generate_workout</code>函数中算法调用的部分。闭包调用和函数调用一样。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">generate_workout</span><span class="token punctuation">(</span>intensity<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> random_number<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> expensive_closure <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>num<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;calculating slowly...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        num
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> intensity <span class="token operator">&lt;</span> <span class="token number">25</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Today, do {} pushups!&quot;</span><span class="token punctuation">,</span> <span class="token function">expensive_closure</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Next, do {} situps!&quot;</span><span class="token punctuation">,</span> <span class="token function">expensive_closure</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> random_number <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Take a break today! Remember to stay hydrated!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span>
                <span class="token string">&quot;Today, run for {} minutes!&quot;</span><span class="token punctuation">,</span>
                <span class="token function">expensive_closure</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>现在，又引入了多次调用的问题。昂贵的计算操作会被调用多次，用户等待的时长更久。我们可以在内部的<code>if</code>块中创建一个变量存储计算结果。但是闭包提供了更好的解决方案。稍后会介绍该方案。目前先套路一下为什么闭包定义没有类型声明，也没有相关的trait。</p> <h3 id="closure-type-inference-and-annotation"><a href="#closure-type-inference-and-annotation" class="header-anchor">#</a> Closure Type Inference and Annotation</h3> <p>闭包不会像函数一样要求你声明参数和返回值的类型。函数要求声明类型是因为它是显式接口的一部分。严格地定义接口能够保证所有的调用者都按照你的预期来传递参数和处理返回值。但是闭包不是用于对外接口的，它是给库内部用的。</p> <p>我们也可以为闭包声明类型。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> expensive_closure <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>num<span class="token punctuation">:</span> u32<span class="token punctuation">|</span></span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;calculating slowly...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    num
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>增加了类型声明之后，闭包定义更接近函数定义了。下面是函数声明语法和闭包的一个垂直对比。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span>  <span class="token function">add_one_v1</span>   <span class="token punctuation">(</span>x<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> add_one_v2 <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>x<span class="token punctuation">:</span> u32<span class="token punctuation">|</span></span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> add_one_v3 <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>x<span class="token punctuation">|</span></span>             <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> add_one_v4 <span class="token operator">=</span> <span class="token operator">|</span>x<span class="token operator">|</span>               x <span class="token operator">+</span> <span class="token number">1</span>  <span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>第二行是完整声明定义，跟函数一样。第三行去掉了类型声明。第四行去掉了花括号，因为闭包内容只有一个表达式，此时可以将花括号也省略。这些声明都是有效的而且功能都是完全一致的。</p> <p>闭包对参数和返回值都有具体的类型推断。当我们没有指定类型时，如果我们调用了两次闭包，第一次调用时候的类型，会被编译器锁定在闭包中，如果后续调用我们用其它类型的参数，编译器就报错。</p> <h3 id="storing-closures-using-generic-parameters-and-the-fn-traits"><a href="#storing-closures-using-generic-parameters-and-the-fn-traits" class="header-anchor">#</a> Storing Closures Using Generic Parameters and the Fn Traits</h3> <p>之前的例子中，闭包被多次调用。我们可以创建一个结构体来存储闭包和闭包的运行结果。只有当结构体中还没有缓存结果值时，才会运行闭包。这种模式称为备忘录或者懒加载。</p> <p>结构体存储闭包时，闭包定义需要添加类型声明。因为结构体定义中，字段类型是必须的。每个闭包示例都有唯一的匿名类型，这意味着，就算两个闭包的类型定义都一致，编译器还是认为它们是不同的类型。在结构体，枚举和函数参数中定义闭包，需要用到泛型和trait绑定。</p> <p><code>Fn</code>trait由标准库提供。所有闭包至少需要实现<code>Fn</code>，<code>FnMut</code>，<code>FnOnce</code>trait之一。</p> <p>在<code>Fn</code>trait绑定上声明类型，代表闭包的参数类型和返回值类型必须和该绑定。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Cacher<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
<span class="token keyword">where</span>
    T<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32<span class="token punctuation">,</span>
<span class="token punctuation">{</span>
    calculation<span class="token punctuation">:</span> T<span class="token punctuation">,</span>
    value<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>u32<span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>Cacher</code>结构体有一个<code>T</code>类型的<code>calculation</code>字段。trait绑定在<code>T</code>类型上表示这个字段是实现了<code>Fn</code>trait的闭包。如果我们想要在这个字段上存储闭包，那么这个闭包必须符合一个<code>u32</code>参数和一个<code>u32</code>返回值的声明。</p> <p><code>Value</code>字段的类型是<code>Option&lt;u32&gt;</code>，初始值是<code>None</code>。当其他代码需要<code>Cacher</code>中存储的闭包的运算结果时，<code>Cacher</code>会运行它存储的闭包，并且将结果返回和缓存。当再次调用<code>Cacher</code>获取闭包运算结果时，就将之前的计算结果返回。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Cacher<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
<span class="token keyword">where</span>
    T<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32<span class="token punctuation">,</span>
<span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>calculation<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Cacher<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        Cacher <span class="token punctuation">{</span>
            calculation<span class="token punctuation">,</span>
            value<span class="token punctuation">:</span> None<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> arg<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span>
        <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token punctuation">{</span>
            <span class="token function">Some</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">,</span>
            None <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>calculation<span class="token punctuation">)</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
                v
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>我们希望<code>Cacher</code>自身来管理字段值，而不是让外部代码去修改，因此这些字段都是私有的，通过方法返回。</p> <p>然后再修改<code>generate_workout</code>函数。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">generate_workout</span><span class="token punctuation">(</span>intensity<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> random_number<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> expensive_result <span class="token operator">=</span> Cacher<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span>num<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;calculating slowly...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        num
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> intensity <span class="token operator">&lt;</span> <span class="token number">25</span> <span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Today, do {} pushups!&quot;</span><span class="token punctuation">,</span> expensive_result<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Next, do {} situps!&quot;</span><span class="token punctuation">,</span> expensive_result<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> random_number <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Take a break today! Remember to stay hydrated!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span>
                <span class="token string">&quot;Today, run for {} minutes!&quot;</span><span class="token punctuation">,</span>
                expensive_result<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>intensity<span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="limitations-of-the-cacher-implementation"><a href="#limitations-of-the-cacher-implementation" class="header-anchor">#</a> Limitations of the <code>Cacher</code> Implementation</h3> <p>目前这个<code>Cacher</code>实现还有两个问题。</p> <p>第一个问题是，无论<code>Cacher</code>实例接收什么参数，都返回的是第一个参数计算的结果。比如下面的测试用例会失败</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function">call_with_different_values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> Cacher<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">|</span>a<span class="token operator">|</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> v1 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> v2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>将<code>value</code>字段改为哈希表类型，通过参数来映射计算值就能解决这个问题。</p> <p>第二个问题是这个<code>Cacher</code>只能存储<code>u32</code>参数类型和<code>u32</code>返回值类型的闭包。但是我们可能想存储其他类型。为了解决这个问题，可以使用多个泛型类型参数。</p> <h3 id="capturing-the-environment-with-closures"><a href="#capturing-the-environment-with-closures" class="header-anchor">#</a> Capturing the Environment with Closures</h3> <p>之前的例子中，我们把闭包当作匿名函数使用。闭包还有一个函数不具备的功能：闭包可以捕获它定义所在的上下文并且可以访问变量。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> equal_to_x <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equal_to_x</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这个例子中，<code>x</code>变量不是闭包的参数，但是仍然可以被闭包访问。因为<code>x</code>变量和闭包是定义在同一个上下文环境中的。</p> <p>当闭包捕获上下文的变量时，会将这些变量存储到内存中使用。大多数情况下代码执行不需要捕获上下文变量，这种内存开销是不必要的。因为函数不允许捕获它的上下文，因此执行函数不会引起这些额外的内存开销。</p> <p>闭包可以通过三种方式捕获上下文信息，跟函数获取参数的三种方式对应：获取所有权、可变引用和不可变引用。这三种方式分别封装在三种<code>Fn</code>trait中。</p> <ul><li><code>FnOnce</code>消费捕获的变量时，必须获取上下文变量的所有权并且传递到闭包中。Once表示闭包不能对同一个变量获取两次及以上所有权。</li> <li><code>FnMut</code>能够改变能够改变上下文中的变量值。</li> <li><code>Fn</code>不可以改变上下文中的变量值。</li></ul> <p>创建闭包时，Rust会根据你使用变量的方式来推断你使用的是哪个trait。所有闭包都实现<code>FnOnce</code>因为至少可以被调用一次。不获取所有权的闭包实现<code>FnMut</code>trait。不改变外部变量的闭包实现<code>Fn</code>trait。</p> <p>如果想要闭包强制获取所有权，可以在参数列表前使用<code>move</code>关键字。当把闭包传递给新线程，让新线程获取所有权时，这种方法很有用。</p> <p>下面是一个强制传递vec数据所有权的例子。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> equal_to_x <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;can't use x here: {:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equal_to_x</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>x</code>的所有权被传递给了闭包，在<code>println!</code>中使用会报错。</p> <h2 id="section-2-processing-a-series-of-items-with-iterators"><a href="#section-2-processing-a-series-of-items-with-iterators" class="header-anchor">#</a> Section 2 - Processing a Series of Items with Iterators</h2> <p>迭代器模式可以让你在一个有序列表上依次执行一些任务。迭代器主要负责序列中每个项目要执行的操作和控制序列的退出。</p> <p>Rust中迭代器是惰性的。意味着只要你不调用消费迭代器的方法，它就不会执行任何操作。比如这个代码就没有任何实际作用。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> v1_iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当我们创建迭代器后，有许多方法可以去消费它。</p> <p>通过<code>for</code>循环，在每个元素上执行一些操作。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> v1_iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> val <span class="token keyword">in</span> v1_iter <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Got: {}&quot;</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>迭代器可以让你更灵活的在不同序列上使用相同的逻辑，不光是在数组这样的数据结构上。</p> <h3 id="iteratortrait和next-方法"><a href="#iteratortrait和next-方法" class="header-anchor">#</a> <code>Iterator</code>Trait和<code>next</code> 方法</h3> <p>所有的迭代器都实现了标准库提供的<code>Iterator</code>trait。它的定义大致是：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Option<span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span>Item<span class="token operator">&gt;</span><span class="token punctuation">;</span>

    <span class="token comment">// methods with default implementations elided</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>有两个新语法<code>type Item</code>和<code>Self::Item</code>，它定义了一个trait的关联类型。因此，实现<code>Iterator</code>trait需要你定义一个<code>Item</code>类型，这个类型会在<code>next</code>方法的返回值类型中使用。也就是说，<code>Item</code>类型是迭代器的返回类型。</p> <p><code>Iterator</code>trait只有<code>next</code>方法是必须实现的，这个方法一次返回一个迭代器中的元素，用<code>Some</code>包裹；当迭代结束时，返回<code>None</code>。</p> <p>可以直接通过迭代器调用<code>next</code>方法：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function">iterator_demonstration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> <span class="token keyword">mut</span> v1_iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>v1_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>v1_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>v1_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>v1_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>使用<code>next</code>方法时，迭代器需要<code>mut</code>关键字定义。next方法会改变迭代器中用来追踪目前所迭代的位置状态，也可以说这是一种*消费（consumes）*行为。在<code>for</code>循环中，迭代器定义不需要<code>mut</code>关键字，因为<code>for</code>循环会获取迭代器的所有权，隐式地将其转为mutable的。</p> <p><code>next</code>方法返回的数据是原序列中元素的不可变引用。<code>iter</code>在不可变引用上生成迭代器。如果我们想创建一个拥有原序列所有权的迭代器，可以调用<code>into_iter</code>。如果想创建一个迭代器的可变引用，可以调用<code>iter_mut</code>。</p> <h3 id="消费迭代器的方法"><a href="#消费迭代器的方法" class="header-anchor">#</a> 消费迭代器的方法</h3> <p>标准库默认为<code>Iterator</code>trait提供了许多方法。有些方法内部会调用<code>next</code>方法，因此在实现<code>Iterator</code>trait时，必须实现<code>next</code>方法。</p> <p>调用<code>next</code>方法的那些方法称为<em>消费型适配器（consuming adaptors）</em>，因为它们在消耗迭代器。例如<code>sum</code>方法：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function">iterator_sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> v1_iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> total<span class="token punctuation">:</span> i32 <span class="token operator">=</span> v1_iter<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="产生新迭代器的方法"><a href="#产生新迭代器的方法" class="header-anchor">#</a> 产生新迭代器的方法</h3> <p>还有一些<code>Iterator</code>trait上定义方法，称之为<em>迭代器适配器（iterator adaptors）</em>，这些方法可以把迭代器转换成其他类型的迭代器。迭代器适配器可以链式调用，这样可以提高一组复杂操作的可读性。由于迭代器是惰性的，因此你最终需要调用消费适配器，这一组操作才会真正起作用。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v1<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的代码编译器会给出一个警告：<code>iterators are lazy and do nothing unless consumed</code>。也就是说这个代码不会起任何作用，定义的闭包也根本没有被执行。我们可以通过调用消费适配器，比如<code>collect</code>方法来解决这个问题。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v1<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> v2<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>_<span class="token operator">&gt;</span> <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">assert_eq!</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="使用闭包捕获上下文"><a href="#使用闭包捕获上下文" class="header-anchor">#</a> 使用闭包捕获上下文</h3> <p>下面通过使用<code>filter</code>迭代适配器来演示一个闭包捕获上下文的基本用法。<code>filter</code>方法接收一个闭包，这个闭包的参数是迭代器中的元素，返回值是一个布尔值。如果闭包返回<code>true</code>，则该元素会被包含在<code>filter</code>方法返回的迭代器中，反之亦然。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(PartialEq, Debug)]</span>
<span class="token keyword">struct</span> Shoe <span class="token punctuation">{</span>
    size<span class="token punctuation">:</span> u32<span class="token punctuation">,</span>
    style<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">shoes_in_my_size</span><span class="token punctuation">(</span>shoes<span class="token punctuation">:</span> Vec<span class="token operator">&lt;</span>Shoe<span class="token operator">&gt;</span><span class="token punctuation">,</span> shoe_size<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Vec<span class="token operator">&lt;</span>Shoe<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    shoes<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token operator">|</span>s<span class="token operator">|</span> s<span class="token punctuation">.</span>size <span class="token operator">==</span> shoe_size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">mod</span> tests <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span>

    <span class="token attribute attr-name">#[test]</span>
    <span class="token keyword">fn</span> <span class="token function">filters_by_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> shoes <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span>
            Shoe <span class="token punctuation">{</span>
                size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
                style<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;sneaker&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            Shoe <span class="token punctuation">{</span>
                size<span class="token punctuation">:</span> <span class="token number">13</span><span class="token punctuation">,</span>
                style<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;sandal&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            Shoe <span class="token punctuation">{</span>
                size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
                style<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;boot&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> in_my_size <span class="token operator">=</span> <span class="token function">shoes_in_my_size</span><span class="token punctuation">(</span>shoes<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">assert_eq!</span><span class="token punctuation">(</span>
            in_my_size<span class="token punctuation">,</span>
            <span class="token function">vec!</span><span class="token punctuation">[</span>
                Shoe <span class="token punctuation">{</span>
                    size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
                    style<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;sneaker&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                Shoe <span class="token punctuation">{</span>
                    size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
                    style<span class="token punctuation">:</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;boot&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><h3 id="使用iteratortrait实现自定义迭代器"><a href="#使用iteratortrait实现自定义迭代器" class="header-anchor">#</a> 使用<code>Iterator</code>trait实现自定义迭代器</h3> <p>之前的例子中，可以通过调用Vec类型上的<code>iter</code>，<code>iter_mut</code>，<code>into_iter</code>来生成一个迭代器。你也可以为标准库中的其他类型来创建迭代器，例如哈希表。也可以在你自己的类型上，实现<code>Iterator</code>trait，从而实现任何你想要的功能。唯一必须要被实现的方法是<code>next</code>方法，当你实现<code>next</code>方法后，就可以调用其他<code>Iterator</code>trait实现的默认方法。</p> <p>实现一个从1累加到5的迭代器来演示一下。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Counter <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> u32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Counter <span class="token punctuation">{</span>
        Counter <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Iterator <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item <span class="token operator">=</span> u32<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Option<span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span>Item<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token function">Some</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            None
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function">calling_next_directly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> counter <span class="token operator">=</span> Counter<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h4 id="使用iteratortrait的其他方法"><a href="#使用iteratortrait的其他方法" class="header-anchor">#</a> 使用<code>Iterator</code>trait的其他方法</h4> <p>我们实现<code>Iterator</code>trait，也定义了<code>next</code>方法，因此我们可以调用<code>Iterator</code>trait上，由标准库默认实现的任意方法，因为它们使用的都是<code>next</code>方法的功能。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function">using_other_iterator_trait_methods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum<span class="token punctuation">:</span> u32 <span class="token operator">=</span> Counter<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>Counter<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">|</span> a <span class="token operator">*</span> b<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面的代码将两个Counter迭代器组合为元组数组，并且第二个Counter的第一个元素被跳过，因此最后一组元组是<code>(5, None)</code>。<code>zip</code>方法不会返回元组中带有<code>None</code>的元素。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f46cf57.js" defer></script><script src="/assets/js/2.49ce1412.js" defer></script><script src="/assets/js/15.41e8c95f.js" defer></script>
  </body>
</html>
