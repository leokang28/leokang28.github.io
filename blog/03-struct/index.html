<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href="https://leokang28.github.io/ rss.xml" rel=alternate title=RSS type=application/rss+xml><title>KSLEO | Using Structs</title><link as=style href=https://leokang28.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://leokang28.github.io/css/style.css rel=stylesheet><link href=https://leokang28.github.io/css/custom.css rel=stylesheet><link href=https://leokang28.github.io/favicon.ico rel=icon type=image/x-icon><body><nav id=nav-bar><a class=site-title href=/>KSLEO</a><a href=/archive> /archive </a><a href=/tags> /tags </a><a href=/about> /about </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://leokang28.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://leokang28.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2022-05-15T03:43:32+08:00>Published on: <span class=accent-data>2022-05-15</span> </time><h1>Using Structs</h1></header><div class=toc-container><h2>Table of content</h2><ul><li><a href=https://leokang28.github.io/blog/03-struct/#chapter-3-using-structs-to-structure-related-data>Chapter 3 - Using Structs to Structure Related Data</a> <ul><li><a href=https://leokang28.github.io/blog/03-struct/#section-1-jie-gou-ti-de-ding-yi-he-shi-li-hua>Section 1 - 结构体的定义和实例化</a><li><a href=https://leokang28.github.io/blog/03-struct/#section-2-yi-ge-jie-gou-ti-shi-li-cheng-xu>Section 2 - 一个结构体示例程序</a><li><a href=https://leokang28.github.io/blog/03-struct/#section-3-fang-fa-yu-fa>Section 3 - 方法语法</a></ul></ul></div><div class=post-content><h1 id=chapter-3-using-structs-to-structure-related-data>Chapter 3 - Using Structs to Structure Related Data</h1><p>结构体是一个编码者自定义的数据类型，可以让编码者自己命名，组织一些数据形成一个有特殊意义的集合。跟面向对象概念中的对象概念类似。结构体和枚举是创建新类型的基础，以致能够充分利用 Rust 编译器做类型检查。<h2 id=section-1-jie-gou-ti-de-ding-yi-he-shi-li-hua>Section 1 - 结构体的定义和实例化</h2><p>结构体跟元组有些类似，它内部的数据也可以是不同的类型。与元组不同的地方是，你可以对每个数据命名，便于理解这些数据具体代表的是什么含义。由于有了这些名称，你不再需要像元组一样按顺序访问内部元素。<p><code>struct</code>关键字后加一个名称就定义了一个结构体。结构体的自定义名称应该是充分语义化的，能够传达内部数据为何要组织在一起。在花括号中，定义了每个元素的名称和类型，这些内部元素称之为<em>fields（字段）</em>。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
</code></pre><p>通过结构体生成的变量称之为<em>instance（实例）</em>。创建一个实例需要指明使用的结构体名称，并且以<em>key-value</em>的形式填充每一个字段。key 是在结构体中定义好的字段名称，value 是我们想要在对应的字段中存储的数据。实例化的时候，字段顺序不需要和结构体定义的顺序一致。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
</code></pre><p>获取实例中的数据可以通过点操作符，例如<code>user1.email</code>。只要该实例是 mutable 的，我们就可以对它上面的字段数据做修改，例如<code>user1.mail = String::from("anotheremail@example.com");</code>。需要注意，在改变数据时，实例本身需要是 mutable 的，Rust 不允许仅其中某些字段为 mutable。<p>与其他表达式一样，可以在函数最后实例化一个结构体并将其作为函数返回值。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre><h3 id=shi-li-hua-jian-xie>实例化简写</h3><p>因为参数名和字段名是完全相等的，可以通过字段初始化简写语法来创建实例。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre><h3 id=tong-guo-qi-ta-shi-li-chuang-jian-xin-shi-li>通过其他实例创建新实例</h3><p>通过已经存在的实例创建新实例是一个非常便捷的方法，并且可以使用结构体更新语法。先看一下使用普通方法的例子<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
</code></pre><p>创建一个新实例<code>user2</code>，并且<code>active</code>和<code>sign_in_count</code>这两个字段是从<code>user1</code>取值的。使用结构体更新语法可以使代码量更少。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
</code></pre><h3 id=shi-yong-yuan-zu-he-jie-gou-ti-gou-zao-xin-lei-xing>使用元组和结构体构造新类型</h3><p>我们可以定义一些像元组一样的结构体，称之为元组结构体。元组结构体具有语义化的名称，但是没有字段名，也就是说只有字段类型。元组结构体在给元组命名和与其他元组做区分时特别有用。<p>元组结构体的定义：<code>struct</code>关键字加一个名称，后面再跟一个括号，里面是字段类型列表。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
</code></pre><p><code>black</code>和<code>origin</code>是不同的变量，因为他们结构体的名称不同，哪怕他们内部的字段类型列表是完全一致的。元组结构体的实例和普通的元组在操作上没有任何区别。<h3 id=unit-like-structs-without-any-fields>Unit-Like Structs Without Any Fields</h3><p>结构体定义时也可以没有任何的字段，这种结构体称为<em>unit-like struct（类单元结构）</em>，因为他们的表现跟单元类型<code>()</code>相似。当你需要在某个类型上实现某些 trait，但又不想存储任何数据时，类单元结构很有用。<h2 id=section-2-yi-ge-jie-gou-ti-shi-li-cheng-xu>Section 2 - 一个结构体示例程序</h2><p>写一个计算矩形面积的程序，从普通的变量开始。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn main() {
    let width1 = 50;
    let height1 = 30;

    println!("area is {}", area(width1, height1));
}

fn area(width:u32, height:u32) -> u32 {
    width * height
}
</code></pre><p>矩形的高度和宽度是两个关联的变量，因为他们构成了一个矩形，但是目前在程序中看不到任何关联性，可读性太差。<h3 id=shi-yong-yuan-zu-zhong-gou>使用元组重构</h3><pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn main() {
    let rect1 = (50, 30);

    println!("area is {}", area(rect1));
}

fn area(rect: (u32, u32)) -> u32 {
    rect.0 * rect.1
}
</code></pre><p>使用元组稍微有了一些结构性，但是在可读性还是不够好，因为元组不能够对字段进行命名。<h3 id=shi-yong-jie-gou-ti-zhong-gou>使用结构体重构</h3><pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>struct Rect {
    width: u32,
    height: u32,
}
fn main() {
    let rect1= Rect {
        width: 50,
        height: 30,
    };

    println!("area is {}", area(rect1));
}

fn area(rect: Rect) -> u32 {
    rect.width * rect.height
}
</code></pre><p>定义一个矩形类型之后，代码目前可读性和抽象都比较好。<h2 id=section-3-fang-fa-yu-fa>Section 3 - 方法语法</h2><p>方法和函数的唯一区别在于，方法是定义在类型中的，有它特定的执行上下文。方法的第一个参数永远是<code>self</code>，是一个当前调用它的实例。<h3 id=fang-fa-ding-yi>方法定义</h3><p>使用<code>impl</code>关键字。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>struct Rect {
    width: u32,
    height: u32,
}

// 方法定义
impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
fn main() {
    let rect1= Rect {
        width: 50,
        height: 30,
    };

    println!("area is {}", rect1.area());
}
</code></pre><p>:::details ->和. 在 C/C++中，方法的调用有两种操作符，分别是<code>-></code>和<code>.</code>。当直接在实例上调用方法时使用<code>.</code>操作符，当使用指针调用方法时使用<code>-></code>操作符。也就是说当<code>obj</code>是一个指针时，<code>obj->func()</code>和<code>(*obj).func()</code>是一样的。<p>Rust 中没有和<code>-></code>等同的操作符，Rust 的方案是自动引用和解析引用。当你通过<code>obj.func()</code>调用方法时，Rust 会自动加上<code>&</code>、<code>&mut</code>和<code>*</code>，让<code>obj</code>能够跟函数声明匹配。 :::<h3 id=duo-ge-can-shu-de-fang-fa>多个参数的方法</h3><pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn main() {
    let rect1 = Rect {
        width: 30,
        height: 50,
    };
    let rect2 = Rect {
        width: 10,
        height: 40,
    };
    let rect3 = Rect {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}

impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rect) -> bool {
        self.width > other.width && self.height > other.height
    }
}
</code></pre><h3 id=duo-ge-impldai-ma-kuai>多个<code>impl</code>代码块</h3><p>Rust 是允许多个<code>impl</code>代码块的，例如<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rect {
    fn can_hold(&self, other: &Rect) -> bool {
        self.width > other.width && self.height > other.height
    }
}
</code></pre><p>目前没有必要写成多个<code>impl</code>代码块，后面会介绍到这种方法的适用情况。</div><div class=post-tags><a class=tag href=/tags/rust>#Rust </a></div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme</div></footer><script defer src=https://leokang28.github.io/js/script.js></script>