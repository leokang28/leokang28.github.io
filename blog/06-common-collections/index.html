<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href="https://leokang28.github.io/ rss.xml" rel=alternate title=RSS type=application/rss+xml><title>KSLEO | Common Collections</title><link as=style href=https://leokang28.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://leokang28.github.io/css/style.css rel=stylesheet><link href=https://leokang28.github.io/css/custom.css rel=stylesheet><link href=https://leokang28.github.io/favicon.ico rel=icon type=image/x-icon><body><nav id=nav-bar><a class=site-title href=/>KSLEO</a><a href=/archive> /archive </a><a href=/tags> /tags </a><a href=/about> /about </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://leokang28.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://leokang28.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2021-03-10T09:54:00+08:00>Published on: <span class=accent-data>2021-03-10</span> </time><h1>Common Collections</h1></header><div class=toc-container><h2>Table of content</h2><ul><li><a href=https://leokang28.github.io/blog/06-common-collections/#chapter-6-common-collections>Chapter 6 - Common Collections</a> <ul><li><a href=https://leokang28.github.io/blog/06-common-collections/#section-1-vector>Section 1 - Vector</a><li><a href=https://leokang28.github.io/blog/06-common-collections/#section-2-string>Section 2 - String</a><li><a href=https://leokang28.github.io/blog/06-common-collections/#section-3-hashmap>Section 3 - HashMap</a></ul></ul></div><div class=post-content><h1 id=chapter-6-common-collections>Chapter 6 - Common Collections</h1><p>Rust 标准库提供了很丰富的数据集合类。大多数数据结构通常只能存储一条数据，而集合可以存储多条数据。跟数组和元组不同，集合的数据存储在 heap 上，这意味着它存储的数据可以不用在编译阶段确定大小和内容，可以在运行时自由操作。这里介绍使用频率最高的三种集合类型：<ul><li>Vector<li>String<li>HashMap</ul><h2 id=section-1-vector>Section 1 - Vector</h2><p>首先介绍集合<code>Vec&LTT></code>，vector 允许你在单个数据结构里存储多个值，这些值存储在内存中相邻的位置。Vector 只能存储相同类型的数据，当你有一个类型列表时 Vector 非常适用。<h3 id=creating-a-new-vector>Creating a New Vector</h3><p>通过<code>Vec::new</code>方法新建一个 vector。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let v:Vec&LTi32> = Vec::new();
</code></pre><p>Vector 是基于泛型实现的，创建 vector 时如果没有初始化值，则需要指定类型。<p>在一些应用场景中，Rust 可以根据指定的初始化值推断 vector 的类型，所以一半很少通过类型变量指定类型。创建 vector 时进行初始化是比较常见的方式，Rust 提供了<code>vec!</code>宏来初始化并创建 vector。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let v = vec![1, 2, 3];
</code></pre><p>由于我们使用<code>i32</code>类型的数据初始化 vector，因此 Rust 可以推断出这个 vector 是<code>i32</code>类型的。<h3 id=updating-a-vector>Updating a Vector</h3><p>使用<code>push</code>方法在 vector 实例上追加数据。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
</code></pre><p>vector 类型的变量要更改时也需要使用<code>mut</code>关键字声明。由于 push 的数据都是<code>i32</code>类型的，因此 Rust 将此类型推断为 vector 的类型，因此可以不用指定其类型。<h3 id=dropping-a-vector-drops-its-elements>Dropping a Vector Drops Its Elements</h3><p>跟其他结构体一样，vector 所在的上下文结束时，它将被释放（没有发生所有权转移）。当 vector 被释放时，它内部的数据也将被删除。这听起来似乎简单合理，但是当开始引用 vector 内的数据时，情况将变得复杂。<h3 id=reading-elements-of-vectors>Reading Elements of Vectors</h3><p>有两种方式引用 vector 中存储的数据。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust> let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
</code></pre><p>第一种方式通过<code>&[]</code>返回一个引用，然后使用下标访问 vector 中的数据，下标从 0 开始，与数组类似。第二种方式通过 vector 实例上的<code>get</code>方法，它返回一个<code>Option<&T></code>。<p>由于有两种访问方式，所以当发生越界访问时，需要针对不同的访问方式做不同的处理。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let v = vec![1, 2, 3];

let num = &v[100];

let num = v.get(100);
</code></pre><p>第一种访问方式会导致程序报错，当你希望发生越界时程序终止运行，可以使用这种方式。<p>当使用<code>get</code>方法时，如果发生越界访问，它会返回<code>None</code>，后续应当有处理<code>Some(&i32)</code>和<code>None</code>的逻辑。这种方式相比程序终止，有更好的用户体验。<p>当创建了一个有效引用，borrow checker 会强制执行所有权和<a href=/Rust/2-ownership.html#the-rules-of-references>引用规则</a>检查来确保当前引用和其他指向 vector 内容的引用也是有效的。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {}", first);
</code></pre><p>这个代码在编译阶段会报错，因为在同一个上下文环境中，对同一个数据存在 immutable 引用时，不能有 mubable 类型的引用。这段代码看上去应该是可以运行的，为什么对 vector 头部的引用和 vector 尾部的 push 操作会发生冲突呢？因为追加数据时有可能存在当前内存不足，在 heap 上重新分配内存，而此时旧的引用还指向之前被释放的内存，此时不符合引用规则中所有引用都必须有效的那一条，因此编译器会直接报错。<h3 id=iterating-over-the-values-in-a-vector>Iterating over the Values in a Vector</h3><p>使用<code>for</code>循环遍历 vector，获取内部每一条数据的一个 immutable 引用。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let v = vec![1, 2, 3];

for &i in &v {
    println!("{}", i);
}
</code></pre><p>也可以通过遍历 mutable 引用来修改 vector 中的数据。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let mut v = vec![1, 2 ,3];
for &i in &mut v {
    i *= 2;
}
</code></pre><h3 id=using-an-enum-to-store-multiple-types>Using an Enum to Store Multiple Types</h3><p>之前说过 vector 只能存储相同类型的数据，这个限制很不方便，因为有很多的场景需要存储不同类型的数据列表。我们可以通过定义枚举来满足这种场景需求。<p>比如我们需要读取一个电子表格的一行数据，其类型可能是数字、字符串等。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
</code></pre><p>Rust 在编译阶段需要知道 vector 存储何种数据类型，方便在 heap 上分配每个元素所需要的内存大小。第二个好处是可以明确指定这个 vector 存储的是何种类型。<p>在编写过程中，如果你不能确定枚举下的所有类型，这种方式则不适用。此时可以用 trait 对象作为替代，后面的章节中会介绍到 trait 对象。<h2 id=section-2-string>Section 2 - String</h2><p>许多 Rust 新手对 String 会在理解上有一些吃力，基于一下三个可能的原因：<ul><li>Rust 倾向于抛出任何可能的错误。<li>String 是一个比许多程序员所理解的更加复杂的数据类型。<li>UTF8。</ul><p>将 String 放在集合这一章讨论，是由于 String 类型是基于字节的集合实现的，并且添加了一些实用功能，这些字节在 String 类型中会被解析为文本。下面会讨论 String 类型和其他集合类型的相同之处，如 creating，updating，reading 等操作。还将讨论 String 和其他集合类型的不同之处——Stirng 类型上操作的复杂化，由于人和机器对文本的解释方式不同。<h3 id=what-is-a-string>What Is a String?</h3><p>首先定义一下<em>string</em>的含义。Rust 语言核心中只有一种字符串类型，即字符串切片<code>str</code>。之前介绍过字符串切片，是对一些 utf8 编码数据的引用。保存在可执行文件中的字符串字面量也是<code>str</code>。<p>而<code>String</code>类型，是由 Rust 标准库提供而非写在 Rust 语言核心中，是一种可扩展、可修改、utf8 编码的字符串类型。当在 Rust 中提到字符串类型时，一般指的是这两种类型而非其中一种。<h3 id=creating-a-new-string>Creating a New String</h3><p><code>String</code>类型上的方法大多数都是和<code>Vec&LTT></code>类型相似的。比如新建方法<code>new</code>。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let mut s = String::new();
</code></pre><p>这里新建了一个空的字符串<code>s</code>，之后可以在它上面存储文本数据。但是通常在新建字符串时都会有初始化的值。可以使用<code>to_string</code>方法将字面量或者<code>str</code>数据转换成<code>String</code>类型。也可以使用<code>String::from</code>方法来创建，跟<code>to_string</code>方法效果是一样的。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let data = "initial data";

let s = data.to_string();
let s = "initial data".to_string();

let s = String::from("initial data");
</code></pre><p><code>String</code>类型是 utf8 编码的，因此它可以存储任何 utf8 编码范围内的文本数据，以下都是有效的字符串数据。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
</code></pre><h3 id=updating-a-string>Updating a String</h3><p><code>String</code>类型大小、内容都可以改变，可以像<code>Vec&LTT></code>一样用 push 的方式追加数据。此外，也可以通过<code>+</code>运算符或者<code>format!</code>宏来进行字符串拼接。<h4 id=appending-to-a-string-with-push-str-and-push>Appending to a String with <code>push_str</code> and <code>push</code></h4><p><code>push_str</code>方法追加一个字符串切片。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let mut s = String::from("foo");

s.push_str("bar");
</code></pre><p><code>push</code>方法追加单个字符。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>s.push('a');
</code></pre><h4 id=concatenation-with-the-operator-or-the-format-macro>Concatenation with the + Operator or the format! Macro</h4><p><code>+</code>运算符拼接字符串<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 这里s1的所有权发生了转移
</code></pre><p>加运算执行完毕后<code>s1</code>不再有效的原因，和为什么要使用<code>s2</code>的引用进行加运算的原因，在于执行<code>+</code>运算时所调用的方法。该方法的声明类似于：<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn add(self, s: &str) -> String
</code></pre><p>标准库中的<code>add</code>方法是通过泛型声明的。这里我们使用<code>String</code>类型作为说明。<p>首先<code>s2</code>变量之前有<code>&</code>修饰符，说明这里是一个<code>s2</code>的引用。由于<code>add</code>方法的声明，只能将一个第二个字符串的引用作为参数和第一个字符串做合并。也不能合并两个<code>String</code>类型的数据。但是，<code>&s2</code>是一个<code>&String</code>类型而非<code>&str</code>类型，为什么编译器没有报错？<p>因为编译器可以将<code>&String</code>类型*coerce（强转换）*为<code>&str</code>类型。调用<code>add</code>方法时，Rust 进行了 deref coercion（隐式强转换），在这个例子中，<code>&s2</code>将返回<code>&s2[..]</code>。由于<code>add</code>方法没有获取参数<code>s</code>的所有权，因此<code>s2</code>变量在计算之后依然是有效的。<p>其次，<code>add</code>方法获取了<code>self</code>的所有权。这意味着<code>s1</code>变量在进行计算之后不再有效。<code>s3 = s1 + &s2;</code>看起来是进行了值的复制和拼接，并且创建了新的变量。实际上是对<code>s1</code>进行内容追加后转移了的所有权。看似进行了许多复制和变量的新建，实际上要比这更有效率。<p>而在多个字符串进行拼接时，<code>+</code>运算符看起来会比较啰嗦。此时使用<code>format!</code>宏代替是比较好的方案。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
</code></pre><p><code>format!</code>宏的方法比<code>+</code>运算符可读性更好，并且它不会获取任何参数的所有权。<h3 id=indexing-into-strings>Indexing into Strings</h3><p>在其他语言中，使用索引访问字符串中的某个字符是常见的操作。但是在 Rust 中会报错，Rust 不支持数字索引，要解释这个问题，需要讨论 Rust 如何在内存中存储 String 数据。<h4 id=internal-representation>Internal Representation</h4><p><code>String</code>类型是对<code>Vec&LTu8></code>类型的一层封装。来看一些 utf8 编码的字符串示例<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let mut s = String::from("hola");
</code></pre><p>在这个示例中，<code>s</code>的长度是 4，意思是 vector 存储的“hola”有 4 字节长，每个字母占 1 字节。但是在其他字符数据的情况下呢？<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let hello = "Здравствуйте";
// 注意这是西里尔字母З，而不是阿拉伯数字3
let answer = &hello[0];
</code></pre><p>这个例子中，<code>answer</code>会是<code>З</code>吗？在 utf8 编码中，3 的第一个字节是<code>208</code>，第二个字节是<code>151</code>，所以<code>answer</code>的值是<code>208</code>，而<code>208</code>不是一个有效字符。这跟用户期望返回第一个字符不一致，但 Rust 在 0 索引处存储的值就是<code>208</code>的 16 进制。用户通常不希望获得字节类型的数据，哪怕字符串全部是由拉丁字母组成的。如果<code>&"hello"[0]</code>是一个合法的索引，那么它也只会返回<code>104</code>而不是<code>h</code>。因此，Rust 不允许使用索引访问字符串中的字符，在编译阶段就抛出错误，以免在开发阶段对代码的执行产生误解。<h4 id=bytes-and-scalar-values-and-grapheme-clusters>Bytes and Scalar Values and Grapheme Clusters</h4><p>从 Rust 的视角来看，有三种相关的方式查看 String 中的数据：<em>Bytes（可执行）</em>，<em>scalar values（标量）</em>，<em>grapheme clusters（词组）</em>（最接近人类字符的概念）。<p>用梵文写的印地语“नमस्ते“，在<code>Vec&LTu8></code>中存储的数据是<blockquote><p><code>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</code>。</blockquote><p>这 18 个 16 进制数据就是计算机最终存储的数据。如果从 unicode 标量的角度看，也是 Rust 中的<code>char</code>类型。这些字节串可以看作<blockquote><p><code>['न', 'म', 'स', '्', 'त', 'े']</code></blockquote><p>其中有 6 个 char 字符，其中第四个和第六个是变音符号，不具备表意功能。最后，如果从词组的角度看，就可以得到一个人类阅读友好的组成单词的四个字母。<blockquote><p><code>["न", "म", "स्", "ते"]</code></blockquote><p>Rust 提供了多种方式来解释计算机存储的原始字符数据，满足不同程序的数据需求，而不用关心具体使用的是哪种人类语言。<p>Rust 不允许使用索引访问字符串数据的最后一个原因是，索引操作要求数据量不会影响读取的时间复杂度（O(1)）。但是这在 String 类型的性能上是不能够保证的，因为 Rust 需要从头遍历到索引位置处，找出其中有效的字符。<h3 id=slicing-strings>Slicing Strings</h3><p>索引访问 String 不是一个好的方案，原因还在于索引访问的返回值不清晰，是应该返回可执行数据，还是字符，还是词组，还是字符串切片呢？因此，Rust 需要编码者在使用索引创建字符串切片时更加准确的定义返回值。为了更具体的索引，请使用<code>[]</code>和范围语法创建字符串切片，而不是在<code>[]</code>中使用单个数字。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let hello = "Здравствуйте";

let s = &hello[0..4];
</code></pre><p>这里<code>s</code>是一个<code>&str</code>，由于每个西里尔字符使用 2 字节编码，因此<code>s</code>的值应该是 Зд。如果把<code>s</code>变量改成<code>&hello[0..3]</code>，程序会在运行时崩溃——当前索引不在正确的字符边界处。在使用 range 创建字符串切片时需要小心，因为有可能会让程序崩溃。<h3 id=methods-for-iterating-over-strings>Methods for Iterating Over Strings</h3><p>如果需要在每个单独的 unicode 字符标量上执行某些操作，可以通过 String 的<code>chars</code>方法来遍历每个字符标量，它返回的是<code>char</code>类型。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>for c in "नमस्ते".chars() {
    println!("{}", c);
}
</code></pre><p><code>bytes</code>方法返回原始的字节数据。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>for b in "नमस्ते".bytes() {
    println!("{}", b);
}
</code></pre><p>请记住有效的 unicode 字符标量是有 1 个或以上的字节所组成的。<p>由于返回词组的方法比较复杂，因此标准库并没有提供相关功能。有需要可以上<a href=https://crates.io/ rel=noopener target=_blank>crates.io</a>查看。<h3 id=strings-are-not-so-simple>Strings Are Not So Simple</h3><p>Rust 将正确的处理字符串数据作为所有程序的默认行为，因此编码者需要在前期投入精力去思考如何正确的处理 utf8 数据。代价则是相比其他编程语言，Rust 暴露了更多的复杂性给编码者，但同时能够让你避免类似于非 ASCII 字符的错误。<h2 id=section-3-hashmap>Section 3 - HashMap</h2><p>最后一个要介绍的常见集合是<em>hash map</em>。<code>HashMap&LTK, V></code>类型存储的是<code>K</code>类型与<code>V</code>类型之间的键值对映射关系。通过<em>hashing function</em>来实现，这个函数确定了键和值如何在内存中存储。这个功能很多编程语言都提供了，只不过叫法有差异，比如哈希表、对象、map、字典等等。<p>当你想通过非数字索引的方式查看数据时，哈希表是很实用的，它使用的是任意数据类型的键来检索数据。<p>我们仅列举一些常用的 API，在标准库<code>HashMap&LTK, V></code>中定义了许多实用的方法，具体查阅标准库文档。<h3 id=creating-a-new-hash-map>Creating a New Hash Map</h3><p>通过<code>new</code>方法新建，<code>insert</code>方法插入数据。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::colloctions::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
</code></pre><p>首先需要引入<code>HashMap</code>模块。在介绍的三种集合中，HashMap 是使用频率最低的，因此它没有被默认包含到上下文中。标准库对 HashMap 的支持也很少，比如没有宏来构建 HashMap。<p>跟 vectors 一样，哈希表的数据存储在 heap 上。上面的代码定义了一个键为<code>String</code>类型，值为<code>i32</code>类型的哈希表。哈市表跟 vector 一样是同质的，即键是同一种数据类型，值也是同一种数据类型。<p>另外一种创建哈希表的方式是通过迭代器和元组组成的 vector 上的<code>collect</code>方法，其中每个元组包含哈希表的键和值。<code>collect</code>方法将数据收集到多种集合类型中，包括哈希表。<code>zip</code>方法可以用来创建元组组成的 vector。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let mut scores: HashMap<_, _> =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
</code></pre><p>类型声明<code>HashMap<_, _></code>是必须的，因为<code>collect</code>方法会把数据收集到许多种集合中，除非你指定，否则 Rust 不知道你需要的是哪一种。键和值的类型参数使用下划线占位，此时 Rust 可以通过返回值来推断键和值的类型。<h3 id=hash-maps-and-ownership>Hash Maps and Ownership</h3><p>对于实现了<code>Copy</code>trait 的类型来说，比如<code>i32</code>，值是拷贝进哈希表的。对于 owned 的数据类型来说，比如<code>String</code>，所有权会被转移到哈希表上。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);

// error[E0382]: borrow of moved value: `field_name`
</code></pre><p>在这个例子中，当<code>field_name</code>和<code>field_value</code>被添加到 map 之后，我们是不能使用这个值的，因为所有权被传递到了 map 中。<p>如果我们使用引用插入到哈希表中，那么所有权将不会被移动到哈希表中。但是，此时需要保证引用的有效时间至少要和哈希表一致。<h3 id=accessing-values-in-a-hash-map>Accessing Values in a Hash Map</h3><p><code>get</code>方法获取哈希表的值。<code>get</code>方法返回<code>Option<&V></code>。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collection::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
</code></pre><p>使用<code>for</code>循环遍历键值对<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{}: {}", key, value);
}
</code></pre><h3 id=updating-a-hash-map>Updating a Hash Map</h3><p>键值对的数量是可以增加的，但是每个键只能关联到一个值。当你需要修改哈希表的值时，需要考虑到值已经关联了值的情况，覆盖、舍弃还是合并。<h4 id=overwriting-a-value>Overwriting a Value</h4><p>如果在插入值之后，重新对同一个键进行了插值，那么新值会将旧值覆盖。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
// 25
</code></pre><h4 id=only-inserting-a-value-if-the-key-has-no-value>Only Inserting a Value If the Key Has No Value</h4><p>检查键是否关联了值，如果没有就给他它关联一个新值，这是很常见的逻辑。哈希表对这种情况提供了一个特殊的 API<code>entry</code>，它的参数是你需要检查的键，返回一个<code>Entry</code>枚举，代表一个值是否存在。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
// {"Yellow": 50, "Blue": 10}
</code></pre><p><code>or_insert</code>方法当键存在时，返回一个该键值的可变引用。如果不存在，则把参数当作值插入到哈希表中然后返回一个可变引用。<h4 id=updating-a-value-based-on-the-old-value>Updating a Value Based on the Old Value</h4><p>另一种常见场景是使用旧值更新哈希表的新值。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
// {"world": 2, "hello": 1, "wonderful": 1}
</code></pre><h3 id=hashing-functions>Hashing Functions</h3><p><code>HashMap</code>默认使用*<a href=https://www.131002.net/siphash/siphash.pdf rel=noopener target=_blank>cryptographically strong</a><em>散列函数。它对 DoS 攻击有很好对抵抗性。这个算法不是最快的，但是从安全性的角度考虑，舍弃这点性能是值得的。如果你想自己指定散列函数，你可以指定一个</em>hasher*来自己切换散列函数。hasher 是一个实现了<code>BuildHasher</code>trait 的类型。</div><div class=post-tags><a class=tag href=/tags/rust>#Rust </a></div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme</div></footer><script defer src=https://leokang28.github.io/js/script.js></script>