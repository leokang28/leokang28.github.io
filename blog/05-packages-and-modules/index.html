<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href="https://leokang28.github.io/ rss.xml" rel=alternate title=RSS type=application/rss+xml><title>KSLEO | Packages, Crates and Modules</title><link as=style href=https://leokang28.github.io/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://leokang28.github.io/css/style.css rel=stylesheet><link href=https://leokang28.github.io/css/custom.css rel=stylesheet><link href=https://leokang28.github.io/favicon.ico rel=icon type=image/x-icon><body><nav id=nav-bar><a class=site-title href=/>KSLEO</a><a href=/archive> /archive </a><a href=/tags> /tags </a><a href=/about> /about </a><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://leokang28.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://leokang28.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2021-01-15T13:42:49+08:00>Published on: <span class=accent-data>2021-01-15</span> </time><address rel=author>By <span class=accent-data>ksleo</span></address><h1>Packages, Crates and Modules</h1></header><div class=toc-container><h2>Table of content</h2><ul><li><a href=https://leokang28.github.io/blog/05-packages-and-modules/#chapter-5-managing-growing-projects-with-packages-crates-and-modules>Chapter 5 - Managing Growing Projects with Packages, Crates, and Modules</a> <ul><li><a href=https://leokang28.github.io/blog/05-packages-and-modules/#section-1-packages-and-crates>Section 1 - Packages and Crates</a><li><a href=https://leokang28.github.io/blog/05-packages-and-modules/#section-2-defining-modules-to-control-scope-and-privacy>Section 2 - Defining Modules to Control Scope and Privacy</a><li><a href=https://leokang28.github.io/blog/05-packages-and-modules/#section-3-paths-for-referring-to-an-item-in-the-module-tree>Section 3 - Paths for Referring to an Item in the Module Tree</a><li><a href=https://leokang28.github.io/blog/05-packages-and-modules/#section-4-bringing-paths-into-scope-with-the-use-keyword>Section 4 - Bringing Paths into Scope with the use Keyword</a><li><a href=https://leokang28.github.io/blog/05-packages-and-modules/#section-5-separating-modules-into-different-files>Section 5 - Separating Modules into Different Files</a></ul></ul></div><div class=post-content><h1 id=chapter-5-managing-growing-projects-with-packages-crates-and-modules>Chapter 5 - Managing Growing Projects with Packages, Crates, and Modules</h1><p>当项目体积越来越大，良好的代码组织就变得很重要。因为只靠脑子记忆整个项目的代码逻辑是不可能的。<p>目前为止所写的一些示例程序都是一个模块一个文件下的。当项目体积增长，就可以将代码分割到不同模块不同文件中。一个*package（包）*可以包含多个可执行 crate，并且可以选择性的包含一个库 crate。当包体积变大，可以通过提取代码成一个独立的 crate，将它转变为一个外部依赖。本章会涵盖所有这些技术。<p>除了分组功能，封装逻辑实现代码可以让代码复用：当你封装了一个操作，其他地方的代码可以通过接口直接使用这个功能，而不需要知道内部具体是如何实现的。封装代码哪部分是公用接口，哪部分是私有属性，这取决于封装实现的编码人员。<p>还有一个相关概念称之为<em>scope（域）</em>：这是一个嵌套结构的上下文环境。当读写编译代码时，编码人员和编译器都需要知道特定位置的一些特定名称代表的是一个变量、函数、结构体、模块还是一些其他的东西。你可以创建一个 scope 并指定哪些内容在这个 scope 中。在同一个 scope 中不允许出现两个名称一致的实体。有一些工具可以解决命名冲突。<p>Rust 模块系统包括：<ul><li><strong>Packages</strong>：是 Cargo 的一个功能，可以用来创建、测试和发布 crate。<li><strong>Crates</strong>：一个导出可执行文件或者可执行文件的模块树。<li><strong>Modules</strong>和<strong>use</strong>：用来控制<em>Paths</em>的组织、域和隐私。<li><strong>Paths</strong>：命名实体的方式，例如给函数、结构体和模块命名。</ul><p>接下来会依次覆盖这些内容。<h2 id=section-1-packages-and-crates>Section 1 - Packages and Crates</h2><p><em>crate</em>是一个可执行文件或者库。<em>crate root</em>是编译器开始编译并把你的 crate 打包成根模块的源文件。<em>package</em>是由一个或者多个提供了某些功能的 crate 组成的。一个 package 有一个描述如何构建这些 crate 的<em>Cargo.toml</em>文件。<p>一个 package 最多包含一个库 crate，可以包含任意数量的可执行 crate。但是至少要包含一个 crate。<p>看一下使用<code>cargo new</code>创建新的 package 时发生了什么。<pre><code>$ cargo new my-project
    Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre><p>cargo 生成一个 package，创建了一个<em>cargo.toml</em>文件。看一下 cargo.toml 文件的内容，里面没有关于<em>src/main.rs</em>的信息，因为 Rust 遵循一个规定，<em>src/main.rs</em>文件是与 package 同名的可执行 crate 的入口文件。如果 package 下有一个<em>src/lib.rs</em>文件，则它是与 package 同名的库 crate 的入口文件。cargo 将入口文件传给<code>rustc</code>构建库或者可执行文件。<p>我们刚生成的项目中，只有一个 src/main.rs 文件，意味着这个项目只有一个可执行 crate。如果 package 中同时具有<em>src/main.rs</em>和<em>src/lib.rs</em>文件，则说明这个 package 有一个可执行 crate 和一个库 crate，且都与 package 同名。如果 package 具有多个可执行 crate，则对应的文件需要存放在<em>src/bin</em>目录下，每个文件都是一个独立的可执行 crate。<p>一个 crate 最好将一些相关功能组织到一个 scope 里面，方便在项目之间复用。<p>将 crate 的功能保持在它的 scope 内，可以明确该功能是我们自己定义的还是该 crate 定义的，避免潜在冲突。比如，<code>rand</code>crate 定义了一个 trait 叫做<code>Rng</code>。我们也可以自己定义一个结构体叫<code>Rng</code>。由于 crate 的功能被限定在自己的 scope 中，因此当我们引入 rand 的时候，编译器很明确<code>Rng</code>是指向何处的。在我们自己的 crate 中，<code>Rng</code>指向我们定义的结构体；当我们要使用<code>rand</code>中的<code>Rng</code>时，可以通过<code>rand::Rng</code>的方式访问。<h2 id=section-2-defining-modules-to-control-scope-and-privacy>Section 2 - Defining Modules to Control Scope and Privacy</h2><p>module 让我们把代码组织管理，方便维护和复用。同时 module 还控制一个实体的隐私性，是外部可访问（public）还是不可访问（private）。<p>接下来写一个库 crate 作为例子。这些代码只定义函数声明而不实现函数体，因为现在需要将重点放在代码组织上。<p>我们模拟一个餐厅的状况。餐厅有<em>front of house</em>和<em>back of house</em>。前厅主要是客人吃饭，服务员送餐，下单等。后厅主要给厨师使用。<p>我们可以将功能函数通过嵌套模块的方式组织。使用<code>cargo run --lib restaurant</code>创建一个 restaurant 库 crate，然后写入以下代码。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre><p>我们用<code>mod</code>关键字创建了一个<code>front_of_house</code>模块，并且用花括号将其内容包裹。在这个模块中，可以定义其他的模块，比如<code>hosting</code>、<code>serving</code>，当然内部也可以定义其他的内容，比如结构体、枚举、函数、traits 等。<p>通过模块可以将相关的定义组织在一起。编码人员想阅读或者扩展这个模块时，都能很方便的找到，且不破坏其组织性。<p>之前有提到<em>src/main.rs</em>和<em>src/lib.rs</em>被称作 crate 的入口文件。之所以叫他们入口文件是因为，这两个文件中的内容都会生成一个根结点为 crate 的模块树。<pre><code>crate
└── front_of_house
    ├── hosting
    │   ├── add_to_waitlist
    │   └── seat_at_table
    └── serving
        ├── take_order
        ├── serve_order
        └── take_payment
</code></pre><p>这棵树展示了模块的嵌套关系。可以看出这棵树上的一些模块是兄弟节点，这说明他们定义在同一个模块里。这里的概念和数据结构树中的兄弟子父节点的概念是类似的。整个模块的父节点是 crate 隐式节点。<h2 id=section-3-paths-for-referring-to-an-item-in-the-module-tree>Section 3 - Paths for Referring to an Item in the Module Tree</h2><p>如何导入模块中的内容使用，Rust 使用和文件系统路径相似的概念。调用一个外部方法的时候需要知道它的路径。<p>路径有两种形式：<ul><li>从 crate 根节点开始的绝对路径。<li>从当前模块开始的相对路径，在当前模块中调用<code>self</code>、<code>super</code>或者其他关键字和名称。</ul><p>绝对路径和相对路径都是一组通过<code>::</code>符号分隔的标识符组成。<p>回到之前的例子，应该如何调用<code>add_to_waitlist</code>这个函数呢？或者说，这个函数的路径是什么？下面的代码用两种方式来调用该方法。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // abs path
    crate::front_of_house::hosting::add_to_waitlist();
    // relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre><p>第一种方式使用绝对路径调用函数。<code>add_to_waitlist</code>函数和<code>eat_at_restaurant</code>函数定义在同一个 crate 中，因此可以使用<code>crate</code>关键字作为绝对路径的开头。紧接着引入连续的模块名直到该函数的位置，和文件系统路径很相似。<p>第二种方式使用相对路径调用函数。路径是以<code>front_of_house</code>开头的，<code>front_of_house</code>模块和<code>eat_at_restaurant</code>函数定义在同一层级。这和文件系统中，使用相同层级文件的引入方式类似。<p>具体使用哪种方式调用模块取决于你的项目结构。通常倾向于使用绝对路径，这种调用方式下，代码定义和模块引用更加独立。<p>目前这个代码还是编译不通过的，编译器此时会报错说 hosting 模块是 private 的。此时我们的调用路径没有错，但是我们并没有该模块的访问权限。<p>模块不光能很好的组织代码，它同时具有定义<em>privacy boundary</em>权限界限的功能。具体的实现代码不允许外部代码访问，调用和依赖。如果你想让你的某些内容变为私有，将它封装到一个模块里就行。<p>Rust 权限系统默认所有实体（方法、结构体、变量、枚举等）都是私有的。父模块中不能调用子模块的内容，但是子模块可以调用父模块的内容。原因在于子模块隐藏了自己的实现细节，但是它可以访问自己定义所在的上下文环境。<h3 id=exposing-paths-with-the-pub-keyword>Exposing Paths with the pub Keyword</h3><p>我们可以使用<code>pub</code>关键字将默认私有的内容对外暴露。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}
</code></pre><p>此时编译代码，编译器依旧报错，此时错误是函数<code>add_to_waitlist</code>是私有的。<code>pub</code>模块对外暴露模块时，它里面的内容依旧默认是私有的。<p>因此把<code>add_to_waitlist</code>函数也用<code>pub</code>关键字修饰。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
</code></pre><p>我们再通过绝对路径和相对路径回顾一下引用过程。<p>在绝对路径中，路径用模块树的根节点<code>crate</code>开头。然后是定义在根节点中的<code>front_of_house</code>模块。<code>front_of_house</code>是私有模块，但是由于<code>eat_at_restaurant</code>模块是跟它定义在同一个模块中的，因此在他们之间可以调用。接下来是<code>hosting</code>公共模块，最后是<code>ad_to_waitlist</code>公共方法，此时函数调用生效。<p>在相对路径中，除了第一步以外。其余逻辑和绝对路径中是一样的。相对路径中使用<code>front_of_house</code>作为路径的开头。<code>front_of_house</code>和<code>eat_at_restaurant</code>是定义在同一个模块中的，因此以它们的父模块作为相对路径的开始是正常的。<h3 id=starting-relative-paths-with-super>Starting Relative Paths with super</h3><p>我们可以使用<code>super</code>关键字来代表父模块。这个关键字和文件系统中的<code>..</code>语法类似。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
</code></pre><p><code>fix_incorrect_order</code>函数定义在<code>back_of_house</code>模块中。可以使用<code>super</code>进入到它的父模块<code>crate</code>，也就是根模块中。在根模块中就可以引用到<code>serve_order</code>方法了。<h3 id=making-structs-and-enums-public>Making Structs and Enums Public</h3><p><code>pub</code>关键字也可以用来修饰结构体和枚举，但是另外有一些细节需要注意。<code>pub</code>关键字修饰的结构体，它的字段依旧是私有的。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,

        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Beakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");

    meal.toast = String::from("Wheat");

    println!("I'd like {} toast please", meal.toast);
}
</code></pre><p>在<code>eat_at_restaurant</code>函数中可以访问<code>back_of_house::Breakfast</code>的<code>toast</code>字段，因为它是公开的，但是我们不能访问<code>seasonal_fruit</code>字段，因为字段默认都是私有的。同时，由于<code>back_of_house::Breakfast</code>具有一个私有字段，因此这个结构体需要提供一个作用类似于工厂函数的方法，用来创建实例，这里是<code>summer</code>方法。如果结构体没有提供这样的方法，那么我们将无法实例化它，因为在外部无法对私有字段进行赋值。<p>在枚举类型中，<code>pub</code>字段修饰的枚举类型，它下面的字段同时也都是公开的。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }

    pub fn eat_at_restaurant() {
        let order1 = back_of_house::Appetizer::Soup;
        let order2 = back_of_house::APpetizer::Salad;
    }
}
</code></pre><p>如果<code>enum</code>里的字段是私有的，那么这个 enum 就没有任何的意义，所有当<code>enum</code>被修饰为<code>pub</code>时，它内部的字段都自动转为公开。<h2 id=section-4-bringing-paths-into-scope-with-the-use-keyword>Section 4 - Bringing Paths into Scope with the use Keyword</h2><p>之前的例子中，我们写的模块引用代码中，模块路径很长而且很多内容都是重复的。使用<code>use</code>关键字将模块路径导入到当前模块中，可以解决这个问题。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre><p>使用<code>use</code>关键字和一个路径名称，类似于文件系统中创建一个符号链接。也可以通过<code>use</code>关键字引入一个相对路径：<code>use self::front_of_house::hosting;</code>。<h3 id=creating-idiomatic-use-paths>Creating Idiomatic use Paths</h3><p>思考一个问题——为什么要通过<code>use crate::front_of_house::hosting</code>引入模块然后再通过<code>hosting</code>模块调用<code>eat_at_restaurant</code>方法。而不是直接引入<code>eat_at_restaurant</code>方法进行调用呢？引入要调用函数的父模块是惯用的方式，因为这样能让我们在调用时清楚的知道这个函数的归属。而引入结构体、枚举以及一些其他内容时，惯用的方式是直接引入全部的路径。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre><p>这里没有强制性的要求，只不过这种方式是 Rust 代码惯用的方式。<p>有一种例外情况是，我们引入了两个模块中名称相同的两个内容，此时需要明确其父模块，因为 Rust 是不允许同名的。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::fmt;
use std::io;

fn function1() -> fmt::Result{}

fn function2() -> io::Result{}
</code></pre><h3 id=providing-new-names-with-the-as-keyword>Providing New Names with the as Keyword</h3><p>引入不同模块的同名内容的另一个解决方案是通过<code>as</code>关键字对其重新命名一个本地使用名称，或者说是别名。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result{}

fn function2() -> IoResult<()>{}
</code></pre><h3 id=re-exporting-names-with-pub-use>Re-exporting Names with pub use</h3><p>当我们使用<code>use</code>关键字引入一个模块时，它仅在当前模块中是可用的。为了让调用我们自己模块的代码也能够使用这个模块名称，我们可以通过<code>pub use</code>关键字对其进行二次导出。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre><h3 id=using-nested-paths-to-clean-up-large-use-lists>Using Nested Paths to Clean Up Large use Lists</h3><p>如果我们引入一个模块中的多个内容，每行引入一个模块会让我们的文件内容变得很长。例如：<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::cmp::Ordering;
use std::io;
</code></pre><p>可以通过嵌套的方式引入同一个模块中的多个内容。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::{cmp::Ordering, io};
</code></pre><p>在大型项目中，这种方式能有效减少 use 语句的数量。同时嵌套引用允许我们在任意的层级进行嵌套。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::io::{self, Write};
</code></pre><h3 id=the-glob-operator>The Glob Operator</h3><p>如果想要引入模块下的所有<code>pub</code>的内容，可以使用通配符<code>*</code>。<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::collections::*;
</code></pre><p>这种方式需要谨慎使用，因为有可能会跟你本地的一些名称冲突。这种引入方式一般用在测试模块中。<h2 id=section-5-separating-modules-into-different-files>Section 5 - Separating Modules into Different Files</h2><p>当模块越来越大，你就需要分别将这些代码分割到不同的文件中去了。<p>src/lib.rs<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre><p>src/front_of_house.rs<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre><p>在<code>mod front_of_house</code>后接一个分号，此时 Rust 会加载跟这个模块名称相同的文件内容。我们可以将 front_of_house 文件再分割。<p>src/front_of_house.rs<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>pub mod hosting;
</code></pre><p>src/front_of_house/hosting.rs<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>pub fn add_to_waitlist() {}
</code></pre></div><footer class=post-tags><a class=tag href=/tags/rust>#Rust</a></footer></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme</div></footer><script defer src=https://leokang28.github.io/js/script.js></script>