<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Nodejs setTimeout(fn, 0) 和 setImmediate 哪个先执行以及延伸思考 | KSLEO</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.35aebc44.css" as="style"><link rel="preload" href="/assets/js/app.6f46cf57.js" as="script"><link rel="preload" href="/assets/js/2.49ce1412.js" as="script"><link rel="preload" href="/assets/js/21.88ceead5.js" as="script"><link rel="prefetch" href="/assets/js/10.86ad4e85.js"><link rel="prefetch" href="/assets/js/11.e7ef91a0.js"><link rel="prefetch" href="/assets/js/12.14d347b9.js"><link rel="prefetch" href="/assets/js/13.beaf8085.js"><link rel="prefetch" href="/assets/js/14.e42e08a4.js"><link rel="prefetch" href="/assets/js/15.41e8c95f.js"><link rel="prefetch" href="/assets/js/16.e8b84c5d.js"><link rel="prefetch" href="/assets/js/17.4d574f20.js"><link rel="prefetch" href="/assets/js/18.a8a8e164.js"><link rel="prefetch" href="/assets/js/19.118b3a66.js"><link rel="prefetch" href="/assets/js/20.ccdc0717.js"><link rel="prefetch" href="/assets/js/22.500d3be7.js"><link rel="prefetch" href="/assets/js/23.b7ca339b.js"><link rel="prefetch" href="/assets/js/24.0360313a.js"><link rel="prefetch" href="/assets/js/25.6083b636.js"><link rel="prefetch" href="/assets/js/26.1bd9d3eb.js"><link rel="prefetch" href="/assets/js/27.beb716dd.js"><link rel="prefetch" href="/assets/js/28.bb093ca6.js"><link rel="prefetch" href="/assets/js/29.5b527549.js"><link rel="prefetch" href="/assets/js/3.8a6c11df.js"><link rel="prefetch" href="/assets/js/30.796276de.js"><link rel="prefetch" href="/assets/js/31.666b101e.js"><link rel="prefetch" href="/assets/js/32.654129d9.js"><link rel="prefetch" href="/assets/js/33.e479db51.js"><link rel="prefetch" href="/assets/js/4.e2a8d64a.js"><link rel="prefetch" href="/assets/js/5.dd4c966a.js"><link rel="prefetch" href="/assets/js/6.00a6c78e.js"><link rel="prefetch" href="/assets/js/7.9330d48e.js"><link rel="prefetch" href="/assets/js/8.560dd961.js"><link rel="prefetch" href="/assets/js/9.da6c1180.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35aebc44.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">KSLEO</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/directory/" class="nav-link">
  笔记📒
</a></div><div class="nav-item"><a href="http://leokang28.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客🔗
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="nodejs-settimeout-fn-0-和-setimmediate-哪个先执行以及延伸思考"><a href="#nodejs-settimeout-fn-0-和-setimmediate-哪个先执行以及延伸思考" class="header-anchor">#</a> Nodejs setTimeout(fn, 0) 和 setImmediate 哪个先执行以及延伸思考</h1> <p>不论面试还是闲来看博客，基本都遇到过关于这个问题的讨论。某一天心血来潮做了一系列的代码实验和资料查阅，可能不是很全面，但应该能说明问题，而且纯个人见解，读到这篇文章的大佬如果有不同的看法，或者认为我哪个部分理解有问题导致错误，可以讨论并帮我指正。</p> <h2 id="settimeout-fn-0-vs-setimmediate"><a href="#settimeout-fn-0-vs-setimmediate" class="header-anchor">#</a> setTimeout(fn, 0) vs setImmediate</h2> <ul><li><p>这里有一个 stackoverflow 的解答，但我的个人结论跟他不太一样。
<a href="https://stackoverflow.com/questions/24117267/nodejs-settimeoutfn-0-vs-setimmediatefn" target="_blank" rel="noopener noreferrer">NodeJS - setTimeout(fn,0) vs setImmediate(fn)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>自己的结论</p> <p><s>setTimeout 和 setImmediate 两个事件注册之后（在同步代码或者同一轮事件循环中注册的），重点在于 setTimeout 注册之后</s></p> <p>经过又一次测试，发现之前的描述不是很恰当。新的结论为：执行顺序与两种事件的注册位置和注册之后的同步代码耗时有关。</p> <ul><li><p>在同步代码中注册，或者在微任务中注册（<code>process.nextTick</code>或者<code>Promise.then</code>），或者在<code>setImmediate</code>中注册：</p> <ol><li>有耗时的同步代码，并且耗时超过了 Timeout 设定的时间，那么前者先执行；否则后者先执行。</li> <li>没有耗时的同步代码，那么执行顺序将不确定。</li></ol></li> <li><p>在其他异步事件中注册(setInterval, 异步io回调等)：</p> <p>无论如何都是后者先执行</p></li></ul></li> <li><p>测试代码 1（执行斐波那契计算，增加同步耗时）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">500000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行结果</p> <p><img src="https://gitee.com/ksleo/source/raw/master/QQ20200805-235203@2x.png" alt="https://gitee.com/ksleo/source/raw/master/WeWork%20Helper20191112014007.png"></p> <p>其余注册情况的执行可以自行测试。</p></li></ul> <p>部分斐波那契计算没有超过 <span style="color:red;">1ms</span> 却还是 timer 先执行了，我这里没有列出。是因为除了我们自己的同步任务，node 还有自己的同步流程需要耗时，这些时间要一起考虑。</p> <ul><li><p>测试代码 2（没有自己的同步代码执行，耗时主要在 node 自己的同步流程中）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行结果</p> <p><img src="https://gitee.com/ksleo/source/raw/master/QQ20200805-235141@2x.png" alt="https://gitee.com/ksleo/source/master/3DAC55C6-A0BB-4D93-BFD2-2B2A4672881B.png"></p> <p>其余注册情况的执行可以自行测试。</p></li></ul> <p>可以看出执行顺序不确定了，因此我认为是因为 node 内部的同步耗时不确定导致。</p> <p>上面提到一个时间：1ms。引发一个问题：我们定义的 timer 是 0ms，跟 1ms 有什么关系？这涉及到了 setTimeout 的具体实现。
<a href="https://github.com/nodejs/node/blob/e66a2acc4cb9fc09fc32d1833b89ae56468a0931/lib/internal/timers.js#L152" target="_blank" rel="noopener noreferrer">Timer 对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。setTimeout 执行时，我们设置的延迟时间会被 Timer 校验，而 0 是一个非法参数，Timer 会自动将其设成 1。这就是我们上面 1ms 的由来，所以 <code>setTimeout(fn, 0)</code>实际上是 <code>setTimeout(fn, 1)</code></p> <p>所以以上就是我对这个问题的解答了。</p> <h2 id="延伸"><a href="#延伸" class="header-anchor">#</a> 延伸</h2> <p>我后续查阅了许多内容，想从更深入的角度理解为什么是这样？node 的 Event Loop 是什么样的逻辑？</p> <h3 id="libuv"><a href="#libuv" class="header-anchor">#</a> libuv</h3> <p>关于 node 中 Event Loop 和 libuv 的细节和概念，主要参考了文章<a href="https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810" target="_blank" rel="noopener noreferrer">Event Loop and the Big Picture — NodeJS Event Loop Part 1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h4 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h4> <p>一切 I/O 请求会生成一个失败/成功或者其他触发器，这个触发器就是事件（Event），事件的执行由一个算法管理，算法大致流程如下描述：</p> <ol><li>事件收发器（Event demultiplexr） I/O 请求并交给对应的硬件执行（网络、硬盘等）</li> <li>一旦上述请求执行完毕，事件收发器会为该请求注册相对应的回调，压入事件队列等待被执行。这些回调就是事件（event），事件被压入的队列就是事件队列（Event Queue）</li> <li>事件队列中的回调会按注册顺序依次执行，知道队列清空。</li> <li>事件队列中全部执行完毕或者事件收发器没有接收新请求，结束流程，否则从第一步继续循环。</li></ol> <p>管理和调度这整个机制的程序就是事件循环（Event Loop）。</p> <p><img src="https://gitee.com/ksleo/source/raw/master/1_3fzASvL5gFrSC64hHKzQOQ.jpeg" alt="event loop"></p> <p>这只是对 node 的一个宏观概览，内部细节要复杂很多。</p> <h4 id="event-demultiplexr"><a href="#event-demultiplexr" class="header-anchor">#</a> Event demultiplexr</h4> <p>这是一个设计模式中的抽象概念，在不同的系统中有不同的实现（Linux 下的 epoll、windows 下的 IOCP 等）。Node 对不同平台的差异化在底层做了处理，对 Node 的上层调用者暴露统一的接口。</p> <p>就算在统一操作系统下，不同类型的 I/O 处理起来的逻辑也会有很大区别，比如一些 I/O 硬件层面就实现了异步功能，而某些类型 I/O 原生就不支持异步，Node 为此引入了 Thread Pool 的解决方案。并且将所有的解决方案整合，最终成为 Node 的异步 I/O 模型。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>某些开发者会有一个误解：Node 中的异步 I/O 全部是通过线程池的方式实现的。
文件IO走线程池，通过pipe和主线程epoll建立联系。
其余IO则是直接epoll监听</p></div> <p>要管理这些流程，并且抹平跨平台的差异，暴露统一接口，Node 引入了一个抽象中间层，libuv。libuv 提供了整个 Node 的事件循环功能。</p> <h4 id="event-queue"><a href="#event-queue" class="header-anchor">#</a> Event Queue</h4> <p>上面已经提到 demultiplexr 会把回调压入事件队列，这个事件队列就是由 libuv 提供的一个数据结构，并且由 Event Loop 去调度这个队列。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>Event Queue 不是简单的一个队列，它包括很多的子队列，这些子队列的执行顺序也有明确定义。</p></div> <p>libuv Event Loop 提供了四种主要的队列。</p> <ul><li><strong>Expired timers and intervals queue</strong> - setTimeout 和 setInterval 注册的事件</li> <li><strong>IO Events Queue</strong> - 纯 IO 事件</li> <li><strong>Immediates Queue</strong> - setImmediate 注册的事件</li> <li><strong>Close Handlers Queue</strong> - 任意的 close 事件</li></ul> <p>除了这四种主要的队列，还有两个事件队列。</p> <ul><li><strong>Next Ticks Queue</strong> - <code>process.nextTick</code></li> <li><strong>Other Microtasks Queue</strong> - 例如 Promise.resolve</li></ul> <h4 id="队列的执行顺序"><a href="#队列的执行顺序" class="header-anchor">#</a> 队列的执行顺序</h4> <p>上面列出的参考文章提到，事件循环总是由 Expired timers and intervals queue 开始检查，上面四种主要队列，每一个队列被称之为 Event Loop 的一个阶段（phase）。在一个阶段执行完毕后，会去检查 nextTick 和 microtask 队列。也就是说在一个阶段执行完毕进入下一阶段之前，nextTick 和 microtask 队列都会被检查一遍，并且 nextTick queue 优先执行。</p> <p><img src="https://gitee.com/ksleo/source/raw/master/1_aU5dr98pxTsZ4AMfnA6lNA.png" alt="event queue"></p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>bluebird 等库实现的 Promise 由于其内部的实现方式，不适用此逻辑</p></div> <p>但经我代码测试，从结果来看，该参考文章描述不太准确。不太准确的点在于<code>事件循环从Expired timers and intervals queue开始，进入下一阶段之前检查nextTick和microTask</code>。而我测试结果显示，事件循环的顺序应该是<code>进入每一个阶段之前都进行nextTick和microTask检查</code>。也就是说，程序一开始进入 Expired timers and intervals queue 时就会先进行一次 nextTick 和 microTask 检查，后面会给出关于这个结论的测试代码。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>上面是我自己代码测试然后对比参考文章得出的不同结论，我没有研究 libuv 的源码（能力有限），所以该结论可能会与其他人有出入，若有错误感谢指正。</p></div> <p>到此位置 Event Loop 的逻辑已经算是理的差不多了。下面针对我的结论和原文有出入的地方，给出测试代码和执行结果。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> fd <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">openSync</span><span class="token punctuation">(</span><span class="token string">'./package.json'</span><span class="token punctuation">)</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise in immediate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nexttick in immediate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise in close event'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nexttick in close event'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer'</span><span class="token punctuation">)</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise in timer'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nexttick in timer'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">50000</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nexttick1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nexttick2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">说明</p> <p>这里 timer 注册后我加入了一段斐波那契计算，主要是为了证明，timer 后执行并不是因为同步耗时没有到超时时间，而的确是 nextTick 和 microtask 先执行了。</p></div> <p>执行结果</p> <p><img src="https://gitee.com/ksleo/source/raw/master/QQ20200805-234908@2x.png" alt="event loop test code"></p> <h4 id="其他问题"><a href="#其他问题" class="header-anchor">#</a> 其他问题</h4> <ul><li><p>如果改变了上面代码的顺序，会不会有不同的结果呢？</p> <p>不会。因为 setTimeout 等代码只是在注册回调而已（事件进队）。具体的逻辑是在回调（Event）当中定义的，运行得到的结果也是回调返回的结果，而回调执行的顺序严格按照 libuv Event Loop 的定义。</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f46cf57.js" defer></script><script src="/assets/js/2.49ce1412.js" defer></script><script src="/assets/js/21.88ceead5.js" defer></script>
  </body>
</html>
